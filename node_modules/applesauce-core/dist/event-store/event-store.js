import { kinds } from "nostr-tools";
import { isAddressableKind } from "nostr-tools/kinds";
import { EMPTY, filter, finalize, from, merge, mergeMap, ReplaySubject, share, take, timer } from "rxjs";
import hash_sum from "hash-sum";
import { getDeleteCoordinates, getDeleteIds } from "../helpers/delete.js";
import { createReplaceableAddress, EventStoreSymbol, FromCacheSymbol, isReplaceable } from "../helpers/event.js";
import { getExpirationTimestamp } from "../helpers/expiration.js";
import { matchFilters } from "../helpers/filter.js";
import { parseCoordinate } from "../helpers/pointers.js";
import { addSeenRelay, getSeenRelays } from "../helpers/relays.js";
import { unixNow } from "../helpers/time.js";
import { UserBlossomServersModel } from "../models/blossom.js";
import { EventModel, EventsModel, ReplaceableModel, ReplaceableSetModel, TimelineModel } from "../models/common.js";
import { ContactsModel } from "../models/contacts.js";
import { CommentsModel, ThreadModel } from "../models/index.js";
import { MailboxesModel } from "../models/mailboxes.js";
import { MuteModel } from "../models/mutes.js";
import { ProfileModel } from "../models/profile.js";
import { ReactionsModel } from "../models/reactions.js";
import { EventSet } from "./event-set.js";
/** An extended {@link EventSet} that handles replaceable events, delets, and models */
export class EventStore {
    database;
    /** Enable this to keep old versions of replaceable events */
    keepOldVersions = false;
    /** Enable this to keep expired events */
    keepExpired = false;
    /**
     * A method used to verify new events before added them
     * @returns true if the event is valid, false if it should be ignored
     */
    verifyEvent;
    /** A stream of new events added to the store */
    insert$;
    /** A stream of events that have been updated */
    update$;
    /** A stream of events that have been removed */
    remove$;
    /**
     * A method that will be called when an event isn't found in the store
     * @experimental
     */
    eventLoader;
    /**
     * A method that will be called when a replaceable event isn't found in the store
     * @experimental
     */
    replaceableLoader;
    /**
     * A method that will be called when an addressable event isn't found in the store
     * @experimental
     */
    addressableLoader;
    constructor() {
        this.database = new EventSet();
        // verify events before they are added to the database
        this.database.onBeforeInsert = (event) => {
            // Ignore events that are invalid
            if (this.verifyEvent && this.verifyEvent(event) === false)
                return false;
            else
                return true;
        };
        // when events are added to the database, add the symbol
        this.database.insert$.subscribe((event) => {
            Reflect.set(event, EventStoreSymbol, this);
        });
        // when events are removed from the database, remove the symbol
        this.database.remove$.subscribe((event) => {
            Reflect.deleteProperty(event, EventStoreSymbol);
        });
        this.insert$ = this.database.insert$;
        this.update$ = this.database.update$;
        this.remove$ = this.database.remove$;
    }
    // delete state
    deletedIds = new Set();
    deletedCoords = new Map();
    checkDeleted(event) {
        if (typeof event === "string")
            return this.deletedIds.has(event);
        else {
            if (this.deletedIds.has(event.id))
                return true;
            if (isAddressableKind(event.kind)) {
                const identifier = event.tags.find((t) => t[0] === "d")?.[1];
                const deleted = this.deletedCoords.get(createReplaceableAddress(event.kind, event.pubkey, identifier));
                if (deleted)
                    return deleted > event.created_at;
            }
        }
        return false;
    }
    expirations = new Map();
    /** Adds an event to the expiration map */
    addExpiration(event) {
        const expiration = getExpirationTimestamp(event);
        if (expiration && Number.isFinite(expiration))
            this.expirations.set(event.id, expiration);
    }
    expirationTimeout = null;
    nextExpirationCheck = null;
    handleExpiringEvent(event) {
        const expiration = getExpirationTimestamp(event);
        if (!expiration)
            return;
        // Add event to expiration map
        this.expirations.set(event.id, expiration);
        // Exit if the next check is already less than the next expiration
        if (this.expirationTimeout && this.nextExpirationCheck && this.nextExpirationCheck < expiration)
            return;
        // Set timeout to prune expired events
        if (this.expirationTimeout)
            clearTimeout(this.expirationTimeout);
        const timeout = expiration - unixNow();
        this.expirationTimeout = setTimeout(this.pruneExpired.bind(this), timeout * 1000 + 10);
        this.nextExpirationCheck = expiration;
    }
    /** Remove expired events from the store */
    pruneExpired() {
        const now = unixNow();
        for (const [id, expiration] of this.expirations) {
            if (expiration <= now) {
                this.expirations.delete(id);
                this.remove(id);
            }
        }
        // Cleanup timers
        if (this.expirationTimeout)
            clearTimeout(this.expirationTimeout);
        this.nextExpirationCheck = null;
        this.expirationTimeout = null;
    }
    // handling delete events
    handleDeleteEvent(deleteEvent) {
        const ids = getDeleteIds(deleteEvent);
        for (const id of ids) {
            this.deletedIds.add(id);
            // remove deleted events in the database
            const event = this.database.getEvent(id);
            if (event)
                this.database.remove(event);
        }
        const coords = getDeleteCoordinates(deleteEvent);
        for (const coord of coords) {
            this.deletedCoords.set(coord, Math.max(this.deletedCoords.get(coord) ?? 0, deleteEvent.created_at));
            // Parse the nostr address coordinate
            const parsed = parseCoordinate(coord);
            if (!parsed)
                continue;
            // Remove older versions of replaceable events
            const events = this.database.getReplaceableHistory(parsed.kind, parsed.pubkey, parsed.identifier) ?? [];
            for (const event of events) {
                if (event.created_at < deleteEvent.created_at)
                    this.database.remove(event);
            }
        }
    }
    /** Copies important metadata from and identical event to another */
    static mergeDuplicateEvent(source, dest) {
        const relays = getSeenRelays(source);
        if (relays) {
            for (const relay of relays)
                addSeenRelay(dest, relay);
        }
        // copy the from cache symbol only if its true
        const fromCache = Reflect.get(source, FromCacheSymbol);
        if (fromCache && !Reflect.get(dest, FromCacheSymbol))
            Reflect.set(dest, FromCacheSymbol, fromCache);
    }
    /**
     * Adds an event to the store and update subscriptions
     * @returns The existing event or the event that was added, if it was ignored returns null
     */
    add(event, fromRelay) {
        if (event.kind === kinds.EventDeletion)
            this.handleDeleteEvent(event);
        // Ignore if the event was deleted
        if (this.checkDeleted(event))
            return event;
        // Reject expired events if keepExpired is false
        const expiration = getExpirationTimestamp(event);
        if (this.keepExpired === false && expiration && expiration <= unixNow())
            return null;
        // Get the replaceable identifier
        const identifier = isReplaceable(event.kind) ? event.tags.find((t) => t[0] === "d")?.[1] : undefined;
        // Don't insert the event if there is already a newer version
        if (!this.keepOldVersions && isReplaceable(event.kind)) {
            const existing = this.database.getReplaceableHistory(event.kind, event.pubkey, identifier);
            // If there is already a newer version, copy cached symbols and return existing event
            if (existing && existing.length > 0 && existing[0].created_at >= event.created_at) {
                EventStore.mergeDuplicateEvent(event, existing[0]);
                return existing[0];
            }
        }
        else if (this.database.hasEvent(event.id)) {
            // Duplicate event, copy symbols and return existing event
            const existing = this.database.getEvent(event.id);
            if (existing) {
                EventStore.mergeDuplicateEvent(event, existing);
                return existing;
            }
        }
        // Insert event into database
        const inserted = this.database.add(event);
        // If the event was ignored, return null
        if (inserted === null)
            return null;
        // Copy cached data if its a duplicate event
        if (event !== inserted)
            EventStore.mergeDuplicateEvent(event, inserted);
        // attach relay this event was from
        if (fromRelay)
            addSeenRelay(inserted, fromRelay);
        // remove all old version of the replaceable event
        if (!this.keepOldVersions && isReplaceable(event.kind)) {
            const existing = this.database.getReplaceableHistory(event.kind, event.pubkey, identifier);
            if (existing) {
                const older = Array.from(existing).filter((e) => e.created_at < event.created_at);
                for (const old of older)
                    this.database.remove(old);
                // return the newest version of the replaceable event
                // most of the time this will be === event, but not always
                if (existing.length !== older.length)
                    return existing[0];
            }
        }
        // Add event to expiration map
        if (this.keepExpired === false && expiration)
            this.handleExpiringEvent(inserted);
        return inserted;
    }
    /** Removes an event from the database and updates subscriptions */
    remove(event) {
        return this.database.remove(event);
    }
    /** Add an event to the store and notifies all subscribes it has updated */
    update(event) {
        return this.database.update(event);
    }
    /** Removes any event that is not being used by a subscription */
    prune(max) {
        return this.database.prune(max);
    }
    /** Check if the store has an event by id */
    hasEvent(id) {
        return this.database.hasEvent(id);
    }
    /** Get an event by id from the store */
    getEvent(id) {
        return this.database.getEvent(id);
    }
    /** Check if the store has a replaceable event */
    hasReplaceable(kind, pubkey, d) {
        return this.database.hasReplaceable(kind, pubkey, d);
    }
    /** Gets the latest version of a replaceable event */
    getReplaceable(kind, pubkey, identifier) {
        return this.database.getReplaceable(kind, pubkey, identifier);
    }
    /** Returns all versions of a replaceable event */
    getReplaceableHistory(kind, pubkey, identifier) {
        return this.database.getReplaceableHistory(kind, pubkey, identifier);
    }
    /** Get all events matching a filter */
    getByFilters(filters) {
        return this.database.getByFilters(filters);
    }
    /** Returns a timeline of events that match filters */
    getTimeline(filters) {
        return this.database.getTimeline(filters);
    }
    /** Sets the claim on the event and touches it */
    claim(event, claim) {
        this.database.claim(event, claim);
    }
    /** Checks if an event is claimed by anything */
    isClaimed(event) {
        return this.database.isClaimed(event);
    }
    /** Removes a claim from an event */
    removeClaim(event, claim) {
        this.database.removeClaim(event, claim);
    }
    /** Removes all claims on an event */
    clearClaim(event) {
        this.database.clearClaim(event);
    }
    /** A directory of all active models */
    models = new Map();
    /** How long a model should be kept "warm" while nothing is subscribed to it */
    modelKeepWarm = 60_000;
    /** Get or create a model on the event store */
    model(constructor, ...args) {
        let models = this.models.get(constructor);
        if (!models) {
            models = new Map();
            this.models.set(constructor, models);
        }
        const key = constructor.getKey ? constructor.getKey(...args) : hash_sum(args);
        let model = models.get(key);
        // Create the model if it does not exist
        if (!model) {
            const cleanup = () => {
                // Remove the model from the cache if its the same one
                if (models.get(key) === model)
                    models.delete(key);
            };
            model = constructor(...args)(this).pipe(
            // remove the model when its unsubscribed
            finalize(cleanup), 
            // only subscribe to models once for all subscriptions
            share({
                connector: () => new ReplaySubject(1),
                resetOnComplete: () => timer(this.modelKeepWarm),
                resetOnRefCountZero: () => timer(this.modelKeepWarm),
            }));
            // Add the model to the cache
            models.set(key, model);
        }
        return model;
    }
    /**
     * Creates an observable that streams all events that match the filter
     * @param filters
     * @param [onlyNew=false] Only subscribe to new events
     */
    filters(filters, onlyNew = false) {
        filters = Array.isArray(filters) ? filters : [filters];
        return merge(
        // merge existing events
        onlyNew ? EMPTY : from(this.getByFilters(filters)), 
        // subscribe to future events
        this.insert$.pipe(filter((e) => matchFilters(filters, e))));
    }
    /** Returns an observable that completes when an event is removed */
    removed(id) {
        const deleted = this.checkDeleted(id);
        if (deleted)
            return EMPTY;
        return this.remove$.pipe(
        // listen for removed events
        filter((e) => e.id === id), 
        // complete as soon as we find a matching removed event
        take(1), 
        // switch to empty
        mergeMap(() => EMPTY));
    }
    /** Creates an observable that emits when event is updated */
    updated(event) {
        return this.database.update$.pipe(filter((e) => e.id === event || e === event));
    }
    // Helper methods for creating models
    /** Creates a {@link EventModel} */
    event(pointer) {
        if (typeof pointer === "string")
            pointer = { id: pointer };
        return this.model(EventModel, pointer);
    }
    replaceable(...args) {
        let pointer;
        // Parse arguments
        if (args.length === 1) {
            pointer = args[0];
        }
        else if (args.length === 3 || args.length === 2) {
            let [kind, pubkey, identifier] = args;
            pointer = { kind, pubkey, identifier };
        }
        if (!pointer)
            throw new Error("Invalid arguments, expected address pointer or kind, pubkey, identifier");
        return this.model(ReplaceableModel, pointer);
    }
    /** Subscribe to an addressable event by pointer */
    addressable(pointer) {
        return this.model(ReplaceableModel, pointer);
    }
    /** Creates a {@link TimelineModel} */
    timeline(filters, includeOldVersion = false) {
        return this.model(TimelineModel, filters, includeOldVersion);
    }
    /** Subscribe to a users profile */
    profile(user) {
        return this.model(ProfileModel, user);
    }
    /** Subscribe to a users contacts */
    contacts(user) {
        if (typeof user === "string")
            user = { pubkey: user };
        return this.model(ContactsModel, user);
    }
    /** Subscribe to a users mutes */
    mutes(user) {
        if (typeof user === "string")
            user = { pubkey: user };
        return this.model(MuteModel, user);
    }
    /** Subscribe to a users NIP-65 mailboxes */
    mailboxes(user) {
        if (typeof user === "string")
            user = { pubkey: user };
        return this.model(MailboxesModel, user);
    }
    /** Subscribe to a users blossom servers */
    blossomServers(user) {
        if (typeof user === "string")
            user = { pubkey: user };
        return this.model(UserBlossomServersModel, user);
    }
    /** Subscribe to an event's reactions */
    reactions(event) {
        return this.model(ReactionsModel, event);
    }
    /** Subscribe to a thread */
    thread(root) {
        return this.model(ThreadModel, root);
    }
    /** Subscribe to a event's comments */
    comments(event) {
        return this.model(CommentsModel, event);
    }
    /** @deprecated use multiple {@link EventModel} instead */
    events(ids) {
        return this.model(EventsModel, ids);
    }
    /** @deprecated use multiple {@link ReplaceableModel} instead */
    replaceableSet(pointers) {
        return this.model(ReplaceableSetModel, pointers);
    }
}

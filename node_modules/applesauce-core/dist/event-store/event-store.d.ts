import { Filter, NostrEvent } from "nostr-tools";
import { AddressPointer, EventPointer } from "nostr-tools/nip19";
import { Observable, Subject } from "rxjs";
import { AddressPointerWithoutD } from "../helpers/pointers.js";
import { EventMemory } from "./event-memory.js";
import { IEventDatabase, IEventStore } from "./interface.js";
declare const EventStore_base: {
    new (...args: any[]): {
        [x: string]: any;
        models: Map<import("./interface.js").ModelConstructor<any, any[], IEventStore | import("./interface.js").IAsyncEventStore>, Map<string, Observable<any>>>;
        modelKeepWarm: number;
        model<T extends unknown, Args extends Array<any>>(constructor: import("./interface.js").ModelConstructor<T, Args, IEventStore | import("./interface.js").IAsyncEventStore>, ...args: Args): Observable<T>;
        filters(filters: Filter | Filter[], onlyNew?: boolean): Observable<NostrEvent>;
        event(pointer: string | EventPointer): Observable<NostrEvent | undefined>;
        replaceable(pointer: AddressPointer | AddressPointerWithoutD): Observable<NostrEvent | undefined>;
        replaceable(kind: number, pubkey: string, identifier?: string): Observable<NostrEvent | undefined>;
        addressable(pointer: AddressPointer): Observable<NostrEvent | undefined>;
        timeline(filters: Filter | Filter[], includeOldVersion?: boolean): Observable<NostrEvent[]>;
        profile(user: string | import("nostr-tools/nip19").ProfilePointer): Observable<import("../helpers/profile.js").ProfileContent | undefined>;
        contacts(user: string | import("nostr-tools/nip19").ProfilePointer): Observable<import("nostr-tools/nip19").ProfilePointer[]>;
        mutes(user: string | import("nostr-tools/nip19").ProfilePointer): Observable<import("../helpers/mutes.js").Mutes | undefined>;
        mailboxes(user: string | import("nostr-tools/nip19").ProfilePointer): Observable<{
            inboxes: string[];
            outboxes: string[];
        } | undefined>;
        blossomServers(user: string | import("nostr-tools/nip19").ProfilePointer): Observable<URL[]>;
        reactions(event: NostrEvent): Observable<import("nostr-tools").Event[]>;
        thread(root: string | EventPointer | AddressPointer): Observable<import("../models/thread.js").Thread>;
        comments(event: NostrEvent): Observable<import("nostr-tools").Event[]>;
        events(ids: string[]): Observable<Record<string, NostrEvent | undefined>>;
        replaceableSet(pointers: {
            kind: number;
            pubkey: string;
            identifier?: string;
        }[]): Observable<Record<string, NostrEvent | undefined>>;
    };
} & {
    new (): {};
};
/** A wrapper around an event database that handles replaceable events, deletes, and models */
export declare class EventStore extends EventStore_base implements IEventStore {
    database: IEventDatabase;
    /** Optional memory database for ensuring single event instances */
    memory?: EventMemory;
    /** Enable this to keep old versions of replaceable events */
    keepOldVersions: boolean;
    /** Enable this to keep expired events */
    keepExpired: boolean;
    /**
     * A method used to verify new events before added them
     * @returns true if the event is valid, false if it should be ignored
     */
    verifyEvent?: (event: NostrEvent) => boolean;
    /** A stream of new events added to the store */
    insert$: Subject<import("nostr-tools").Event>;
    /** A stream of events that have been updated */
    update$: Subject<import("nostr-tools").Event>;
    /** A stream of events that have been removed */
    remove$: Subject<import("nostr-tools").Event>;
    /**
     * A method that will be called when an event isn't found in the store
     * @experimental
     */
    eventLoader?: (pointer: EventPointer) => Observable<NostrEvent> | Promise<NostrEvent | undefined>;
    /**
     * A method that will be called when a replaceable event isn't found in the store
     * @experimental
     */
    replaceableLoader?: (pointer: AddressPointerWithoutD) => Observable<NostrEvent> | Promise<NostrEvent | undefined>;
    /**
     * A method that will be called when an addressable event isn't found in the store
     * @experimental
     */
    addressableLoader?: (pointer: AddressPointer) => Observable<NostrEvent> | Promise<NostrEvent | undefined>;
    constructor(database?: IEventDatabase);
    /** A method to add all events to memory to ensure there is only ever a single instance of an event */
    private mapToMemory;
    protected deletedIds: Set<string>;
    protected deletedCoords: Map<string, number>;
    protected checkDeleted(event: string | NostrEvent): boolean;
    protected expirations: Map<string, number>;
    /** Adds an event to the expiration map */
    protected addExpiration(event: NostrEvent): void;
    protected expirationTimeout: number | null;
    protected nextExpirationCheck: number | null;
    protected handleExpiringEvent(event: NostrEvent): void;
    /** Remove expired events from the store */
    protected pruneExpired(): void;
    protected handleDeleteEvent(deleteEvent: NostrEvent): void;
    /** Copies important metadata from and identical event to another */
    static mergeDuplicateEvent(source: NostrEvent, dest: NostrEvent): void;
    /**
     * Adds an event to the store and update subscriptions
     * @returns The existing event or the event that was added, if it was ignored returns null
     */
    add(event: NostrEvent, fromRelay?: string): NostrEvent | null;
    /** Removes an event from the store and updates subscriptions */
    remove(event: string | NostrEvent): boolean;
    /** Add an event to the store and notifies all subscribes it has updated */
    update(event: NostrEvent): boolean;
    /** Check if the store has an event by id */
    hasEvent(id: string): boolean;
    /** Get an event by id from the store */
    getEvent(id: string): NostrEvent | undefined;
    /** Check if the store has a replaceable event */
    hasReplaceable(kind: number, pubkey: string, d?: string): boolean;
    /** Gets the latest version of a replaceable event */
    getReplaceable(kind: number, pubkey: string, identifier?: string): NostrEvent | undefined;
    /** Returns all versions of a replaceable event */
    getReplaceableHistory(kind: number, pubkey: string, identifier?: string): NostrEvent[] | undefined;
    /** Get all events matching a filter */
    getByFilters(filters: Filter | Filter[]): NostrEvent[];
    /** Returns a timeline of events that match filters */
    getTimeline(filters: Filter | Filter[]): NostrEvent[];
    /** Passthrough method for the database.touch */
    touch(event: NostrEvent): void | undefined;
    /** Sets the claim on the event and touches it */
    claim(event: NostrEvent, claim: any): void;
    /** Checks if an event is claimed by anything */
    isClaimed(event: NostrEvent): boolean;
    /** Removes a claim from an event */
    removeClaim(event: NostrEvent, claim: any): void;
    /** Removes all claims on an event */
    clearClaim(event: NostrEvent): void;
    /** Pass through method for the database.unclaimed */
    unclaimed(): Generator<NostrEvent>;
    /** Removes any event that is not being used by a subscription */
    prune(limit?: number): number;
    /** Returns an observable that completes when an event is removed */
    removed(id: string): Observable<never>;
    /** Creates an observable that emits when event is updated */
    updated(event: string | NostrEvent): Observable<NostrEvent>;
}
export {};

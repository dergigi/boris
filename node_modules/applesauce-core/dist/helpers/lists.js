import { isAddressableKind, isReplaceableKind } from "nostr-tools/kinds";
import { getReplaceableIdentifier, isReplaceable } from "./event.js";
import { getHiddenTags } from "./hidden-tags.js";
import { getAddressPointerForEvent, getAddressPointerFromATag, getCoordinateFromAddressPointer, getEventPointerFromETag, getProfilePointerFromPTag, } from "./pointers.js";
import { mergeRelaySets } from "./relays.js";
import { isATag, isETag, isPTag, processTags } from "./tags.js";
export const FAVORITE_RELAYS_KIND = 10012;
/** Returns all the tags of a list or set */
export function getListTags(list, type) {
    switch (type) {
        case "public":
            return list.tags;
        case "hidden":
            return getHiddenTags(list) ?? [];
        default:
        case "all":
            return [...(getHiddenTags(list) ?? []), ...list.tags];
    }
}
/**
 * Checks if an event pointer is anywhere in a list or set
 * NOTE: Ignores the `relay` field in EventPointer
 * @param list - The list or set to check
 * @param pointer - The event pointer to check
 * @param type - Which types of tags to check
 */
export function isEventPointerInList(list, pointer, type) {
    const id = typeof pointer === "string" ? pointer : pointer.id;
    const tags = getListTags(list, type);
    return tags.some((t) => t[0] === "e" && t[1] === id);
}
/**
 * Checks if an address pointer is anywhere in a list or set
 * NOTE: Ignores the `relay` field in AddressPointer
 * @param list - The list or set to check
 * @param pointer - The address pointer to check
 * @param type - Which types of tags to check
 */
export function isAddressPointerInList(list, pointer, type) {
    const cord = typeof pointer === "string" ? pointer : getCoordinateFromAddressPointer(pointer);
    const tags = getListTags(list, type);
    return tags.some((t) => t[0] === "a" && t[1] === cord);
}
/**
 * Checks if an profile pointer is anywhere in a list or set
 * NOTE: Ignores the `relay` field in ProfilePointer
 * @param list - The list or set to check
 * @param pointer - The profile pointer to check
 * @param type - Which types of tags to check
 */
export function isProfilePointerInList(list, pointer, type) {
    const pubkey = typeof pointer === "string" ? pointer : pointer.pubkey;
    const tags = getListTags(list, type);
    return tags.some((t) => t[0] === "p" && t[1] === pubkey);
}
/** Returns if an event is in a list */
export function isEventInList(list, event) {
    return isReplaceable(event.kind)
        ? isAddressPointerInList(list, getAddressPointerForEvent(event))
        : isEventPointerInList(list, event);
}
/**
 * Returns all the EventPointer in a list or set
 * @param list - The list or set to get the event pointers from
 * @param type - Which types of tags to read
 */
export function getEventPointersFromList(list, type) {
    return processTags(getListTags(list, type), (tag) => (isETag(tag) ? tag : undefined), getEventPointerFromETag);
}
/**
 * Returns all the AddressPointer in a list or set
 * @param list - The list or set to get the address pointers from
 * @param type - Which types of tags to read
 */
export function getAddressPointersFromList(list, type) {
    return processTags(getListTags(list, type), (t) => (isATag(t) ? t : undefined), getAddressPointerFromATag);
}
/**
 * Returns all the ProfilePointer in a list or set
 * @param list - The list or set to get the profile pointers from
 * @param type - Which types of tags to read
 */
export function getProfilePointersFromList(list, type) {
    return processTags(getListTags(list, type), (t) => (isPTag(t) ? t : undefined), getProfilePointerFromPTag);
}
/**
 * Returns a deduplicated array of all 'relay' tags in a list or set
 * @param list - The list or set to get the relays from
 * @param type - Which types of tags to read
 */
export function getRelaysFromList(list, type) {
    return mergeRelaySets(processTags(getListTags(list, type), (t) => (t[0] === "relay" ? t[1] : undefined)));
}
/** Returns if an event is a valid list or set */
export function isValidList(event) {
    try {
        if (isAddressableKind(event.kind)) {
            // event is a set
            // ensure the set has an identifier
            getReplaceableIdentifier(event);
            return true;
        }
        else if (isReplaceableKind(event.kind) && event.kind >= 10000 && event.kind < 20000) {
            // event is a list
            return true;
        }
    }
    catch (error) { }
    return false;
}

import { getOrComputeCachedValue } from "./cache.js";
import { getTagValue } from "./event-tags.js";
import { getProfilePointerFromPTag } from "./pointers.js";
import { isPTag, isRTag, isTTag } from "./tags.js";
// NIP-52 Calendar Event Kinds
export const DATE_BASED_CALENDAR_EVENT_KIND = 31922;
export const TIME_BASED_CALENDAR_EVENT_KIND = 31923;
// Cache symbols for complex operations only
export const CalendarEventLocationsSymbol = Symbol.for("calendar-event-locations");
export const CalendarEventParticipantsSymbol = Symbol.for("calendar-event-participants");
export const CalendarEventHashtagsSymbol = Symbol.for("calendar-event-hashtags");
export const CalendarEventReferencesSymbol = Symbol.for("calendar-event-references");
export const CalendarEventGeohashSymbol = Symbol.for("calendar-event-geohash");
/** Gets the title of a calendar event or calendar */
export function getCalendarEventTitle(event) {
    return getTagValue(event, "title") || getTagValue(event, "name"); // fallback to deprecated "name" tag
}
/** Gets the summary of a calendar event */
export function getCalendarEventSummary(event) {
    return getTagValue(event, "summary");
}
/** Gets the image URL of a calendar event */
export function getCalendarEventImage(event) {
    return getTagValue(event, "image");
}
/** Gets the start Unix timestamp of a calendar event */
export function getCalendarEventStart(event) {
    const value = getTagValue(event, "start");
    if (!value)
        return undefined;
    if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
        return new Date(value).valueOf() / 1000;
    else if (event.kind === TIME_BASED_CALENDAR_EVENT_KIND)
        return parseInt(value);
    else
        return undefined;
}
/** Gets the timezone of the start timestamp of a calendar event */
export function getCalendarEventStartTimezone(event) {
    if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
        return undefined;
    return getTagValue(event, "start_tzid");
}
/** Gets the timezone of the end timestamp of a calendar event */
export function getCalendarEventEndTimezone(event) {
    if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
        return undefined;
    return getTagValue(event, "end_tzid");
}
/** Gets the end Unix timestamp of a calendar event */
export function getCalendarEventEnd(event) {
    const value = getTagValue(event, "end");
    if (!value)
        return undefined;
    if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
        return new Date(value).valueOf() / 1000;
    else if (event.kind === TIME_BASED_CALENDAR_EVENT_KIND)
        return parseInt(value);
    else
        return undefined;
}
/** Gets all locations from a calendar event */
export function getCalendarEventLocations(event) {
    if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
        throw new Error("Event is not a date-based or time-based calendar event");
    return getOrComputeCachedValue(event, CalendarEventLocationsSymbol, () => {
        return event.tags.filter((t) => t[0] === "location" && t[1]).map((t) => t[1]);
    });
}
/** Gets the geohash of a calendar event */
export function getCalendarEventGeohash(event) {
    if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
        throw new Error("Event is not a date-based or time-based calendar event");
    return getOrComputeCachedValue(event, CalendarEventGeohashSymbol, () => {
        let hash = undefined;
        for (const tag of event.tags) {
            if (tag[0] === "g" && tag[1] && (!hash || tag[1].length > hash.length))
                hash = tag[1];
        }
        return hash;
    });
}
/** Gets all participants from a calendar event */
export function getCalendarEventParticipants(event) {
    if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
        throw new Error("Event is not a date-based or time-based calendar event");
    return getOrComputeCachedValue(event, CalendarEventParticipantsSymbol, () => {
        return event.tags.filter(isPTag).map((tag) => ({
            ...getProfilePointerFromPTag(tag),
            // Third index of tag is optional "role"
            role: tag[3] || undefined,
        }));
    });
}
/** Gets all hashtags from a calendar event */
export function getCalendarEventHashtags(event) {
    if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
        throw new Error("Event is not a date-based or time-based calendar event");
    return getOrComputeCachedValue(event, CalendarEventHashtagsSymbol, () => {
        return event.tags.filter(isTTag).map((t) => t[1]);
    });
}
/** Gets all references from a calendar event */
export function getCalendarEventReferences(event) {
    if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
        throw new Error("Event is not a date-based or time-based calendar event");
    return getOrComputeCachedValue(event, CalendarEventReferencesSymbol, () => {
        return event.tags.filter(isRTag).map((t) => t[1]);
    });
}

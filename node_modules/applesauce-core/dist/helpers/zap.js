import { kinds, nip57 } from "nostr-tools";
import { parseBolt11 } from "./bolt11.js";
import { getOrComputeCachedValue } from "./cache.js";
import { getTagValue } from "./event-tags.js";
import { getAddressPointerFromATag, getEventPointerFromETag } from "./pointers.js";
import { isATag, isETag } from "./tags.js";
export const ZapRequestSymbol = Symbol.for("zap-request");
export const ZapSenderSymbol = Symbol.for("zap-sender");
export const ZapReceiverSymbol = Symbol.for("zap-receiver");
export const ZapInvoiceSymbol = Symbol.for("zap-bolt11");
export const ZapEventPointerSymbol = Symbol.for("zap-event-pointer");
export const ZapAddressPointerSymbol = Symbol.for("zap-address-pointer");
export function getZapSender(zap) {
    return getOrComputeCachedValue(zap, ZapSenderSymbol, () => {
        return getTagValue(zap, "P") || getZapRequest(zap)?.pubkey;
    });
}
export function getZapRecipient(zap) {
    return getOrComputeCachedValue(zap, ZapReceiverSymbol, () => {
        return getTagValue(zap, "p");
    });
}
export function getZapPayment(zap) {
    return getOrComputeCachedValue(zap, ZapInvoiceSymbol, () => {
        const bolt11 = getTagValue(zap, "bolt11");
        return bolt11 ? parseBolt11(bolt11) : undefined;
    });
}
export function getZapAmount(zap) {
    return getZapPayment(zap)?.amount;
}
/** Gets the AddressPointer that was zapped */
export function getZapAddressPointer(zap) {
    return getOrComputeCachedValue(zap, ZapAddressPointerSymbol, () => {
        const a = zap.tags.find(isATag);
        return a ? getAddressPointerFromATag(a) : null;
    });
}
/** Gets the EventPointer that was zapped */
export function getZapEventPointer(zap) {
    return getOrComputeCachedValue(zap, ZapEventPointerSymbol, () => {
        const e = zap.tags.find(isETag);
        return e ? getEventPointerFromETag(e) : null;
    });
}
/** Gets the preimage for the bolt11 invoice */
export function getZapPreimage(zap) {
    return getTagValue(zap, "preimage");
}
export function getZapRequest(zap) {
    return getOrComputeCachedValue(zap, ZapRequestSymbol, () => {
        const description = getTagValue(zap, "description");
        if (!description)
            return;
        // Attempt to parse the zap request
        try {
            const error = nip57.validateZapRequest(description);
            if (error)
                return;
            return JSON.parse(description);
        }
        catch (error) {
            return undefined;
        }
    });
}
/**
 * Checks if a zap event is valid (not missing fields)
 * DOES NOT validate LNURL address
 */
export function isValidZap(zap) {
    if (!zap)
        return false;
    if (zap.kind !== kinds.Zap)
        return false;
    // Is not a valid zap kind if any of these is undefined
    if (getZapPayment(zap) === undefined)
        return false;
    if (getZapRequest(zap) === undefined)
        return false;
    if (getZapRecipient(zap) === undefined)
        return false;
    if (getZapSender(zap) === undefined)
        return false;
    return true;
}
/** Returns the zap splits for an event */
export function getZapSplits(event) {
    const tags = event.tags.filter((t) => t[0] === "zap" && t[1] && t[3]);
    if (tags.length > 0) {
        const targets = tags
            .map((t) => ({ pubkey: t[1], relay: t[2], weight: parseFloat(t[3]) }))
            .filter((p) => Number.isFinite(p.weight));
        const total = targets.reduce((v, p) => v + p.weight, 0);
        return targets.map((p) => ({ ...p, percent: p.weight / total }));
    }
    return undefined;
}

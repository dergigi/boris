var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
import { bytesToHex, randomBytes } from '@noble/hashes/utils';
import { BlindedMessage } from './model/BlindedMessage.js';
import { bytesToNumber, getDecodedToken, splitAmount, sumProofs, getKeepAmounts } from './utils.js';
import { hashToCurve, pointFromHex } from '@cashu/crypto/modules/common';
import { blindMessage, constructProofFromPromise, serializeProof } from '@cashu/crypto/modules/client';
import { deriveBlindingFactor, deriveSecret } from '@cashu/crypto/modules/client/NUT09';
import { createP2PKsecret, getSignedProofs } from '@cashu/crypto/modules/client/NUT11';
/**
 * The default number of proofs per denomination to keep in a wallet.
 */
var DEFAULT_DENOMINATION_TARGET = 3;
/**
 * The default unit for the wallet, if not specified in constructor.
 */
var DEFAULT_UNIT = 'sat';
/**
 * Class that represents a Cashu wallet.
 * This class should act as the entry point for this library
 */
var CashuWallet = /** @class */ (function () {
    /**
     * @param mint Cashu mint instance is used to make api calls
     * @param options.unit optionally set unit (default is 'sat')
     * @param options.keys public keys from the mint (will be fetched from mint if not provided)
     * @param options.keysets keysets from the mint (will be fetched from mint if not provided)
     * @param options.mintInfo mint info from the mint (will be fetched from mint if not provided)
     * @param options.denominationTarget target number proofs per denomination (default: see @constant DEFAULT_DENOMINATION_TARGET)
     * @param options.bip39seed BIP39 seed for deterministic secrets.
     * This can lead to poor performance, in which case the seed should be directly provided
     */
    function CashuWallet(mint, options) {
        var _this = this;
        this._keys = new Map();
        this._keysets = [];
        this._seed = undefined;
        this._unit = DEFAULT_UNIT;
        this._mintInfo = undefined;
        this._denominationTarget = DEFAULT_DENOMINATION_TARGET;
        this.mint = mint;
        var keys = [];
        if ((options === null || options === void 0 ? void 0 : options.keys) && !Array.isArray(options.keys)) {
            keys = [options.keys];
        }
        else if ((options === null || options === void 0 ? void 0 : options.keys) && Array.isArray(options === null || options === void 0 ? void 0 : options.keys)) {
            keys = options === null || options === void 0 ? void 0 : options.keys;
        }
        if (keys)
            keys.forEach(function (key) { return _this._keys.set(key.id, key); });
        if (options === null || options === void 0 ? void 0 : options.unit)
            this._unit = options === null || options === void 0 ? void 0 : options.unit;
        if (options === null || options === void 0 ? void 0 : options.keysets)
            this._keysets = options.keysets;
        if (options === null || options === void 0 ? void 0 : options.denominationTarget) {
            this._denominationTarget = options.denominationTarget;
        }
        if (options === null || options === void 0 ? void 0 : options.bip39seed) {
            if (options.bip39seed instanceof Uint8Array) {
                this._seed = options.bip39seed;
                return;
            }
            throw new Error('bip39seed must be a valid UInt8Array');
        }
    }
    Object.defineProperty(CashuWallet.prototype, "unit", {
        get: function () {
            return this._unit;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CashuWallet.prototype, "keys", {
        get: function () {
            return this._keys;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CashuWallet.prototype, "keysetId", {
        get: function () {
            if (!this._keysetId) {
                throw new Error('No keysetId set');
            }
            return this._keysetId;
        },
        set: function (keysetId) {
            this._keysetId = keysetId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CashuWallet.prototype, "keysets", {
        get: function () {
            return this._keysets;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CashuWallet.prototype, "mintInfo", {
        get: function () {
            if (!this._mintInfo) {
                throw new Error('Mint info not loaded');
            }
            return this._mintInfo;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get information about the mint
     * @returns mint info
     */
    CashuWallet.prototype.getMintInfo = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this;
                        return [4 /*yield*/, this.mint.getInfo()];
                    case 1:
                        _a._mintInfo = _b.sent();
                        return [2 /*return*/, this._mintInfo];
                }
            });
        });
    };
    /**
     * Load mint information, keysets and keys. This function can be called if no keysets are passed in the constructor
     */
    CashuWallet.prototype.loadMint = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getMintInfo()];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.getKeySets()];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.getKeys()];
                    case 3:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Choose a keyset to activate based on the lowest input fee
     *
     * Note: this function will filter out deprecated base64 keysets
     *
     * @param keysets keysets to choose from
     * @returns active keyset
     */
    CashuWallet.prototype.getActiveKeyset = function (keysets) {
        var activeKeysets = keysets.filter(function (k) { return k.active; });
        // we only consider keyset IDs that start with "00"
        activeKeysets = activeKeysets.filter(function (k) { return k.id.startsWith('00'); });
        var activeKeyset = activeKeysets.sort(function (a, b) { var _a, _b; return ((_a = a.input_fee_ppk) !== null && _a !== void 0 ? _a : 0) - ((_b = b.input_fee_ppk) !== null && _b !== void 0 ? _b : 0); })[0];
        if (!activeKeyset) {
            throw new Error('No active keyset found');
        }
        return activeKeyset;
    };
    /**
     * Get keysets from the mint with the unit of the wallet
     * @returns keysets with wallet's unit
     */
    CashuWallet.prototype.getKeySets = function () {
        return __awaiter(this, void 0, void 0, function () {
            var allKeysets, unitKeysets;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.mint.getKeySets()];
                    case 1:
                        allKeysets = _a.sent();
                        unitKeysets = allKeysets.keysets.filter(function (k) { return k.unit === _this._unit; });
                        this._keysets = unitKeysets;
                        return [2 /*return*/, this._keysets];
                }
            });
        });
    };
    /**
     * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet keyset.
     * @returns keyset
     */
    CashuWallet.prototype.getAllKeys = function () {
        return __awaiter(this, void 0, void 0, function () {
            var keysets;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.mint.getKeys()];
                    case 1:
                        keysets = _a.sent();
                        this._keys = new Map(keysets.keysets.map(function (k) { return [k.id, k]; }));
                        this.keysetId = this.getActiveKeyset(this._keysets).id;
                        return [2 /*return*/, keysets.keysets];
                }
            });
        });
    };
    /**
     * Get public keys from the mint. If keys were already fetched, it will return those.
     *
     * If `keysetId` is set, it will fetch and return that specific keyset.
     * Otherwise, we select an active keyset with the unit of the wallet.
     *
     * @param keysetId optional keysetId to get keys for
     * @param forceRefresh? if set to true, it will force refresh the keyset from the mint
     * @returns keyset
     */
    CashuWallet.prototype.getKeys = function (keysetId, forceRefresh) {
        return __awaiter(this, void 0, void 0, function () {
            var localKeyset, keys;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(!(this._keysets.length > 0) || forceRefresh)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.getKeySets()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2:
                        // no keyset id is chosen, let's choose one
                        if (!keysetId) {
                            localKeyset = this.getActiveKeyset(this._keysets);
                            keysetId = localKeyset.id;
                        }
                        if (!!this._keysets.find(function (k) { return k.id === keysetId; })) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.getKeySets()];
                    case 3:
                        _a.sent();
                        if (!this._keysets.find(function (k) { return k.id === keysetId; })) {
                            throw new Error("could not initialize keys. No keyset with id '".concat(keysetId, "' found"));
                        }
                        _a.label = 4;
                    case 4:
                        if (!!this._keys.get(keysetId)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.mint.getKeys(keysetId)];
                    case 5:
                        keys = _a.sent();
                        this._keys.set(keysetId, keys.keysets[0]);
                        _a.label = 6;
                    case 6:
                        // set and return
                        this.keysetId = keysetId;
                        return [2 /*return*/, this._keys.get(keysetId)];
                }
            });
        });
    };
    /**
     * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the first token in the token array)
     * @param {(string|Token)} token - Cashu token, either as string or decoded
     * @param options.keysetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param options.outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param options.proofsWeHave? optionally provide all currently stored proofs of this mint. Cashu-ts will use them to derive the optimal output amounts
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param options.privkey? will create a signature on the @param token secrets if set
     * @returns New token with newly created proofs, token entries that had errors
     */
    CashuWallet.prototype.receive = function (token, options) {
        return __awaiter(this, void 0, void 0, function () {
            var keys, amount, _a, payload, blindingData, signatures, freshProofs;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (typeof token === 'string') {
                            token = getDecodedToken(token);
                        }
                        return [4 /*yield*/, this.getKeys(options === null || options === void 0 ? void 0 : options.keysetId)];
                    case 1:
                        keys = _b.sent();
                        amount = sumProofs(token.proofs) - this.getFeesForProofs(token.proofs);
                        _a = this.createSwapPayload(amount, token.proofs, keys, options === null || options === void 0 ? void 0 : options.outputAmounts, options === null || options === void 0 ? void 0 : options.counter, options === null || options === void 0 ? void 0 : options.pubkey, options === null || options === void 0 ? void 0 : options.privkey), payload = _a.payload, blindingData = _a.blindingData;
                        return [4 /*yield*/, this.mint.swap(payload)];
                    case 2:
                        signatures = (_b.sent()).signatures;
                        freshProofs = this.constructProofs(signatures, blindingData.blindingFactors, blindingData.secrets, keys);
                        return [2 /*return*/, freshProofs];
                }
            });
        });
    };
    /**
     * Send proofs of a given amount, by providing at least the required amount of proofs
     * @param amount amount to send
     * @param proofs array of proofs (accumulated amount of proofs must be >= than amount)
     * @param options.outputAmounts? optionally specify the output's amounts to keep and send.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.proofsWeHave? optionally provide all currently stored proofs of this mint. Cashu-ts will use them to derive the optimal output amounts
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param options.privkey? will create a signature on the output secrets if set
     * @param options.keysetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param options.offline? optionally send proofs offline.
     * @param options.includeFees? optionally include fees in the response.
     * @returns {SendResponse}
     */
    CashuWallet.prototype.send = function (amount, proofs, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var _b, keepProofsOffline, sendProofOffline, expectedFee, _c, keepProofsSelect, sendProofs, _d, keep, send, keepProofs;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (sumProofs(proofs) < amount) {
                            throw new Error('Not enough funds available to send');
                        }
                        _b = this.selectProofsToSend(proofs, amount, options === null || options === void 0 ? void 0 : options.includeFees), keepProofsOffline = _b.keep, sendProofOffline = _b.send;
                        expectedFee = (options === null || options === void 0 ? void 0 : options.includeFees) ? this.getFeesForProofs(sendProofOffline) : 0;
                        if (!(!(options === null || options === void 0 ? void 0 : options.offline) &&
                            (sumProofs(sendProofOffline) != amount + expectedFee || // if the exact amount cannot be selected
                                (options === null || options === void 0 ? void 0 : options.outputAmounts) ||
                                (options === null || options === void 0 ? void 0 : options.pubkey) ||
                                (options === null || options === void 0 ? void 0 : options.privkey) ||
                                (options === null || options === void 0 ? void 0 : options.keysetId))) // these options require a swap
                        ) return [3 /*break*/, 2]; // these options require a swap
                        _c = this.selectProofsToSend(proofs, amount, true), keepProofsSelect = _c.keep, sendProofs = _c.send;
                        (_a = options === null || options === void 0 ? void 0 : options.proofsWeHave) === null || _a === void 0 ? void 0 : _a.push.apply(_a, keepProofsSelect);
                        return [4 /*yield*/, this.swap(amount, sendProofs, options)];
                    case 1:
                        _d = _e.sent(), keep = _d.keep, send = _d.send;
                        keepProofs = keepProofsSelect.concat(keep);
                        return [2 /*return*/, { keep: keepProofs, send: send }];
                    case 2:
                        if (sumProofs(sendProofOffline) < amount + expectedFee) {
                            throw new Error('Not enough funds available to send');
                        }
                        return [2 /*return*/, { keep: keepProofsOffline, send: sendProofOffline }];
                }
            });
        });
    };
    CashuWallet.prototype.selectProofsToSend = function (proofs, amountToSend, includeFees) {
        var sortedProofs = proofs.sort(function (a, b) { return a.amount - b.amount; });
        var smallerProofs = sortedProofs
            .filter(function (p) { return p.amount <= amountToSend; })
            .sort(function (a, b) { return b.amount - a.amount; });
        var biggerProofs = sortedProofs
            .filter(function (p) { return p.amount > amountToSend; })
            .sort(function (a, b) { return a.amount - b.amount; });
        var nextBigger = biggerProofs[0];
        if (!smallerProofs.length && nextBigger) {
            return {
                keep: proofs.filter(function (p) { return p.secret !== nextBigger.secret; }),
                send: [nextBigger]
            };
        }
        if (!smallerProofs.length && !nextBigger) {
            return { keep: proofs, send: [] };
        }
        var remainder = amountToSend;
        var selectedProofs = [smallerProofs[0]];
        var returnedProofs = [];
        var feePPK = includeFees ? this.getFeesForProofs(selectedProofs) : 0;
        remainder -= selectedProofs[0].amount - feePPK / 1000;
        if (remainder > 0) {
            var _a = this.selectProofsToSend(smallerProofs.slice(1), remainder, includeFees), keep = _a.keep, send = _a.send;
            selectedProofs.push.apply(selectedProofs, send);
            returnedProofs.push.apply(returnedProofs, keep);
        }
        var selectedFeePPK = includeFees ? this.getFeesForProofs(selectedProofs) : 0;
        if (sumProofs(selectedProofs) < amountToSend + selectedFeePPK && nextBigger) {
            selectedProofs = [nextBigger];
        }
        return {
            keep: proofs.filter(function (p) { return !selectedProofs.includes(p); }),
            send: selectedProofs
        };
    };
    /**
     * calculates the fees based on inputs (proofs)
     * @param proofs input proofs to calculate fees for
     * @returns fee amount
     */
    CashuWallet.prototype.getFeesForProofs = function (proofs) {
        var _this = this;
        if (!this._keysets.length) {
            throw new Error('Could not calculate fees. No keysets found');
        }
        var keysetIds = new Set(proofs.map(function (p) { return p.id; }));
        keysetIds.forEach(function (id) {
            if (!_this._keysets.find(function (k) { return k.id === id; })) {
                throw new Error("Could not calculate fees. No keyset found with id: ".concat(id));
            }
        });
        var fees = Math.floor(Math.max((proofs.reduce(function (total, curr) { var _a; return total + (((_a = _this._keysets.find(function (k) { return k.id === curr.id; })) === null || _a === void 0 ? void 0 : _a.input_fee_ppk) || 0); }, 0) +
            999) /
            1000, 0));
        return fees;
    };
    /**
     * calculates the fees based on inputs for a given keyset
     * @param nInputs number of inputs
     * @param keysetId keysetId used to lookup `input_fee_ppk`
     * @returns fee amount
     */
    CashuWallet.prototype.getFeesForKeyset = function (nInputs, keysetId) {
        var _a;
        var fees = Math.floor(Math.max((nInputs * (((_a = this._keysets.find(function (k) { return k.id === keysetId; })) === null || _a === void 0 ? void 0 : _a.input_fee_ppk) || 0) +
            999) /
            1000, 0));
        return fees;
    };
    /**
     * Splits and creates sendable tokens
     * if no amount is specified, the amount is implied by the cumulative amount of all proofs
     * if both amount and preference are set, but the preference cannot fulfill the amount, then we use the default split
     * @param amount amount to send while performing the optimal split (least proofs possible). can be set to undefined if preference is set
     * @param proofs proofs matching that amount
     * @param options.outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.keysetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param options.includeFees? include estimated fees for the receiver to receive the proofs
     * @param options.proofsWeHave? optionally provide all currently stored proofs of this mint. Cashu-ts will use them to derive the optimal output amounts
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param options.privkey? will create a signature on the @param proofs secrets if set
     * @returns promise of the change- and send-proofs
     */
    CashuWallet.prototype.swap = function (amount, proofs, options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function () {
            var keyset, proofsToSend, amountToSend, amountAvailable, amountToKeep, sendAmounts, outputFee, sendAmountsFee, keepAmounts, _d, payload, blindingData, signatures, swapProofs, splitProofsToKeep, splitProofsToSend, amountToKeepCounter;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        if (!options)
                            options = {};
                        return [4 /*yield*/, this.getKeys(options.keysetId)];
                    case 1:
                        keyset = _e.sent();
                        proofsToSend = proofs;
                        amountToSend = amount;
                        amountAvailable = sumProofs(proofs);
                        amountToKeep = amountAvailable - amountToSend - this.getFeesForProofs(proofsToSend);
                        sendAmounts = ((_a = options === null || options === void 0 ? void 0 : options.outputAmounts) === null || _a === void 0 ? void 0 : _a.sendAmounts) || splitAmount(amountToSend, keyset.keys);
                        // include the fees to spend the the outputs of the swap
                        if (options === null || options === void 0 ? void 0 : options.includeFees) {
                            outputFee = this.getFeesForKeyset(sendAmounts.length, keyset.id);
                            sendAmountsFee = splitAmount(outputFee, keyset.keys);
                            while (this.getFeesForKeyset(sendAmounts.concat(sendAmountsFee).length, keyset.id) > outputFee) {
                                outputFee++;
                                sendAmountsFee = splitAmount(outputFee, keyset.keys);
                            }
                            sendAmounts = sendAmounts.concat(sendAmountsFee);
                            amountToSend += outputFee;
                            amountToKeep -= outputFee;
                        }
                        if (options && !((_b = options.outputAmounts) === null || _b === void 0 ? void 0 : _b.keepAmounts) && options.proofsWeHave) {
                            keepAmounts = getKeepAmounts(options.proofsWeHave, amountToKeep, keyset.keys, this._denominationTarget);
                        }
                        else if (options.outputAmounts) {
                            if (((_c = options.outputAmounts.keepAmounts) === null || _c === void 0 ? void 0 : _c.reduce(function (a, b) { return a + b; }, 0)) !=
                                amountToKeep) {
                                throw new Error('Keep amounts do not match amount to keep');
                            }
                            keepAmounts = options.outputAmounts.keepAmounts;
                        }
                        if (amountToSend + this.getFeesForProofs(proofsToSend) > amountAvailable) {
                            console.error("Not enough funds available (".concat(amountAvailable, ") for swap amountToSend: ").concat(amountToSend, " + fee: ").concat(this.getFeesForProofs(proofsToSend), " | length: ").concat(proofsToSend.length));
                            throw new Error("Not enough funds available for swap");
                        }
                        if (amountToSend + this.getFeesForProofs(proofsToSend) + amountToKeep != amountAvailable) {
                            throw new Error('Amounts do not match for swap');
                        }
                        options.outputAmounts = {
                            keepAmounts: keepAmounts,
                            sendAmounts: sendAmounts
                        };
                        _d = this.createSwapPayload(amountToSend, proofsToSend, keyset, options === null || options === void 0 ? void 0 : options.outputAmounts, options === null || options === void 0 ? void 0 : options.counter, options === null || options === void 0 ? void 0 : options.pubkey, options === null || options === void 0 ? void 0 : options.privkey), payload = _d.payload, blindingData = _d.blindingData;
                        return [4 /*yield*/, this.mint.swap(payload)];
                    case 2:
                        signatures = (_e.sent()).signatures;
                        swapProofs = this.constructProofs(signatures, blindingData.blindingFactors, blindingData.secrets, keyset);
                        splitProofsToKeep = [];
                        splitProofsToSend = [];
                        amountToKeepCounter = 0;
                        swapProofs.forEach(function (proof) {
                            if (amountToKeepCounter < amountToKeep) {
                                amountToKeepCounter += proof.amount;
                                splitProofsToKeep.push(proof);
                                return;
                            }
                            splitProofsToSend.push(proof);
                        });
                        return [2 /*return*/, {
                                keep: splitProofsToKeep,
                                send: splitProofsToSend
                            }];
                }
            });
        });
    };
    /**
     * Regenerates
     * @param start set starting point for count (first cycle for each keyset should usually be 0)
     * @param count set number of blinded messages that should be generated
     * @param options.keysetId set a custom keysetId to restore from. keysetIds can be loaded with `CashuMint.getKeySets()`
     * @returns proofs
     */
    CashuWallet.prototype.restore = function (start, count, options) {
        return __awaiter(this, void 0, void 0, function () {
            var keys, amounts, _a, blindedMessages, blindingFactors, secrets, _b, outputs, promises, validBlindingFactors, validSecrets;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getKeys(options === null || options === void 0 ? void 0 : options.keysetId)];
                    case 1:
                        keys = _c.sent();
                        if (!this._seed) {
                            throw new Error('CashuWallet must be initialized with a seed to use restore');
                        }
                        amounts = Array(count).fill(0);
                        _a = this.createBlindedMessages(amounts, keys.id, start), blindedMessages = _a.blindedMessages, blindingFactors = _a.blindingFactors, secrets = _a.secrets;
                        return [4 /*yield*/, this.mint.restore({ outputs: blindedMessages })];
                    case 2:
                        _b = _c.sent(), outputs = _b.outputs, promises = _b.promises;
                        validBlindingFactors = blindingFactors.filter(function (_, i) {
                            return outputs.map(function (o) { return o.B_; }).includes(blindedMessages[i].B_);
                        });
                        validSecrets = secrets.filter(function (_, i) {
                            return outputs.map(function (o) { return o.B_; }).includes(blindedMessages[i].B_);
                        });
                        return [2 /*return*/, {
                                proofs: this.constructProofs(promises, validBlindingFactors, validSecrets, keys)
                            }];
                }
            });
        });
    };
    /**
     * Requests a mint quote form the mint. Response returns a Lightning payment request for the requested given amount and unit.
     * @param amount Amount requesting for mint.
     * @param description optional description for the mint quote
     * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit
     */
    CashuWallet.prototype.createMintQuote = function (amount, description) {
        return __awaiter(this, void 0, void 0, function () {
            var mintQuotePayload;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mintQuotePayload = {
                            unit: this._unit,
                            amount: amount,
                            description: description
                        };
                        return [4 /*yield*/, this.mint.createMintQuote(mintQuotePayload)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Gets an existing mint quote from the mint.
     * @param quote Quote ID
     * @returns the mint will create and return a Lightning invoice for the specified amount
     */
    CashuWallet.prototype.checkMintQuote = function (quote) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.mint.checkMintQuote(quote)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Mint proofs for a given mint quote
     * @param amount amount to request
     * @param quote ID of mint quote
     * @param options.keysetId? optionally set keysetId for blank outputs for returned change.
     * @param options.preference? Deprecated. Use `outputAmounts` instead. Optional preference for splitting proofs into specific amounts.
     * @param options.outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @returns proofs
     */
    CashuWallet.prototype.mintProofs = function (amount, quote, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var keyset, _b, blindedMessages, secrets, blindingFactors, mintPayload, signatures;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, this.getKeys(options === null || options === void 0 ? void 0 : options.keysetId)];
                    case 1:
                        keyset = _c.sent();
                        if (!(options === null || options === void 0 ? void 0 : options.outputAmounts) && (options === null || options === void 0 ? void 0 : options.proofsWeHave)) {
                            options.outputAmounts = {
                                keepAmounts: getKeepAmounts(options.proofsWeHave, amount, keyset.keys, this._denominationTarget),
                                sendAmounts: []
                            };
                        }
                        _b = this.createRandomBlindedMessages(amount, keyset, (_a = options === null || options === void 0 ? void 0 : options.outputAmounts) === null || _a === void 0 ? void 0 : _a.keepAmounts, options === null || options === void 0 ? void 0 : options.counter, options === null || options === void 0 ? void 0 : options.pubkey), blindedMessages = _b.blindedMessages, secrets = _b.secrets, blindingFactors = _b.blindingFactors;
                        mintPayload = {
                            outputs: blindedMessages,
                            quote: quote
                        };
                        return [4 /*yield*/, this.mint.mint(mintPayload)];
                    case 2:
                        signatures = (_c.sent()).signatures;
                        return [2 /*return*/, {
                                proofs: this.constructProofs(signatures, blindingFactors, secrets, keyset)
                            }];
                }
            });
        });
    };
    /**
     * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order to pay a Lightning invoice.
     * @param invoice LN invoice that needs to get a fee estimate
     * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve
     */
    CashuWallet.prototype.createMeltQuote = function (invoice) {
        return __awaiter(this, void 0, void 0, function () {
            var meltQuotePayload, meltQuote;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        meltQuotePayload = {
                            unit: this._unit,
                            request: invoice
                        };
                        return [4 /*yield*/, this.mint.createMeltQuote(meltQuotePayload)];
                    case 1:
                        meltQuote = _a.sent();
                        return [2 /*return*/, meltQuote];
                }
            });
        });
    };
    /**
     * Return an existing melt quote from the mint.
     * @param quote ID of the melt quote
     * @returns the mint will return an existing melt quote
     */
    CashuWallet.prototype.checkMeltQuote = function (quote) {
        return __awaiter(this, void 0, void 0, function () {
            var meltQuote;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.mint.checkMeltQuote(quote)];
                    case 1:
                        meltQuote = _a.sent();
                        return [2 /*return*/, meltQuote];
                }
            });
        });
    };
    /**
     * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt quote. This function does not perform coin selection!.
     * Returns melt quote and change proofs
     * @param meltQuote ID of the melt quote
     * @param proofsToSend proofs to melt
     * @param options.keysetId? optionally set keysetId for blank outputs for returned change.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.privkey? optionally set a private key to unlock P2PK locked secrets
     * @returns
     */
    CashuWallet.prototype.meltProofs = function (meltQuote, proofsToSend, options) {
        return __awaiter(this, void 0, void 0, function () {
            var keys, _a, blindedMessages, secrets, blindingFactors, meltPayload, meltResponse, change;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getKeys(options === null || options === void 0 ? void 0 : options.keysetId)];
                    case 1:
                        keys = _b.sent();
                        _a = this.createBlankOutputs(sumProofs(proofsToSend) - meltQuote.amount, keys.id, options === null || options === void 0 ? void 0 : options.counter), blindedMessages = _a.blindedMessages, secrets = _a.secrets, blindingFactors = _a.blindingFactors;
                        if ((options === null || options === void 0 ? void 0 : options.privkey) != undefined) {
                            proofsToSend = getSignedProofs(proofsToSend.map(function (p) {
                                return {
                                    amount: p.amount,
                                    C: pointFromHex(p.C),
                                    id: p.id,
                                    secret: new TextEncoder().encode(p.secret)
                                };
                            }), options.privkey).map(function (p) { return serializeProof(p); });
                        }
                        meltPayload = {
                            quote: meltQuote.quote,
                            inputs: proofsToSend,
                            outputs: __spreadArray([], blindedMessages, true)
                        };
                        return [4 /*yield*/, this.mint.melt(meltPayload)];
                    case 2:
                        meltResponse = _b.sent();
                        change = [];
                        if (meltResponse.change) {
                            change = this.constructProofs(meltResponse.change, blindingFactors, secrets, keys);
                        }
                        return [2 /*return*/, {
                                quote: meltResponse,
                                change: change
                            }];
                }
            });
        });
    };
    /**
     * Creates a split payload
     * @param amount amount to send
     * @param proofsToSend proofs to split*
     * @param outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param privkey? will create a signature on the @param proofsToSend secrets if set
     * @returns
     */
    CashuWallet.prototype.createSwapPayload = function (amount, proofsToSend, keyset, outputAmounts, counter, pubkey, privkey) {
        var totalAmount = proofsToSend.reduce(function (total, curr) { return total + curr.amount; }, 0);
        if (outputAmounts && outputAmounts.sendAmounts && !outputAmounts.keepAmounts) {
            outputAmounts.keepAmounts = splitAmount(totalAmount - amount - this.getFeesForProofs(proofsToSend), keyset.keys);
        }
        var keepBlindedMessages = this.createRandomBlindedMessages(totalAmount - amount - this.getFeesForProofs(proofsToSend), keyset, outputAmounts === null || outputAmounts === void 0 ? void 0 : outputAmounts.keepAmounts, counter);
        if (this._seed && counter) {
            counter = counter + keepBlindedMessages.secrets.length;
        }
        var sendBlindedMessages = this.createRandomBlindedMessages(amount, keyset, outputAmounts === null || outputAmounts === void 0 ? void 0 : outputAmounts.sendAmounts, counter, pubkey);
        if (privkey) {
            proofsToSend = getSignedProofs(proofsToSend.map(function (p) {
                return {
                    amount: p.amount,
                    C: pointFromHex(p.C),
                    id: p.id,
                    secret: new TextEncoder().encode(p.secret)
                };
            }), privkey).map(function (p) { return serializeProof(p); });
        }
        // join keepBlindedMessages and sendBlindedMessages
        var blindingData = {
            blindedMessages: __spreadArray(__spreadArray([], keepBlindedMessages.blindedMessages, true), sendBlindedMessages.blindedMessages, true),
            secrets: __spreadArray(__spreadArray([], keepBlindedMessages.secrets, true), sendBlindedMessages.secrets, true),
            blindingFactors: __spreadArray(__spreadArray([], keepBlindedMessages.blindingFactors, true), sendBlindedMessages.blindingFactors, true)
        };
        var payload = {
            inputs: proofsToSend,
            outputs: __spreadArray([], blindingData.blindedMessages, true)
        };
        return { payload: payload, blindingData: blindingData };
    };
    /**
     * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
     * @param proofs (only the `secret` field is required)
     * @returns
     */
    CashuWallet.prototype.checkProofsStates = function (proofs) {
        return __awaiter(this, void 0, void 0, function () {
            var enc, Ys, BATCH_SIZE, states, _loop_1, this_1, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        enc = new TextEncoder();
                        Ys = proofs.map(function (p) { return hashToCurve(enc.encode(p.secret)).toHex(true); });
                        BATCH_SIZE = 100;
                        states = [];
                        _loop_1 = function (i) {
                            var YsSlice, batchStates, stateMap, j, state;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        YsSlice = Ys.slice(i, i + BATCH_SIZE);
                                        return [4 /*yield*/, this_1.mint.check({
                                                Ys: YsSlice
                                            })];
                                    case 1:
                                        batchStates = (_b.sent()).states;
                                        stateMap = {};
                                        batchStates.forEach(function (s) {
                                            stateMap[s.Y] = s;
                                        });
                                        for (j = 0; j < YsSlice.length; j++) {
                                            state = stateMap[YsSlice[j]];
                                            if (!state) {
                                                throw new Error('Could not find state for proof with Y: ' + YsSlice[j]);
                                            }
                                            states.push(state);
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        this_1 = this;
                        i = 0;
                        _a.label = 1;
                    case 1:
                        if (!(i < Ys.length)) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_1(i)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3:
                        i += BATCH_SIZE;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/, states];
                }
            });
        });
    };
    /**
     * Creates blinded messages for a given amount
     * @param amount amount to create blinded messages for
     * @param split optional preference for splitting proofs into specific amounts. overrides amount param
     * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @returns blinded messages, secrets, rs, and amounts
     */
    CashuWallet.prototype.createRandomBlindedMessages = function (amount, keyset, split, counter, pubkey) {
        var amounts = splitAmount(amount, keyset.keys, split);
        return this.createBlindedMessages(amounts, keyset.id, counter, pubkey);
    };
    /**
     * Creates blinded messages for a according to @param amounts
     * @param amount array of amounts to create blinded messages for
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @returns blinded messages, secrets, rs, and amounts
     */
    CashuWallet.prototype.createBlindedMessages = function (amounts, keysetId, counter, pubkey) {
        // if we atempt to create deterministic messages without a _seed, abort.
        if (counter != undefined && !this._seed) {
            throw new Error('Cannot create deterministic messages without seed. Instantiate CashuWallet with a bip39seed, or omit counter param.');
        }
        var blindedMessages = [];
        var secrets = [];
        var blindingFactors = [];
        for (var i = 0; i < amounts.length; i++) {
            var deterministicR = undefined;
            var secretBytes = undefined;
            if (pubkey) {
                secretBytes = createP2PKsecret(pubkey);
            }
            else if (this._seed && counter != undefined) {
                secretBytes = deriveSecret(this._seed, keysetId, counter + i);
                deterministicR = bytesToNumber(deriveBlindingFactor(this._seed, keysetId, counter + i));
            }
            else {
                secretBytes = randomBytes(32);
            }
            if (!pubkey) {
                var secretHex = bytesToHex(secretBytes);
                secretBytes = new TextEncoder().encode(secretHex);
            }
            secrets.push(secretBytes);
            var _a = blindMessage(secretBytes, deterministicR), B_ = _a.B_, r = _a.r;
            blindingFactors.push(r);
            var blindedMessage = new BlindedMessage(amounts[i], B_, keysetId);
            blindedMessages.push(blindedMessage.getSerializedBlindedMessage());
        }
        return { blindedMessages: blindedMessages, secrets: secrets, blindingFactors: blindingFactors, amounts: amounts };
    };
    /**
     * Creates NUT-08 blank outputs (fee returns) for a given fee reserve
     * See: https://github.com/cashubtc/nuts/blob/main/08.md
     * @param amount amount to cover with blank outputs
     * @param keysetId mint keysetId
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @returns blinded messages, secrets, and rs
     */
    CashuWallet.prototype.createBlankOutputs = function (amount, keysetId, counter) {
        var count = Math.ceil(Math.log2(amount)) || 1;
        //Prevent count from being -Infinity
        if (count < 0) {
            count = 0;
        }
        var amounts = count ? Array(count).fill(1) : [];
        var _a = this.createBlindedMessages(amounts, keysetId, counter), blindedMessages = _a.blindedMessages, blindingFactors = _a.blindingFactors, secrets = _a.secrets;
        return { blindedMessages: blindedMessages, secrets: secrets, blindingFactors: blindingFactors };
    };
    /**
     * construct proofs from @params promises, @params rs, @params secrets, and @params keyset
     * @param promises array of serialized blinded signatures
     * @param rs arrays of binding factors
     * @param secrets array of secrets
     * @param keyset mint keyset
     * @returns array of serialized proofs
     */
    CashuWallet.prototype.constructProofs = function (promises, rs, secrets, keyset) {
        return promises
            .map(function (p, i) {
            var blindSignature = { id: p.id, amount: p.amount, C_: pointFromHex(p.C_) };
            var r = rs[i];
            var secret = secrets[i];
            var A = pointFromHex(keyset.keys[p.amount]);
            return constructProofFromPromise(blindSignature, r, secret, A);
        })
            .map(function (p) { return serializeProof(p); });
    };
    return CashuWallet;
}());
export { CashuWallet };
//# sourceMappingURL=CashuWallet.js.map
import { CashuMint } from './CashuMint.js';
import { type MeltQuoteResponse, type MintKeys, type MintKeyset, type MeltProofsResponse, type Proof, type SendResponse, type Token, GetInfoResponse, OutputAmounts, ProofState } from './model/types/index.js';
/**
 * Class that represents a Cashu wallet.
 * This class should act as the entry point for this library
 */
declare class CashuWallet {
    private _keys;
    private _keysetId;
    private _keysets;
    private _seed;
    private _unit;
    private _mintInfo;
    private _denominationTarget;
    mint: CashuMint;
    /**
     * @param mint Cashu mint instance is used to make api calls
     * @param options.unit optionally set unit (default is 'sat')
     * @param options.keys public keys from the mint (will be fetched from mint if not provided)
     * @param options.keysets keysets from the mint (will be fetched from mint if not provided)
     * @param options.mintInfo mint info from the mint (will be fetched from mint if not provided)
     * @param options.denominationTarget target number proofs per denomination (default: see @constant DEFAULT_DENOMINATION_TARGET)
     * @param options.bip39seed BIP39 seed for deterministic secrets.
     * This can lead to poor performance, in which case the seed should be directly provided
     */
    constructor(mint: CashuMint, options?: {
        unit?: string;
        keys?: Array<MintKeys> | MintKeys;
        keysets?: Array<MintKeyset>;
        mintInfo?: GetInfoResponse;
        bip39seed?: Uint8Array;
        denominationTarget?: number;
    });
    get unit(): string;
    get keys(): Map<string, MintKeys>;
    get keysetId(): string;
    set keysetId(keysetId: string);
    get keysets(): Array<MintKeyset>;
    get mintInfo(): GetInfoResponse;
    /**
     * Get information about the mint
     * @returns mint info
     */
    getMintInfo(): Promise<GetInfoResponse>;
    /**
     * Load mint information, keysets and keys. This function can be called if no keysets are passed in the constructor
     */
    loadMint(): Promise<void>;
    /**
     * Choose a keyset to activate based on the lowest input fee
     *
     * Note: this function will filter out deprecated base64 keysets
     *
     * @param keysets keysets to choose from
     * @returns active keyset
     */
    getActiveKeyset(keysets: Array<MintKeyset>): MintKeyset;
    /**
     * Get keysets from the mint with the unit of the wallet
     * @returns keysets with wallet's unit
     */
    getKeySets(): Promise<Array<MintKeyset>>;
    /**
     * Get all active keys from the mint and set the keyset with the lowest fees as the active wallet keyset.
     * @returns keyset
     */
    getAllKeys(): Promise<Array<MintKeys>>;
    /**
     * Get public keys from the mint. If keys were already fetched, it will return those.
     *
     * If `keysetId` is set, it will fetch and return that specific keyset.
     * Otherwise, we select an active keyset with the unit of the wallet.
     *
     * @param keysetId optional keysetId to get keys for
     * @param forceRefresh? if set to true, it will force refresh the keyset from the mint
     * @returns keyset
     */
    getKeys(keysetId?: string, forceRefresh?: boolean): Promise<MintKeys>;
    /**
     * Receive an encoded or raw Cashu token (only supports single tokens. It will only process the first token in the token array)
     * @param {(string|Token)} token - Cashu token, either as string or decoded
     * @param options.keysetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param options.outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param options.proofsWeHave? optionally provide all currently stored proofs of this mint. Cashu-ts will use them to derive the optimal output amounts
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param options.privkey? will create a signature on the @param token secrets if set
     * @returns New token with newly created proofs, token entries that had errors
     */
    receive(token: string | Token, options?: {
        keysetId?: string;
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
        privkey?: string;
    }): Promise<Array<Proof>>;
    /**
     * Send proofs of a given amount, by providing at least the required amount of proofs
     * @param amount amount to send
     * @param proofs array of proofs (accumulated amount of proofs must be >= than amount)
     * @param options.outputAmounts? optionally specify the output's amounts to keep and send.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.proofsWeHave? optionally provide all currently stored proofs of this mint. Cashu-ts will use them to derive the optimal output amounts
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param options.privkey? will create a signature on the output secrets if set
     * @param options.keysetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param options.offline? optionally send proofs offline.
     * @param options.includeFees? optionally include fees in the response.
     * @returns {SendResponse}
     */
    send(amount: number, proofs: Array<Proof>, options?: {
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
        privkey?: string;
        keysetId?: string;
        offline?: boolean;
        includeFees?: boolean;
    }): Promise<SendResponse>;
    selectProofsToSend(proofs: Array<Proof>, amountToSend: number, includeFees?: boolean): SendResponse;
    /**
     * calculates the fees based on inputs (proofs)
     * @param proofs input proofs to calculate fees for
     * @returns fee amount
     */
    getFeesForProofs(proofs: Array<Proof>): number;
    /**
     * calculates the fees based on inputs for a given keyset
     * @param nInputs number of inputs
     * @param keysetId keysetId used to lookup `input_fee_ppk`
     * @returns fee amount
     */
    getFeesForKeyset(nInputs: number, keysetId: string): number;
    /**
     * Splits and creates sendable tokens
     * if no amount is specified, the amount is implied by the cumulative amount of all proofs
     * if both amount and preference are set, but the preference cannot fulfill the amount, then we use the default split
     * @param amount amount to send while performing the optimal split (least proofs possible). can be set to undefined if preference is set
     * @param proofs proofs matching that amount
     * @param options.outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.keysetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param options.includeFees? include estimated fees for the receiver to receive the proofs
     * @param options.proofsWeHave? optionally provide all currently stored proofs of this mint. Cashu-ts will use them to derive the optimal output amounts
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param options.privkey? will create a signature on the @param proofs secrets if set
     * @returns promise of the change- and send-proofs
     */
    swap(amount: number, proofs: Array<Proof>, options?: {
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
        privkey?: string;
        keysetId?: string;
        includeFees?: boolean;
    }): Promise<SendResponse>;
    /**
     * Regenerates
     * @param start set starting point for count (first cycle for each keyset should usually be 0)
     * @param count set number of blinded messages that should be generated
     * @param options.keysetId set a custom keysetId to restore from. keysetIds can be loaded with `CashuMint.getKeySets()`
     * @returns proofs
     */
    restore(start: number, count: number, options?: {
        keysetId?: string;
    }): Promise<{
        proofs: Array<Proof>;
    }>;
    /**
     * Requests a mint quote form the mint. Response returns a Lightning payment request for the requested given amount and unit.
     * @param amount Amount requesting for mint.
     * @param description optional description for the mint quote
     * @returns the mint will return a mint quote with a Lightning invoice for minting tokens of the specified amount and unit
     */
    createMintQuote(amount: number, description?: string): Promise<import("./model/types/index.js").MintQuoteResponse>;
    /**
     * Gets an existing mint quote from the mint.
     * @param quote Quote ID
     * @returns the mint will create and return a Lightning invoice for the specified amount
     */
    checkMintQuote(quote: string): Promise<import("./model/types/index.js").MintQuoteResponse>;
    /**
     * Mint proofs for a given mint quote
     * @param amount amount to request
     * @param quote ID of mint quote
     * @param options.keysetId? optionally set keysetId for blank outputs for returned change.
     * @param options.preference? Deprecated. Use `outputAmounts` instead. Optional preference for splitting proofs into specific amounts.
     * @param options.outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @returns proofs
     */
    mintProofs(amount: number, quote: string, options?: {
        keysetId?: string;
        outputAmounts?: OutputAmounts;
        proofsWeHave?: Array<Proof>;
        counter?: number;
        pubkey?: string;
    }): Promise<{
        proofs: Array<Proof>;
    }>;
    /**
     * Requests a melt quote from the mint. Response returns amount and fees for a given unit in order to pay a Lightning invoice.
     * @param invoice LN invoice that needs to get a fee estimate
     * @returns the mint will create and return a melt quote for the invoice with an amount and fee reserve
     */
    createMeltQuote(invoice: string): Promise<MeltQuoteResponse>;
    /**
     * Return an existing melt quote from the mint.
     * @param quote ID of the melt quote
     * @returns the mint will return an existing melt quote
     */
    checkMeltQuote(quote: string): Promise<MeltQuoteResponse>;
    /**
     * Melt proofs for a melt quote. proofsToSend must be at least amount+fee_reserve form the melt quote. This function does not perform coin selection!.
     * Returns melt quote and change proofs
     * @param meltQuote ID of the melt quote
     * @param proofsToSend proofs to melt
     * @param options.keysetId? optionally set keysetId for blank outputs for returned change.
     * @param options.counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param options.privkey? optionally set a private key to unlock P2PK locked secrets
     * @returns
     */
    meltProofs(meltQuote: MeltQuoteResponse, proofsToSend: Array<Proof>, options?: {
        keysetId?: string;
        counter?: number;
        privkey?: string;
    }): Promise<MeltProofsResponse>;
    /**
     * Creates a split payload
     * @param amount amount to send
     * @param proofsToSend proofs to split*
     * @param outputAmounts? optionally specify the output's amounts to keep and to send.
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @param privkey? will create a signature on the @param proofsToSend secrets if set
     * @returns
     */
    private createSwapPayload;
    /**
     * Get an array of the states of proofs from the mint (as an array of CheckStateEnum's)
     * @param proofs (only the `secret` field is required)
     * @returns
     */
    checkProofsStates(proofs: Array<Proof>): Promise<Array<ProofState>>;
    /**
     * Creates blinded messages for a given amount
     * @param amount amount to create blinded messages for
     * @param split optional preference for splitting proofs into specific amounts. overrides amount param
     * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @returns blinded messages, secrets, rs, and amounts
     */
    private createRandomBlindedMessages;
    /**
     * Creates blinded messages for a according to @param amounts
     * @param amount array of amounts to create blinded messages for
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @param keyksetId? override the keysetId derived from the current mintKeys with a custom one. This should be a keyset that was fetched from the `/keysets` endpoint
     * @param pubkey? optionally locks ecash to pubkey. Will not be deterministic, even if counter is set!
     * @returns blinded messages, secrets, rs, and amounts
     */
    private createBlindedMessages;
    /**
     * Creates NUT-08 blank outputs (fee returns) for a given fee reserve
     * See: https://github.com/cashubtc/nuts/blob/main/08.md
     * @param amount amount to cover with blank outputs
     * @param keysetId mint keysetId
     * @param counter? optionally set counter to derive secret deterministically. CashuWallet class must be initialized with seed phrase to take effect
     * @returns blinded messages, secrets, and rs
     */
    private createBlankOutputs;
    /**
     * construct proofs from @params promises, @params rs, @params secrets, and @params keyset
     * @param promises array of serialized blinded signatures
     * @param rs arrays of binding factors
     * @param secrets array of secrets
     * @param keyset mint keyset
     * @returns array of serialized proofs
     */
    private constructProofs;
}
export { CashuWallet };

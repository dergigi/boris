import {
  __commonJS,
  __export,
  __publicField,
  __toESM
} from "./chunk-DC5AMYBS.js";

// node_modules/hash-sum/hash-sum.js
var require_hash_sum = __commonJS({
  "node_modules/hash-sum/hash-sum.js"(exports, module) {
    "use strict";
    function pad2(hash3, len) {
      while (hash3.length < len) {
        hash3 = "0" + hash3;
      }
      return hash3;
    }
    function fold(hash3, text) {
      var i2;
      var chr;
      var len;
      if (text.length === 0) {
        return hash3;
      }
      for (i2 = 0, len = text.length; i2 < len; i2++) {
        chr = text.charCodeAt(i2);
        hash3 = (hash3 << 5) - hash3 + chr;
        hash3 |= 0;
      }
      return hash3 < 0 ? hash3 * -2 : hash3;
    }
    function foldObject(hash3, o, seen) {
      return Object.keys(o).sort().reduce(foldKey, hash3);
      function foldKey(hash4, key) {
        return foldValue(hash4, o[key], key, seen);
      }
    }
    function foldValue(input, value, key, seen) {
      var hash3 = fold(fold(fold(input, key), toString(value)), typeof value);
      if (value === null) {
        return fold(hash3, "null");
      }
      if (value === void 0) {
        return fold(hash3, "undefined");
      }
      if (typeof value === "object" || typeof value === "function") {
        if (seen.indexOf(value) !== -1) {
          return fold(hash3, "[Circular]" + key);
        }
        seen.push(value);
        var objHash = foldObject(hash3, value, seen);
        if (!("valueOf" in value) || typeof value.valueOf !== "function") {
          return objHash;
        }
        try {
          return fold(objHash, String(value.valueOf()));
        } catch (err) {
          return fold(objHash, "[valueOf exception]" + (err.stack || err.message));
        }
      }
      return fold(hash3, value.toString());
    }
    function toString(o) {
      return Object.prototype.toString.call(o);
    }
    function sum(o) {
      return pad2(foldValue(0, o, "", []).toString(16), 8);
    }
    module.exports = sum;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i2, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal2(a[i2], b[i2])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal2(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/light-bolt11-decoder/node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64url = exports.base64 = exports.base32crockford = exports.base32hex = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
    function assertNumber2(n) {
      if (!Number.isSafeInteger(n))
        throw new Error(`Wrong integer: ${n}`);
    }
    exports.assertNumber = assertNumber2;
    function chain3(...args) {
      const wrap = (a, b) => (c) => a(b(c));
      const encode = Array.from(args).reverse().reduce((acc, i2) => acc ? wrap(acc, i2.encode) : i2.encode, void 0);
      const decode4 = args.reduce((acc, i2) => acc ? wrap(acc, i2.decode) : i2.decode, void 0);
      return { encode, decode: decode4 };
    }
    function alphabet3(alphabet4) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i2) => {
            assertNumber2(i2);
            if (i2 < 0 || i2 >= alphabet4.length)
              throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet4.length})`);
            return alphabet4[i2];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index = alphabet4.indexOf(letter);
            if (index === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet4}`);
            return index;
          });
        }
      };
    }
    function join3(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from2) => {
          if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i2 of from2)
            if (typeof i2 !== "string")
              throw new Error(`join.encode: non-string input=${i2}`);
          return from2.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding3(bits, chr = "=") {
      assertNumber2(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i2 of data)
            if (typeof i2 !== "string")
              throw new Error(`padding.encode: non-string input=${i2}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i2 of input)
            if (typeof i2 !== "string")
              throw new Error(`padding.decode: non-string input=${i2}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize3(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from2) => from2, decode: (to) => fn(to) };
    }
    function convertRadix4(data, from2, to) {
      if (from2 < 2)
        throw new Error(`convertRadix: wrong from=${from2}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d) => {
        assertNumber2(d);
        if (d < 0 || d >= from2)
          throw new Error(`Wrong integer: ${d}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i2 = pos; i2 < digits.length; i2++) {
          const digit = digits[i2];
          const digitBase = from2 * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from2 * carry / from2 !== carry || digitBase - digit !== from2 * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          digits[i2] = Math.floor(digitBase / to);
          if (!Number.isSafeInteger(digits[i2]) || digits[i2] * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!digits[i2])
            pos = i2;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
        res.push(0);
      return res.reverse();
    }
    var gcd3 = (a, b) => !b ? a : gcd3(b, a % b);
    var radix2carry3 = (from2, to) => from2 + (to - gcd3(from2, to));
    function convertRadix23(data, from2, to, padding4) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from2 <= 0 || from2 > 32)
        throw new Error(`convertRadix2: wrong from=${from2}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry3(from2, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry3(from2, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask = 2 ** to - 1;
      const res = [];
      for (const n of data) {
        assertNumber2(n);
        if (n >= 2 ** from2)
          throw new Error(`convertRadix2: invalid data word=${n} from=${from2}`);
        carry = carry << from2 | n;
        if (pos + from2 > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
        pos += from2;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding4 && pos >= from2)
        throw new Error("Excess padding");
      if (!padding4 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding4 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix4(num) {
      assertNumber2(num);
      return {
        encode: (bytes4) => {
          if (!(bytes4 instanceof Uint8Array))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix4(Array.from(bytes4), 2 ** 8, num);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of strings");
          return Uint8Array.from(convertRadix4(digits, num, 2 ** 8));
        }
      };
    }
    function radix23(bits, revPadding = false) {
      assertNumber2(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry3(8, bits) > 32 || radix2carry3(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes4) => {
          if (!(bytes4 instanceof Uint8Array))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix23(Array.from(bytes4), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of strings");
          return Uint8Array.from(convertRadix23(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper3(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e) {
        }
      };
    }
    function checksum(len, fn) {
      assertNumber2(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum2 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum2, data.length);
          return res;
        },
        decode(data) {
          if (!(data instanceof Uint8Array))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i2 = 0; i2 < len; i2++)
            if (newChecksum[i2] !== oldChecksum[i2])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = { alphabet: alphabet3, chain: chain3, checksum, radix: radix4, radix2: radix23, join: join3, padding: padding3 };
    exports.base16 = chain3(radix23(4), alphabet3("0123456789ABCDEF"), join3(""));
    exports.base32 = chain3(radix23(5), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding3(5), join3(""));
    exports.base32hex = chain3(radix23(5), alphabet3("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding3(5), join3(""));
    exports.base32crockford = chain3(radix23(5), alphabet3("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join3(""), normalize3((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports.base64 = chain3(radix23(6), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding3(6), join3(""));
    exports.base64url = chain3(radix23(6), alphabet3("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding3(6), join3(""));
    var genBase583 = (abc) => chain3(radix4(58), alphabet3(abc), join3(""));
    exports.base58 = genBase583("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase583("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase583("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN2 = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i2 = 0; i2 < data.length; i2 += 8) {
          const block = data.subarray(i2, i2 + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN2[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i2 = 0; i2 < str.length; i2 += 11) {
          const slice = str.slice(i2, i2 + 11);
          const blockLen = XMR_BLOCK_LEN2.indexOf(slice.length);
          const block = exports.base58.decode(slice);
          for (let j = 0; j < block.length - blockLen; j++) {
            if (block[j] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var base58check = (sha2563) => chain3(checksum(4, (data) => sha2563(sha2563(data))), exports.base58);
    exports.base58check = base58check;
    var BECH_ALPHABET3 = chain3(alphabet3("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join3(""));
    var POLYMOD_GENERATORS3 = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod3(pre) {
      const b = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i2 = 0; i2 < POLYMOD_GENERATORS3.length; i2++) {
        if ((b >> i2 & 1) === 1)
          chk ^= POLYMOD_GENERATORS3[i2];
      }
      return chk;
    }
    function bechChecksum3(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i2 = 0; i2 < len; i2++) {
        const c = prefix.charCodeAt(i2);
        if (c < 33 || c > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod3(chk) ^ c >> 5;
      }
      chk = bech32Polymod3(chk);
      for (let i2 = 0; i2 < len; i2++)
        chk = bech32Polymod3(chk) ^ prefix.charCodeAt(i2) & 31;
      for (let v of words)
        chk = bech32Polymod3(chk) ^ v;
      for (let i2 = 0; i2 < 6; i2++)
        chk = bech32Polymod3(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET3.encode(convertRadix23([chk % 2 ** 30], 30, 5, false));
    }
    function genBech323(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix23(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper3(fromWords);
      function encode(prefix, words, limit2 = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit2 !== false && actualLength > limit2)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
        prefix = prefix.toLowerCase();
        return `${prefix}1${BECH_ALPHABET3.encode(words)}${bechChecksum3(prefix, words, ENCODING_CONST)}`;
      }
      function decode4(str, limit2 = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit2 !== false && str.length > limit2)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit2})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        str = lowered;
        const sepIndex = str.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = str.slice(0, sepIndex);
        const _words2 = str.slice(sepIndex + 1);
        if (_words2.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET3.decode(_words2).slice(0, -6);
        const sum = bechChecksum3(prefix, words, ENCODING_CONST);
        if (!_words2.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper3(decode4);
      function decodeToBytes(str) {
        const { prefix, words } = decode4(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      return { encode, decode: decode4, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
    }
    exports.bech32 = genBech323("bech32");
    exports.bech32m = genBech323("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports.hex = chain3(radix23(4), alphabet3("0123456789abcdef"), join3(""), normalize3((s) => {
      if (typeof s !== "string" || s.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
      return s.toLowerCase();
    }));
    var CODERS2 = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError2 = `Invalid encoding type. Available types: ${Object.keys(CODERS2).join(", ")}`;
    var bytesToString = (type, bytes4) => {
      if (typeof type !== "string" || !CODERS2.hasOwnProperty(type))
        throw new TypeError(coderTypeError2);
      if (!(bytes4 instanceof Uint8Array))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS2[type].encode(bytes4);
    };
    exports.bytesToString = bytesToString;
    exports.str = exports.bytesToString;
    var stringToBytes = (type, str) => {
      if (!CODERS2.hasOwnProperty(type))
        throw new TypeError(coderTypeError2);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS2[type].decode(str);
    };
    exports.stringToBytes = stringToBytes;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/light-bolt11-decoder/bolt11.js
var require_bolt11 = __commonJS({
  "node_modules/light-bolt11-decoder/bolt11.js"(exports, module) {
    var { bech32: bech323, hex: hex3, utf8: utf82 } = require_lib();
    var DEFAULTNETWORK = {
      // default network is bitcoin
      bech32: "bc",
      pubKeyHash: 0,
      scriptHash: 5,
      validWitnessVersions: [0]
    };
    var TESTNETWORK = {
      bech32: "tb",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var SIGNETNETWORK = {
      bech32: "tbs",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var REGTESTNETWORK = {
      bech32: "bcrt",
      pubKeyHash: 111,
      scriptHash: 196,
      validWitnessVersions: [0]
    };
    var SIMNETWORK = {
      bech32: "sb",
      pubKeyHash: 63,
      scriptHash: 123,
      validWitnessVersions: [0]
    };
    var FEATUREBIT_ORDER = [
      "option_data_loss_protect",
      "initial_routing_sync",
      "option_upfront_shutdown_script",
      "gossip_queries",
      "var_onion_optin",
      "gossip_queries_ex",
      "option_static_remotekey",
      "payment_secret",
      "basic_mpp",
      "option_support_large_channel"
    ];
    var DIVISORS = {
      m: BigInt(1e3),
      u: BigInt(1e6),
      n: BigInt(1e9),
      p: BigInt(1e12)
    };
    var MAX_MILLISATS = BigInt("2100000000000000000");
    var MILLISATS_PER_BTC = BigInt(1e11);
    var TAGCODES = {
      payment_hash: 1,
      payment_secret: 16,
      description: 13,
      payee: 19,
      description_hash: 23,
      // commit to longer descriptions (used by lnurl-pay)
      expiry: 6,
      // default: 3600 (1 hour)
      min_final_cltv_expiry: 24,
      // default: 9
      fallback_address: 9,
      route_hint: 3,
      // for extra routing info (private etc.)
      feature_bits: 5,
      metadata: 27
    };
    var TAGNAMES = {};
    for (let i2 = 0, keys = Object.keys(TAGCODES); i2 < keys.length; i2++) {
      const currentName = keys[i2];
      const currentCode = TAGCODES[keys[i2]].toString();
      TAGNAMES[currentCode] = currentName;
    }
    var TAGPARSERS = {
      1: (words) => hex3.encode(bech323.fromWordsUnsafe(words)),
      // 256 bits
      16: (words) => hex3.encode(bech323.fromWordsUnsafe(words)),
      // 256 bits
      13: (words) => utf82.encode(bech323.fromWordsUnsafe(words)),
      // string variable length
      19: (words) => hex3.encode(bech323.fromWordsUnsafe(words)),
      // 264 bits
      23: (words) => hex3.encode(bech323.fromWordsUnsafe(words)),
      // 256 bits
      27: (words) => hex3.encode(bech323.fromWordsUnsafe(words)),
      // variable
      6: wordsToIntBE,
      // default: 3600 (1 hour)
      24: wordsToIntBE,
      // default: 9
      3: routingInfoParser,
      // for extra routing info (private etc.)
      5: featureBitsParser
      // keep feature bits as array of 5 bit words
    };
    function getUnknownParser(tagCode) {
      return (words) => ({
        tagCode: parseInt(tagCode),
        words: bech323.encode("unknown", words, Number.MAX_SAFE_INTEGER)
      });
    }
    function wordsToIntBE(words) {
      return words.reverse().reduce((total, item, index) => {
        return total + item * Math.pow(32, index);
      }, 0);
    }
    function routingInfoParser(words) {
      const routes = [];
      let pubkey, shortChannelId, feeBaseMSats, feeProportionalMillionths, cltvExpiryDelta;
      let routesBuffer = bech323.fromWordsUnsafe(words);
      while (routesBuffer.length > 0) {
        pubkey = hex3.encode(routesBuffer.slice(0, 33));
        shortChannelId = hex3.encode(routesBuffer.slice(33, 41));
        feeBaseMSats = parseInt(hex3.encode(routesBuffer.slice(41, 45)), 16);
        feeProportionalMillionths = parseInt(
          hex3.encode(routesBuffer.slice(45, 49)),
          16
        );
        cltvExpiryDelta = parseInt(hex3.encode(routesBuffer.slice(49, 51)), 16);
        routesBuffer = routesBuffer.slice(51);
        routes.push({
          pubkey,
          short_channel_id: shortChannelId,
          fee_base_msat: feeBaseMSats,
          fee_proportional_millionths: feeProportionalMillionths,
          cltv_expiry_delta: cltvExpiryDelta
        });
      }
      return routes;
    }
    function featureBitsParser(words) {
      const bools = words.slice().reverse().map((word) => [
        !!(word & 1),
        !!(word & 2),
        !!(word & 4),
        !!(word & 8),
        !!(word & 16)
      ]).reduce((finalArr, itemArr) => finalArr.concat(itemArr), []);
      while (bools.length < FEATUREBIT_ORDER.length * 2) {
        bools.push(false);
      }
      const featureBits = {};
      FEATUREBIT_ORDER.forEach((featureName, index) => {
        let status;
        if (bools[index * 2]) {
          status = "required";
        } else if (bools[index * 2 + 1]) {
          status = "supported";
        } else {
          status = "unsupported";
        }
        featureBits[featureName] = status;
      });
      const extraBits = bools.slice(FEATUREBIT_ORDER.length * 2);
      featureBits.extra_bits = {
        start_bit: FEATUREBIT_ORDER.length * 2,
        bits: extraBits,
        has_required: extraBits.reduce(
          (result, bit, index) => index % 2 !== 0 ? result || false : result || bit,
          false
        )
      };
      return featureBits;
    }
    function hrpToMillisat(hrpString, outputString) {
      let divisor, value;
      if (hrpString.slice(-1).match(/^[munp]$/)) {
        divisor = hrpString.slice(-1);
        value = hrpString.slice(0, -1);
      } else if (hrpString.slice(-1).match(/^[^munp0-9]$/)) {
        throw new Error("Not a valid multiplier for the amount");
      } else {
        value = hrpString;
      }
      if (!value.match(/^\d+$/))
        throw new Error("Not a valid human readable amount");
      const valueBN = BigInt(value);
      const millisatoshisBN = divisor ? valueBN * MILLISATS_PER_BTC / DIVISORS[divisor] : valueBN * MILLISATS_PER_BTC;
      if (divisor === "p" && !(valueBN % BigInt(10) === BigInt(0)) || millisatoshisBN > MAX_MILLISATS) {
        throw new Error("Amount is outside of valid range");
      }
      return outputString ? millisatoshisBN.toString() : millisatoshisBN;
    }
    function decode4(paymentRequest, network) {
      if (typeof paymentRequest !== "string")
        throw new Error("Lightning Payment Request must be string");
      if (paymentRequest.slice(0, 2).toLowerCase() !== "ln")
        throw new Error("Not a proper lightning payment request");
      const sections = [];
      const decoded = bech323.decode(paymentRequest, Number.MAX_SAFE_INTEGER);
      paymentRequest = paymentRequest.toLowerCase();
      const prefix = decoded.prefix;
      let words = decoded.words;
      let letters = paymentRequest.slice(prefix.length + 1);
      let sigWords = words.slice(-104);
      words = words.slice(0, -104);
      let prefixMatches = prefix.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);
      if (prefixMatches && !prefixMatches[2])
        prefixMatches = prefix.match(/^ln(\S+)$/);
      if (!prefixMatches) {
        throw new Error("Not a proper lightning payment request");
      }
      sections.push({
        name: "lightning_network",
        letters: "ln"
      });
      const bech32Prefix = prefixMatches[1];
      let coinNetwork;
      if (!network) {
        switch (bech32Prefix) {
          case DEFAULTNETWORK.bech32:
            coinNetwork = DEFAULTNETWORK;
            break;
          case TESTNETWORK.bech32:
            coinNetwork = TESTNETWORK;
            break;
          case SIGNETNETWORK.bech32:
            coinNetwork = SIGNETNETWORK;
            break;
          case REGTESTNETWORK.bech32:
            coinNetwork = REGTESTNETWORK;
            break;
          case SIMNETWORK.bech32:
            coinNetwork = SIMNETWORK;
            break;
        }
      } else {
        if (network.bech32 === void 0 || network.pubKeyHash === void 0 || network.scriptHash === void 0 || !Array.isArray(network.validWitnessVersions))
          throw new Error("Invalid network");
        coinNetwork = network;
      }
      if (!coinNetwork || coinNetwork.bech32 !== bech32Prefix) {
        throw new Error("Unknown coin bech32 prefix");
      }
      sections.push({
        name: "coin_network",
        letters: bech32Prefix,
        value: coinNetwork
      });
      const value = prefixMatches[2];
      let millisatoshis;
      if (value) {
        const divisor = prefixMatches[3];
        millisatoshis = hrpToMillisat(value + divisor, true);
        sections.push({
          name: "amount",
          letters: prefixMatches[2] + prefixMatches[3],
          value: millisatoshis
        });
      } else {
        millisatoshis = null;
      }
      sections.push({
        name: "separator",
        letters: "1"
      });
      const timestamp2 = wordsToIntBE(words.slice(0, 7));
      words = words.slice(7);
      sections.push({
        name: "timestamp",
        letters: letters.slice(0, 7),
        value: timestamp2
      });
      letters = letters.slice(7);
      let tagName, parser, tagLength, tagWords;
      while (words.length > 0) {
        const tagCode = words[0].toString();
        tagName = TAGNAMES[tagCode] || "unknown_tag";
        parser = TAGPARSERS[tagCode] || getUnknownParser(tagCode);
        words = words.slice(1);
        tagLength = wordsToIntBE(words.slice(0, 2));
        words = words.slice(2);
        tagWords = words.slice(0, tagLength);
        words = words.slice(tagLength);
        sections.push({
          name: tagName,
          tag: letters[0],
          letters: letters.slice(0, 1 + 2 + tagLength),
          value: parser(tagWords)
          // see: parsers for more comments
        });
        letters = letters.slice(1 + 2 + tagLength);
      }
      sections.push({
        name: "signature",
        letters: letters.slice(0, 104),
        value: hex3.encode(bech323.fromWordsUnsafe(sigWords))
      });
      letters = letters.slice(104);
      sections.push({
        name: "checksum",
        letters
      });
      let result = {
        paymentRequest,
        sections,
        get expiry() {
          let exp = sections.find((s) => s.name === "expiry");
          if (exp) return getValue("timestamp") + exp.value;
        },
        get route_hints() {
          return sections.filter((s) => s.name === "route_hint").map((s) => s.value);
        }
      };
      for (let name in TAGCODES) {
        if (name === "route_hint") {
          continue;
        }
        Object.defineProperty(result, name, {
          get() {
            return getValue(name);
          }
        });
      }
      return result;
      function getValue(name) {
        let section = sections.find((s) => s.name === name);
        return section ? section.value : void 0;
      }
    }
    module.exports = {
      decode: decode4,
      hrpToMillisat
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash3 = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash3 = (hash3 << 5) - hash3 + namespace.charCodeAt(i2);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self, args);
          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }
        debug2.namespace = namespace;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip2 of createDebug.skips) {
          if (matchesTemplate(name, skip2)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bytes(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash3.outputLen);
  number(hash3.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js
var u8a = (a) => a instanceof Uint8Array;
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!u8a(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrays.forEach((a) => {
    if (!u8a(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad2);
    pad2 += a.length;
  });
  return r;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE5) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE5);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE5 ? 4 : 0;
  const l = isLE5 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE5);
  view.setUint32(byteOffset + l, wl, isLE5);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE5) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE5;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE5 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE5);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE5);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W2 = SHA256_W[i2 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes,
  hexToNumber: () => hexToNumber,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a2 = (a) => a instanceof Uint8Array;
var hexes2 = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex(bytes4) {
  if (!u8a2(bytes4))
    throw new Error("Uint8Array expected");
  let hex3 = "";
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    hex3 += hexes2[bytes4[i2]];
  }
  return hex3;
}
function numberToHexUnpadded(num) {
  const hex3 = num.toString(16);
  return hex3.length & 1 ? `0${hex3}` : hex3;
}
function hexToNumber(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  return BigInt(hex3 === "" ? "0" : `0x${hex3}`);
}
function hexToBytes(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  const len = hex3.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex3.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function bytesToNumberBE(bytes4) {
  return hexToNumber(bytesToHex(bytes4));
}
function bytesToNumberLE(bytes4) {
  if (!u8a2(bytes4))
    throw new Error("Uint8Array expected");
  return hexToNumber(bytesToHex(Uint8Array.from(bytes4).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
function ensureBytes(title, hex3, expectedLength) {
  let res;
  if (typeof hex3 === "string") {
    try {
      res = hexToBytes(hex3);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex3}". Cause: ${e}`);
    }
  } else if (u8a2(hex3)) {
    res = Uint8Array.from(hex3);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrays.forEach((a) => {
    if (!u8a2(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad2);
    pad2 += a.length;
  });
  return r;
}
function equalBytes(b1, b2) {
  if (b1.length !== b2.length)
    return false;
  for (let i2 = 0; i2 < b1.length; i2++)
    if (b1[i2] !== b2[i2])
      return false;
  return true;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0; n > _0n; n >>= _1n, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
var bitSet = (n, pos, value) => {
  return n | (value ? _1n : _0n) << BigInt(pos);
};
var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i2 = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i2 = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen = () => {
    if (i2++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/modular.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a, b) {
  const result = a % b;
  return result >= _0n2 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n2 || power < _0n2)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n2)
    return _0n2;
  let res = _1n2;
  while (power > _0n2) {
    if (power & _1n2)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n2;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n2) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number4, modulo) {
  if (number4 === _0n2 || modulo <= _0n2) {
    throw new Error(`invert: expected positive integers, got n=${number4} mod=${modulo}`);
  }
  let a = mod(number4, modulo);
  let b = modulo;
  let x = _0n2, y = _1n2, u = _1n2, v = _0n2;
  while (a !== _0n2) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd3 = b;
  if (gcd3 !== _1n2)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n2) / _2n2;
  let Q, S, Z;
  for (Q = P - _1n2, S = 0; Q % _2n2 === _0n2; Q /= _2n2, S++)
    ;
  for (Z = _2n2; Z < P && pow(Z, legendreC, P) !== P - _1n2; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n2) / _4n;
    return function tonelliFast(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n2) / _2n2;
  return function tonelliSlow(Fp2, n) {
    if (Fp2.pow(n, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp2.pow(Fp2.mul(Fp2.ONE, Z), Q);
    let x = Fp2.pow(n, Q1div2);
    let b = Fp2.pow(n, Q);
    while (!Fp2.eql(b, Fp2.ONE)) {
      if (Fp2.eql(b, Fp2.ZERO))
        return Fp2.ZERO;
      let m = 1;
      for (let t2 = Fp2.sqr(b); m < r; m++) {
        if (Fp2.eql(t2, Fp2.ONE))
          break;
        t2 = Fp2.sqr(t2);
      }
      const ge2 = Fp2.pow(g, _1n2 << BigInt(r - m - 1));
      g = Fp2.sqr(ge2);
      x = Fp2.mul(x, ge2);
      b = Fp2.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n2) / _4n;
    return function sqrt3mod4(Fp2, n) {
      const root = Fp2.pow(n, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp2, n) {
      const n2 = Fp2.mul(n, _2n2);
      const v = Fp2.pow(n2, c1);
      const nv = Fp2.mul(n, v);
      const i2 = Fp2.mul(Fp2.mul(nv, _2n2), v);
      const root = Fp2.mul(nv, Fp2.sub(i2, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map2, val) => {
    map2[val] = "function";
    return map2;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n2)
    throw new Error("Expected power > 0");
  if (power === _0n2)
    return f.ONE;
  if (power === _1n2)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n2) {
    if (power & _1n2)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n2;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i2) => {
    if (f.is0(num))
      return acc;
    tmp[i2] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i2) => {
    if (f.is0(num))
      return acc;
    tmp[i2] = f.mul(acc, tmp[i2]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE5 = false, redef = {}) {
  if (ORDER <= _0n2)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n2,
    ONE: _1n2,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n2 <= num && num < ORDER;
    },
    is0: (num) => num === _0n2,
    isOdd: (num) => (num & _1n2) === _1n2,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE5 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes4) => {
      if (bytes4.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes4.length}`);
      return isLE5 ? bytesToNumberLE(bytes4) : bytesToNumberBE(bytes4);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE5 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE5 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n2) + _1n2;
  return isLE5 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/curve.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n3) {
        if (n & _1n3)
          p = p.add(d);
        d = d.double();
        n >>= _1n3;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window3 = 0; window3 < windows; window3++) {
        base = p;
        points.push(base);
        for (let i2 = 1; i2 < windowSize; i2++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window3 = 0; window3 < windows; window3++) {
        const offset = window3 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n3;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window3 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a } = opts;
  if (endo) {
    if (!Fp2.eql(a, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex3) {
    const { Err: E } = DER;
    const data = typeof hex3 === "string" ? h2b(hex3) : hex3;
    if (!(data instanceof Uint8Array))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex3 = num.toString(16);
      return hex3.length & 1 ? `0${hex3}` : hex3;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var _2n3 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes5 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a.x), Fp2.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes4) => {
    const tail = bytes4.subarray(1);
    const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp2.sqr(x);
    const x3 = Fp2.mul(x2, x);
    return Fp2.add(Fp2.add(x3, Fp2.mul(x, a)), b);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (key instanceof Uint8Array)
        key = bytesToHex(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point2))
      throw new Error("ProjectivePoint expected");
  }
  class Point2 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point2)
        throw new Error("projective point not allowed");
      const is0 = (i2) => Fp2.eql(i2, Fp2.ZERO);
      if (is0(x) && is0(y))
        return Point2.ZERO;
      return new Point2(x, y, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p) => p.pz));
      return points.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex3) {
      const P = Point2.fromAffine(fromBytes(ensureBytes("pointHex", hex3)));
      P.assertValidity();
      return P;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp2.isValid(x) || !Fp2.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));
      const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));
      return U1 && U2;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point2(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a, b } = CURVE;
      const b3 = Fp2.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t2 = Fp2.mul(Z1, Z1);
      let t3 = Fp2.mul(X1, Y1);
      t3 = Fp2.add(t3, t3);
      Z3 = Fp2.mul(X1, Z1);
      Z3 = Fp2.add(Z3, Z3);
      X3 = Fp2.mul(a, Z3);
      Y3 = Fp2.mul(b3, t2);
      Y3 = Fp2.add(X3, Y3);
      X3 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X3, Y3);
      X3 = Fp2.mul(t3, X3);
      Z3 = Fp2.mul(b3, Z3);
      t2 = Fp2.mul(a, t2);
      t3 = Fp2.sub(t0, t2);
      t3 = Fp2.mul(a, t3);
      t3 = Fp2.add(t3, Z3);
      Z3 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z3, t0);
      t0 = Fp2.add(t0, t2);
      t0 = Fp2.mul(t0, t3);
      Y3 = Fp2.add(Y3, t0);
      t2 = Fp2.mul(Y1, Z1);
      t2 = Fp2.add(t2, t2);
      t0 = Fp2.mul(t2, t3);
      X3 = Fp2.sub(X3, t0);
      Z3 = Fp2.mul(t2, t1);
      Z3 = Fp2.add(Z3, Z3);
      Z3 = Fp2.add(Z3, Z3);
      return new Point2(X3, Y3, Z3);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;
      const a = CURVE.a;
      const b3 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X2);
      let t1 = Fp2.mul(Y1, Y2);
      let t2 = Fp2.mul(Z1, Z2);
      let t3 = Fp2.add(X1, Y1);
      let t4 = Fp2.add(X2, Y2);
      t3 = Fp2.mul(t3, t4);
      t4 = Fp2.add(t0, t1);
      t3 = Fp2.sub(t3, t4);
      t4 = Fp2.add(X1, Z1);
      let t5 = Fp2.add(X2, Z2);
      t4 = Fp2.mul(t4, t5);
      t5 = Fp2.add(t0, t2);
      t4 = Fp2.sub(t4, t5);
      t5 = Fp2.add(Y1, Z1);
      X3 = Fp2.add(Y2, Z2);
      t5 = Fp2.mul(t5, X3);
      X3 = Fp2.add(t1, t2);
      t5 = Fp2.sub(t5, X3);
      Z3 = Fp2.mul(a, t4);
      X3 = Fp2.mul(b3, t2);
      Z3 = Fp2.add(X3, Z3);
      X3 = Fp2.sub(t1, Z3);
      Z3 = Fp2.add(t1, Z3);
      Y3 = Fp2.mul(X3, Z3);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.mul(b3, t4);
      t1 = Fp2.add(t1, t2);
      t2 = Fp2.sub(t0, t2);
      t2 = Fp2.mul(a, t2);
      t4 = Fp2.add(t4, t2);
      t0 = Fp2.mul(t1, t4);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t5, t4);
      X3 = Fp2.mul(t3, X3);
      X3 = Fp2.sub(X3, t0);
      t0 = Fp2.mul(t3, t1);
      Z3 = Fp2.mul(t5, Z3);
      Z3 = Fp2.add(Z3, t0);
      return new Point2(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point2.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i2) => p.toAffine(toInv[i2])).map(Point2.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n) {
      const I = Point2.ZERO;
      if (n === _0n4)
        return I;
      assertGE(n);
      if (n === _1n4)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n4 || k2 > _0n4) {
        if (k1 & _1n4)
          k1p = k1p.add(d);
        if (k2 & _1n4)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n4;
        k2 >>= _1n4;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point2(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point2.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point2.BASE;
      const mul3 = (P, a2) => a2 === _0n4 || a2 === _1n4 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul3(this, a).add(mul3(Q, b));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x, py: y, pz: z } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z);
      const ax = Fp2.mul(x, iz);
      const ay = Fp2.mul(y, iz);
      const zz = Fp2.mul(z, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n4)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point2, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n4)
        return this;
      if (clearCofactor)
        return clearCofactor(Point2, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes5(Point2, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex(this.toRawBytes(isCompressed));
    }
  }
  Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point2.ZERO = new Point2(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point2,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n4 < num && num < Fp2.ORDER;
  }
  function modN2(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp2.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp2.toBytes(a.y));
      }
    },
    fromBytes(bytes4) {
      const len = bytes4.length;
      const head = bytes4[0];
      const tail = bytes4.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp2.sqrt(y2);
        const isYOdd = (y & _1n4) === _1n4;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp2.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number4) {
    const HALF = CURVE_ORDER >> _1n4;
    return number4 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN2(-s) : s;
  }
  const slcNum = (b, from2, to) => bytesToNumberBE(b.slice(from2, to));
  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex3) {
      const l = CURVE.nByteLength;
      hex3 = ensureBytes("compactSignature", hex3, l * 2);
      return new Signature(slcNum(hex3, 0, l), slcNum(hex3, l, 2 * l));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex3) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex3));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point2.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h * ir);
      const u2 = modN2(s * ir);
      const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point2.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey2(privateKey, isCompressed = true) {
    return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = item instanceof Uint8Array;
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point2)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point2.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes4) {
    const num = bytesToNumberBE(bytes4);
    const delta = bytes4.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes4) {
    return modN2(bits2int(bytes4));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n4 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => k in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes4 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes4(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point2.BASE.multiply(k).toAffine();
      const r = modN2(q.x);
      if (r === _0n4)
        return;
      const s = modN2(ik * modN2(m + r * d));
      if (s === _0n4)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n4);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point2.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P;
    try {
      if (typeof sg === "string" || sg instanceof Uint8Array) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point2.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN2(h * is);
    const u2 = modN2(r * is);
    const R = (_a = Point2.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
    if (!R)
      return false;
    const v = modN2(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey: getPublicKey2,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point2,
    Signature,
    utils
  };
}
function SWUFpSqrtRatio(Fp2, Z) {
  const q = Fp2.ORDER;
  let l = _0n4;
  for (let o = q - _1n4; o % _2n3 === _0n4; o /= _2n3)
    l += _1n4;
  const c1 = l;
  const _2n_pow_c1_1 = _2n3 << c1 - _1n4 - _1n4;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n3;
  const c2 = (q - _1n4) / _2n_pow_c1;
  const c3 = (c2 - _1n4) / _2n3;
  const c4 = _2n_pow_c1 - _1n4;
  const c5 = _2n_pow_c1_1;
  const c6 = Fp2.pow(Z, c2);
  const c7 = Fp2.pow(Z, (c2 + _1n4) / _2n3);
  let sqrtRatio = (u, v) => {
    let tv1 = c6;
    let tv2 = Fp2.pow(v, c4);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v);
    let tv5 = Fp2.mul(u, tv3);
    tv5 = Fp2.pow(tv5, c3);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v);
    tv3 = Fp2.mul(tv5, u);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c5);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c7);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i2 = c1; i2 > _1n4; i2--) {
      let tv52 = i2 - _2n3;
      tv52 = _2n3 << tv52 - _1n4;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c22 = Fp2.sqrt(Fp2.neg(Z));
    sqrtRatio = (u, v) => {
      let tv1 = Fp2.sqr(v);
      const tv2 = Fp2.mul(u, v);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y2 = Fp2.mul(y1, c22);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v);
      const isQR = Fp2.eql(tv3, u);
      let y = Fp2.cmov(y2, y1, isQR);
      return { isValid: isQR, value: y };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp2.sqr(u);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x = Fp2.mul(tv1, tv3);
    const { isValid: isValid2, value } = sqrtRatio(tv2, tv6);
    y = Fp2.mul(tv1, u);
    y = Fp2.mul(y, value);
    x = Fp2.cmov(x, tv3, isValid2);
    y = Fp2.cmov(y, value, isValid2);
    const e1 = Fp2.isOdd(u) === Fp2.isOdd(y);
    y = Fp2.cmov(Fp2.neg(y), y, e1);
    x = Fp2.div(x, tv4);
    return { x, y };
  };
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
function validateDST(dst) {
  if (dst instanceof Uint8Array)
    return dst;
  if (typeof dst === "string")
    return utf8ToBytes2(dst);
  throw new Error("DST must be Uint8Array or string");
}
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i2 = length - 1; i2 >= 0; i2--) {
    res[i2] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  const arr = new Uint8Array(a.length);
  for (let i2 = 0; i2 < a.length; i2++) {
    arr[i2] = a[i2] ^ b[i2];
  }
  return arr;
}
function isBytes(item) {
  if (!(item instanceof Uint8Array))
    throw new Error("Uint8Array expected");
}
function isNum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255)
    DST = H(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b = new Array(ell);
  const b_0 = H(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i2 = 1; i2 <= ell; i2++) {
    const args = [strxor(b_0, b[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
    b[i2] = H(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k / 8);
    DST = H.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count2, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p, k, m, hash: hash3, expand: expand3, DST: _DST } = options;
  isBytes(msg);
  isNum(count2);
  const DST = validateDST(_DST);
  const log2p = p.toString(2).length;
  const L = Math.ceil((log2p + k) / 8);
  const len_in_bytes = count2 * m * L;
  let prb;
  if (expand3 === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash3);
  } else if (expand3 === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash3);
  } else if (expand3 === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u = new Array(count2);
  for (let i2 = 0; i2 < count2; i2++) {
    const e = new Array(m);
    for (let j = 0; j < m; j++) {
      const elm_offset = L * (j + i2 * m);
      const tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = mod(os2ip(tv), p);
    }
    u[i2] = e;
  }
  return u;
}
function isogenyMap(field, map2) {
  const COEFF = map2.map((i2) => Array.from(i2).reverse());
  return (x, y) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x), i2)));
    x = field.div(xNum, xDen);
    y = field.mul(y, field.div(yNum, yDen));
    return { x, y };
  };
}
function createHasher(Point2, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point2.fromAffine(mapToCurve(u[0]));
      const u1 = Point2.fromAffine(mapToCurve(u[1]));
      const P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P = Point2.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}

// node_modules/nostr-tools/node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/nostr-tools/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/nostr-tools/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n4) / b;
function sqrtMod(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n4, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n4, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n5 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n5 = BigInt(0);
var fe = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1P;
var ge = (x) => typeof x === "bigint" && _0n5 < x && x < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n) => numberToBytesBE(n, 32);
var modP = (x) => mod(x, secp256k1P);
var modN = (x) => mod(x, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p = Point.fromPrivateKey(d_);
  const scalar = p.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p) };
}
function lift_x(x) {
  if (!fe(x))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x * x);
  const c = modP(xx * x + BigInt(7));
  let y = sqrtMod(c);
  if (y % _2n4 !== _0n5)
    y = modP(-y);
  const p = new Point(x, y, _1n5);
  p.assertValidity();
  return p;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m = ensureBytes("message", message);
  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
  const a = ensureBytes("auxRand", auxRand, 32);
  const t = numTo32b(d ^ bytesToNumberBE(taggedHash("BIP0340/aux", a)));
  const rand = taggedHash("BIP0340/nonce", t, px, m);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n5)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
  const e = challenge(rx, px, m);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  if (!schnorrVerify(sig, m, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P = lift_x(bytesToNumberBE(pub));
    const r = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r))
      return false;
    const s = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s))
      return false;
    const e = challenge(numTo32b(r), pointToBytes(P), m);
    const R = GmulAdd(P, s, modN(-e));
    if (!R || !R.hasEvenY() || R.toAffine().x !== r)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j) => BigInt(j)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x, y } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x, y);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/utils.js
var u8a3 = (a) => a instanceof Uint8Array;
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var hexes3 = Array.from({ length: 256 }, (v, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(bytes4) {
  if (!u8a3(bytes4))
    throw new Error("Uint8Array expected");
  let hex3 = "";
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    hex3 += hexes3[bytes4[i2]];
  }
  return hex3;
}
function hexToBytes2(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  const len = hex3.length;
  if (len % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + len);
  const array = new Uint8Array(len / 2);
  for (let i2 = 0; i2 < array.length; i2++) {
    const j = i2 * 2;
    const hexByte = hex3.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array[i2] = byte;
  }
  return array;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes3(data);
  if (!u8a3(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes3(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad2 = 0;
  arrays.forEach((a) => {
    if (!u8a3(a))
      throw new Error("Uint8Array expected");
    r.set(a, pad2);
    pad2 += a.length;
  });
  return r;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto2 && typeof crypto2.getRandomValues === "function") {
    return crypto2.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/_assert.js
function number2(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes2(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(hash3.outputLen);
  number2(hash3.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}
var assert = {
  number: number2,
  bool,
  bytes: bytes2,
  hash: hash2,
  exists: exists2,
  output: output2
};
var assert_default = assert;

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view, byteOffset, value, isLE5) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE5);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE5 ? 4 : 0;
  const l = isLE5 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE5);
  view.setUint32(byteOffset + l, wl, isLE5);
}
var SHA22 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE5) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE5;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    assert_default.exists(this);
    const { view, buffer: buffer2, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.output(out, this);
    this.finished = true;
    const { buffer: buffer2, view, blockLen, isLE: isLE5 } = this;
    let { pos } = this;
    buffer2[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer2[i2] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE5);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE5);
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer: buffer2, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer2);
    return to;
  }
};

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b, c) => a & b ^ ~a & c;
var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2562 = class extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  // prettier-ignore
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W2[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W2[i2 - 15];
      const W2 = SHA256_W2[i2 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T1 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA2242 = class extends SHA2562 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2562 = wrapConstructor2(() => new SHA2562());
var sha2242 = wrapConstructor2(() => new SHA2242());

// node_modules/nostr-tools/node_modules/@scure/base/lib/esm/index.js
function assertNumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`Wrong integer: ${n}`);
}
function chain(...args) {
  const wrap = (a, b) => (c) => a(b(c));
  const encode = Array.from(args).reverse().reduce((acc, i2) => acc ? wrap(acc, i2.encode) : i2.encode, void 0);
  const decode4 = args.reduce((acc, i2) => acc ? wrap(acc, i2.decode) : i2.decode, void 0);
  return { encode, decode: decode4 };
}
function alphabet(alphabet3) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i2) => {
        assertNumber(i2);
        if (i2 < 0 || i2 >= alphabet3.length)
          throw new Error(`Digit index outside alphabet: ${i2} (alphabet: ${alphabet3.length})`);
        return alphabet3[i2];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet3.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet3}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from2) => {
      if (!Array.isArray(from2) || from2.length && typeof from2[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i2 of from2)
        if (typeof i2 !== "string")
          throw new Error(`join.encode: non-string input=${i2}`);
      return from2.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i2 of data)
        if (typeof i2 !== "string")
          throw new Error(`padding.encode: non-string input=${i2}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i2 of input)
        if (typeof i2 !== "string")
          throw new Error(`padding.decode: non-string input=${i2}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from2) => from2, decode: (to) => fn(to) };
}
function convertRadix(data, from2, to) {
  if (from2 < 2)
    throw new Error(`convertRadix: wrong from=${from2}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d) => {
    assertNumber(d);
    if (d < 0 || d >= from2)
      throw new Error(`Wrong integer: ${d}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < digits.length; i2++) {
      const digit = digits[i2];
      const digitBase = from2 * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from2 * carry / from2 !== carry || digitBase - digit !== from2 * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      digits[i2] = Math.floor(digitBase / to);
      if (!Number.isSafeInteger(digits[i2]) || digits[i2] * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!digits[i2])
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd = (a, b) => !b ? a : gcd(b, a % b);
var radix2carry = (from2, to) => from2 + (to - gcd(from2, to));
function convertRadix2(data, from2, to, padding3) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from2 <= 0 || from2 > 32)
    throw new Error(`convertRadix2: wrong from=${from2}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from2, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry(from2, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n of data) {
    assertNumber(n);
    if (n >= 2 ** from2)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from2}`);
    carry = carry << from2 | n;
    if (pos + from2 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
    pos += from2;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding3 && pos >= from2)
    throw new Error("Excess padding");
  if (!padding3 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding3 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes4) => {
      if (!(bytes4 instanceof Uint8Array))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes4), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of strings");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes4) => {
      if (!(bytes4 instanceof Uint8Array))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes4), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of strings");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
var base58xmr = {
  encode(data) {
    let res = "";
    for (let i2 = 0; i2 < data.length; i2 += 8) {
      const block = data.subarray(i2, i2 + 8);
      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
    }
    return res;
  },
  decode(str) {
    let res = [];
    for (let i2 = 0; i2 < str.length; i2 += 11) {
      const slice = str.slice(i2, i2 + 11);
      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
      const block = base58.decode(slice);
      for (let j = 0; j < block.length - blockLen; j++) {
        if (block[j] !== 0)
          throw new Error("base58xmr: wrong padding");
      }
      res = res.concat(Array.from(block.slice(block.length - blockLen)));
    }
    return Uint8Array.from(res);
  }
};
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c = prefix.charCodeAt(i2);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v of words)
    chk = bech32Polymod(chk) ^ v;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode(prefix, words, limit2 = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    prefix = prefix.toLowerCase();
    return `${prefix}1${BECH_ALPHABET.encode(words)}${bechChecksum(prefix, words, ENCODING_CONST)}`;
  }
  function decode4(str, limit2 = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit2 !== false && str.length > limit2)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    str = lowered;
    const sepIndex = str.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = str.slice(0, sepIndex);
    const _words2 = str.slice(sepIndex + 1);
    if (_words2.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(_words2).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!_words2.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode4);
  function decodeToBytes(str) {
    const { prefix, words } = decode4(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode, decode: decode4, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var utf8 = {
  encode: (data) => new TextDecoder().decode(data),
  decode: (str) => new TextEncoder().encode(str)
};
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s) => {
  if (typeof s !== "string" || s.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));
var CODERS = {
  utf8,
  hex,
  base16,
  base32,
  base64,
  base64url,
  base58,
  base58xmr
};
var coderTypeError = `Invalid encoding type. Available types: ${Object.keys(CODERS).join(", ")}`;

// node_modules/@noble/ciphers/esm/_assert.js
function number3(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`positive integer expected, not ${n}`);
}
function bool2(b) {
  if (typeof b !== "boolean")
    throw new Error(`boolean expected, not ${b}`);
}
function isBytes2(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytes3(b, ...lengths) {
  if (!isBytes2(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function exists3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output3(out, instance) {
  bytes3(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error(`digestInto() expects output buffer of length at least ${min2}`);
  }
}

// node_modules/@noble/ciphers/esm/utils.js
var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var isLE3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE3)
  throw new Error("Non little-endian hardware is not supported");
var hexes4 = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function utf8ToBytes4(str) {
  if (typeof str !== "string")
    throw new Error(`string expected, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes3(data) {
  if (typeof data === "string")
    data = utf8ToBytes4(data);
  else if (isBytes2(data))
    data = data.slice();
  else
    throw new Error(`Uint8Array expected, got ${typeof data}`);
  return data;
}
function checkOpts(defaults, opts) {
  if (opts == null || typeof opts !== "object")
    throw new Error("options must be defined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function equalBytes2(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i2 = 0; i2 < a.length; i2++)
    diff |= a[i2] ^ b[i2];
  return diff === 0;
}
var wrapCipher = (params, c) => {
  Object.assign(c, params);
  return c;
};
function setBigUint643(view, byteOffset, value, isLE5) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE5);
  const _32n = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE5 ? 4 : 0;
  const l = isLE5 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE5);
  view.setUint32(byteOffset + l, wl, isLE5);
}

// node_modules/@noble/ciphers/esm/_polyval.js
var BLOCK_SIZE = 16;
var ZEROS16 = new Uint8Array(16);
var ZEROS32 = u32(ZEROS16);
var POLY = 225;
var mul2 = (s0, s1, s2, s3) => {
  const hiBit = s3 & 1;
  return {
    s3: s2 << 31 | s3 >>> 1,
    s2: s1 << 31 | s2 >>> 1,
    s1: s0 << 31 | s1 >>> 1,
    s0: s0 >>> 1 ^ POLY << 24 & -(hiBit & 1)
    // reduce % poly
  };
};
var swapLE = (n) => (n >>> 0 & 255) << 24 | (n >>> 8 & 255) << 16 | (n >>> 16 & 255) << 8 | n >>> 24 & 255 | 0;
function _toGHASHKey(k) {
  k.reverse();
  const hiBit = k[15] & 1;
  let carry = 0;
  for (let i2 = 0; i2 < k.length; i2++) {
    const t = k[i2];
    k[i2] = t >>> 1 | carry;
    carry = (t & 1) << 7;
  }
  k[0] ^= -hiBit & 225;
  return k;
}
var estimateWindow = (bytes4) => {
  if (bytes4 > 64 * 1024)
    return 8;
  if (bytes4 > 1024)
    return 4;
  return 2;
};
var GHASH = class {
  // We select bits per window adaptively based on expectedLength
  constructor(key, expectedLength) {
    this.blockLen = BLOCK_SIZE;
    this.outputLen = BLOCK_SIZE;
    this.s0 = 0;
    this.s1 = 0;
    this.s2 = 0;
    this.s3 = 0;
    this.finished = false;
    key = toBytes3(key);
    bytes3(key, 16);
    const kView = createView3(key);
    let k0 = kView.getUint32(0, false);
    let k1 = kView.getUint32(4, false);
    let k2 = kView.getUint32(8, false);
    let k3 = kView.getUint32(12, false);
    const doubles = [];
    for (let i2 = 0; i2 < 128; i2++) {
      doubles.push({ s0: swapLE(k0), s1: swapLE(k1), s2: swapLE(k2), s3: swapLE(k3) });
      ({ s0: k0, s1: k1, s2: k2, s3: k3 } = mul2(k0, k1, k2, k3));
    }
    const W = estimateWindow(expectedLength || 1024);
    if (![1, 2, 4, 8].includes(W))
      throw new Error(`ghash: wrong window size=${W}, should be 2, 4 or 8`);
    this.W = W;
    const bits = 128;
    const windows = bits / W;
    const windowSize = this.windowSize = 2 ** W;
    const items = [];
    for (let w = 0; w < windows; w++) {
      for (let byte = 0; byte < windowSize; byte++) {
        let s0 = 0, s1 = 0, s2 = 0, s3 = 0;
        for (let j = 0; j < W; j++) {
          const bit = byte >>> W - j - 1 & 1;
          if (!bit)
            continue;
          const { s0: d0, s1: d1, s2: d2, s3: d3 } = doubles[W * w + j];
          s0 ^= d0, s1 ^= d1, s2 ^= d2, s3 ^= d3;
        }
        items.push({ s0, s1, s2, s3 });
      }
    }
    this.t = items;
  }
  _updateBlock(s0, s1, s2, s3) {
    s0 ^= this.s0, s1 ^= this.s1, s2 ^= this.s2, s3 ^= this.s3;
    const { W, t, windowSize } = this;
    let o0 = 0, o1 = 0, o2 = 0, o3 = 0;
    const mask = (1 << W) - 1;
    let w = 0;
    for (const num of [s0, s1, s2, s3]) {
      for (let bytePos = 0; bytePos < 4; bytePos++) {
        const byte = num >>> 8 * bytePos & 255;
        for (let bitPos = 8 / W - 1; bitPos >= 0; bitPos--) {
          const bit = byte >>> W * bitPos & mask;
          const { s0: e0, s1: e1, s2: e2, s3: e3 } = t[w * windowSize + bit];
          o0 ^= e0, o1 ^= e1, o2 ^= e2, o3 ^= e3;
          w += 1;
        }
      }
    }
    this.s0 = o0;
    this.s1 = o1;
    this.s2 = o2;
    this.s3 = o3;
  }
  update(data) {
    data = toBytes3(data);
    exists3(this);
    const b32 = u32(data);
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    const left = data.length % BLOCK_SIZE;
    for (let i2 = 0; i2 < blocks; i2++) {
      this._updateBlock(b32[i2 * 4 + 0], b32[i2 * 4 + 1], b32[i2 * 4 + 2], b32[i2 * 4 + 3]);
    }
    if (left) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(ZEROS32[0], ZEROS32[1], ZEROS32[2], ZEROS32[3]);
      ZEROS32.fill(0);
    }
    return this;
  }
  destroy() {
    const { t } = this;
    for (const elm of t) {
      elm.s0 = 0, elm.s1 = 0, elm.s2 = 0, elm.s3 = 0;
    }
  }
  digestInto(out) {
    exists3(this);
    output3(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u32(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out;
  }
  digest() {
    const res = new Uint8Array(BLOCK_SIZE);
    this.digestInto(res);
    this.destroy();
    return res;
  }
};
var Polyval = class extends GHASH {
  constructor(key, expectedLength) {
    key = toBytes3(key);
    const ghKey = _toGHASHKey(key.slice());
    super(ghKey, expectedLength);
    ghKey.fill(0);
  }
  update(data) {
    data = toBytes3(data);
    exists3(this);
    const b32 = u32(data);
    const left = data.length % BLOCK_SIZE;
    const blocks = Math.floor(data.length / BLOCK_SIZE);
    for (let i2 = 0; i2 < blocks; i2++) {
      this._updateBlock(swapLE(b32[i2 * 4 + 3]), swapLE(b32[i2 * 4 + 2]), swapLE(b32[i2 * 4 + 1]), swapLE(b32[i2 * 4 + 0]));
    }
    if (left) {
      ZEROS16.set(data.subarray(blocks * BLOCK_SIZE));
      this._updateBlock(swapLE(ZEROS32[3]), swapLE(ZEROS32[2]), swapLE(ZEROS32[1]), swapLE(ZEROS32[0]));
      ZEROS32.fill(0);
    }
    return this;
  }
  digestInto(out) {
    exists3(this);
    output3(out, this);
    this.finished = true;
    const { s0, s1, s2, s3 } = this;
    const o32 = u32(out);
    o32[0] = s0;
    o32[1] = s1;
    o32[2] = s2;
    o32[3] = s3;
    return out.reverse();
  }
};
function wrapConstructorWithKey(hashCons) {
  const hashC = (msg, key) => hashCons(key, msg.length).update(toBytes3(msg)).digest();
  const tmp = hashCons(new Uint8Array(16), 0);
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key, expectedLength) => hashCons(key, expectedLength);
  return hashC;
}
var ghash = wrapConstructorWithKey((key, expectedLength) => new GHASH(key, expectedLength));
var polyval = wrapConstructorWithKey((key, expectedLength) => new Polyval(key, expectedLength));

// node_modules/@noble/ciphers/esm/aes.js
var BLOCK_SIZE2 = 16;
var BLOCK_SIZE32 = 4;
var EMPTY_BLOCK = new Uint8Array(BLOCK_SIZE2);
var POLY2 = 283;
function mul22(n) {
  return n << 1 ^ POLY2 & -(n >> 7);
}
function mul(a, b) {
  let res = 0;
  for (; b > 0; b >>= 1) {
    res ^= a & -(b & 1);
    a = mul22(a);
  }
  return res;
}
var sbox = (() => {
  let t = new Uint8Array(256);
  for (let i2 = 0, x = 1; i2 < 256; i2++, x ^= mul22(x))
    t[i2] = x;
  const box = new Uint8Array(256);
  box[0] = 99;
  for (let i2 = 0; i2 < 255; i2++) {
    let x = t[255 - i2];
    x |= x << 8;
    box[t[i2]] = (x ^ x >> 4 ^ x >> 5 ^ x >> 6 ^ x >> 7 ^ 99) & 255;
  }
  return box;
})();
var invSbox = sbox.map((_, j) => sbox.indexOf(j));
var rotr32_8 = (n) => n << 24 | n >>> 8;
var rotl32_8 = (n) => n << 8 | n >>> 24;
function genTtable(sbox2, fn) {
  if (sbox2.length !== 256)
    throw new Error("Wrong sbox length");
  const T0 = new Uint32Array(256).map((_, j) => fn(sbox2[j]));
  const T1 = T0.map(rotl32_8);
  const T2 = T1.map(rotl32_8);
  const T3 = T2.map(rotl32_8);
  const T01 = new Uint32Array(256 * 256);
  const T23 = new Uint32Array(256 * 256);
  const sbox22 = new Uint16Array(256 * 256);
  for (let i2 = 0; i2 < 256; i2++) {
    for (let j = 0; j < 256; j++) {
      const idx = i2 * 256 + j;
      T01[idx] = T0[i2] ^ T1[j];
      T23[idx] = T2[i2] ^ T3[j];
      sbox22[idx] = sbox2[i2] << 8 | sbox2[j];
    }
  }
  return { sbox: sbox2, sbox2: sbox22, T0, T1, T2, T3, T01, T23 };
}
var tableEncoding = genTtable(sbox, (s) => mul(s, 3) << 24 | s << 16 | s << 8 | mul(s, 2));
var tableDecoding = genTtable(invSbox, (s) => mul(s, 11) << 24 | mul(s, 13) << 16 | mul(s, 9) << 8 | mul(s, 14));
var xPowers = (() => {
  const p = new Uint8Array(16);
  for (let i2 = 0, x = 1; i2 < 16; i2++, x = mul22(x))
    p[i2] = x;
  return p;
})();
function expandKeyLE(key) {
  bytes3(key);
  const len = key.length;
  if (![16, 24, 32].includes(len))
    throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${len}`);
  const { sbox2 } = tableEncoding;
  const k32 = u32(key);
  const Nk = k32.length;
  const subByte = (n) => applySbox(sbox2, n, n, n, n);
  const xk = new Uint32Array(len + 28);
  xk.set(k32);
  for (let i2 = Nk; i2 < xk.length; i2++) {
    let t = xk[i2 - 1];
    if (i2 % Nk === 0)
      t = subByte(rotr32_8(t)) ^ xPowers[i2 / Nk - 1];
    else if (Nk > 6 && i2 % Nk === 4)
      t = subByte(t);
    xk[i2] = xk[i2 - Nk] ^ t;
  }
  return xk;
}
function expandKeyDecLE(key) {
  const encKey = expandKeyLE(key);
  const xk = encKey.slice();
  const Nk = encKey.length;
  const { sbox2 } = tableEncoding;
  const { T0, T1, T2, T3 } = tableDecoding;
  for (let i2 = 0; i2 < Nk; i2 += 4) {
    for (let j = 0; j < 4; j++)
      xk[i2 + j] = encKey[Nk - i2 - 4 + j];
  }
  encKey.fill(0);
  for (let i2 = 4; i2 < Nk - 4; i2++) {
    const x = xk[i2];
    const w = applySbox(sbox2, x, x, x, x);
    xk[i2] = T0[w & 255] ^ T1[w >>> 8 & 255] ^ T2[w >>> 16 & 255] ^ T3[w >>> 24];
  }
  return xk;
}
function apply0123(T01, T23, s0, s1, s2, s3) {
  return T01[s0 << 8 & 65280 | s1 >>> 8 & 255] ^ T23[s2 >>> 8 & 65280 | s3 >>> 24 & 255];
}
function applySbox(sbox2, s0, s1, s2, s3) {
  return sbox2[s0 & 255 | s1 & 65280] | sbox2[s2 >>> 16 & 255 | s3 >>> 16 & 65280] << 16;
}
function encrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableEncoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i2 = 0; i2 < rounds; i2++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s1, s2, s3);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s2, s3, s0);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s3, s0, s1);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s0, s1, s2);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s1, s2, s3);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s2, s3, s0);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s3, s0, s1);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s0, s1, s2);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function decrypt(xk, s0, s1, s2, s3) {
  const { sbox2, T01, T23 } = tableDecoding;
  let k = 0;
  s0 ^= xk[k++], s1 ^= xk[k++], s2 ^= xk[k++], s3 ^= xk[k++];
  const rounds = xk.length / 4 - 2;
  for (let i2 = 0; i2 < rounds; i2++) {
    const t02 = xk[k++] ^ apply0123(T01, T23, s0, s3, s2, s1);
    const t12 = xk[k++] ^ apply0123(T01, T23, s1, s0, s3, s2);
    const t22 = xk[k++] ^ apply0123(T01, T23, s2, s1, s0, s3);
    const t32 = xk[k++] ^ apply0123(T01, T23, s3, s2, s1, s0);
    s0 = t02, s1 = t12, s2 = t22, s3 = t32;
  }
  const t0 = xk[k++] ^ applySbox(sbox2, s0, s3, s2, s1);
  const t1 = xk[k++] ^ applySbox(sbox2, s1, s0, s3, s2);
  const t2 = xk[k++] ^ applySbox(sbox2, s2, s1, s0, s3);
  const t3 = xk[k++] ^ applySbox(sbox2, s3, s2, s1, s0);
  return { s0: t0, s1: t1, s2: t2, s3: t3 };
}
function getDst(len, dst) {
  if (!dst)
    return new Uint8Array(len);
  bytes3(dst);
  if (dst.length < len)
    throw new Error(`aes: wrong destination length, expected at least ${len}, got: ${dst.length}`);
  return dst;
}
function ctrCounter(xk, nonce, src, dst) {
  bytes3(nonce, BLOCK_SIZE2);
  bytes3(src);
  const srcLen = src.length;
  dst = getDst(srcLen, dst);
  const ctr3 = nonce;
  const c32 = u32(ctr3);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  const src32 = u32(src);
  const dst32 = u32(dst);
  for (let i2 = 0; i2 + 4 <= src32.length; i2 += 4) {
    dst32[i2 + 0] = src32[i2 + 0] ^ s0;
    dst32[i2 + 1] = src32[i2 + 1] ^ s1;
    dst32[i2 + 2] = src32[i2 + 2] ^ s2;
    dst32[i2 + 3] = src32[i2 + 3] ^ s3;
    let carry = 1;
    for (let i3 = ctr3.length - 1; i3 >= 0; i3--) {
      carry = carry + (ctr3[i3] & 255) | 0;
      ctr3[i3] = carry & 255;
      carry >>>= 8;
    }
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
      dst[i2] = src[i2] ^ buf[pos];
  }
  return dst;
}
function ctr32(xk, isLE5, nonce, src, dst) {
  bytes3(nonce, BLOCK_SIZE2);
  bytes3(src);
  dst = getDst(src.length, dst);
  const ctr3 = nonce;
  const c32 = u32(ctr3);
  const view = createView3(ctr3);
  const src32 = u32(src);
  const dst32 = u32(dst);
  const ctrPos = isLE5 ? 0 : 12;
  const srcLen = src.length;
  let ctrNum = view.getUint32(ctrPos, isLE5);
  let { s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]);
  for (let i2 = 0; i2 + 4 <= src32.length; i2 += 4) {
    dst32[i2 + 0] = src32[i2 + 0] ^ s0;
    dst32[i2 + 1] = src32[i2 + 1] ^ s1;
    dst32[i2 + 2] = src32[i2 + 2] ^ s2;
    dst32[i2 + 3] = src32[i2 + 3] ^ s3;
    ctrNum = ctrNum + 1 >>> 0;
    view.setUint32(ctrPos, ctrNum, isLE5);
    ({ s0, s1, s2, s3 } = encrypt(xk, c32[0], c32[1], c32[2], c32[3]));
  }
  const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
  if (start < srcLen) {
    const b32 = new Uint32Array([s0, s1, s2, s3]);
    const buf = u8(b32);
    for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
      dst[i2] = src[i2] ^ buf[pos];
  }
  return dst;
}
var ctr = wrapCipher({ blockSize: 16, nonceLength: 16 }, function ctr2(key, nonce) {
  bytes3(key);
  bytes3(nonce, BLOCK_SIZE2);
  function processCtr(buf, dst) {
    const xk = expandKeyLE(key);
    const n = nonce.slice();
    const out = ctrCounter(xk, n, buf, dst);
    xk.fill(0);
    n.fill(0);
    return out;
  }
  return {
    encrypt: (plaintext, dst) => processCtr(plaintext, dst),
    decrypt: (ciphertext, dst) => processCtr(ciphertext, dst)
  };
});
function validateBlockDecrypt(data) {
  bytes3(data);
  if (data.length % BLOCK_SIZE2 !== 0) {
    throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE2}`);
  }
}
function validateBlockEncrypt(plaintext, pcks5, dst) {
  let outLen = plaintext.length;
  const remaining = outLen % BLOCK_SIZE2;
  if (!pcks5 && remaining !== 0)
    throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");
  const b = u32(plaintext);
  if (pcks5) {
    let left = BLOCK_SIZE2 - remaining;
    if (!left)
      left = BLOCK_SIZE2;
    outLen = outLen + left;
  }
  const out = getDst(outLen, dst);
  const o = u32(out);
  return { b, o, out };
}
function validatePCKS(data, pcks5) {
  if (!pcks5)
    return data;
  const len = data.length;
  if (!len)
    throw new Error(`aes/pcks5: empty ciphertext not allowed`);
  const lastByte = data[len - 1];
  if (lastByte <= 0 || lastByte > 16)
    throw new Error(`aes/pcks5: wrong padding byte: ${lastByte}`);
  const out = data.subarray(0, -lastByte);
  for (let i2 = 0; i2 < lastByte; i2++)
    if (data[len - i2 - 1] !== lastByte)
      throw new Error(`aes/pcks5: wrong padding`);
  return out;
}
function padPCKS(left) {
  const tmp = new Uint8Array(16);
  const tmp32 = u32(tmp);
  tmp.set(left);
  const paddingByte = BLOCK_SIZE2 - left.length;
  for (let i2 = BLOCK_SIZE2 - paddingByte; i2 < BLOCK_SIZE2; i2++)
    tmp[i2] = paddingByte;
  return tmp32;
}
var ecb = wrapCipher({ blockSize: 16 }, function ecb2(key, opts = {}) {
  bytes3(key);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      bytes3(plaintext);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const xk = expandKeyLE(key);
      let i2 = 0;
      for (; i2 + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = encrypt(xk, b[i2 + 0], b[i2 + 1], b[i2 + 2], b[i2 + 3]);
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i2 * 4));
        const { s0, s1, s2, s3 } = encrypt(xk, tmp32[0], tmp32[1], tmp32[2], tmp32[3]);
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const out = getDst(ciphertext.length, dst);
      const b = u32(ciphertext);
      const o = u32(out);
      for (let i2 = 0; i2 + 4 <= b.length; ) {
        const { s0, s1, s2, s3 } = decrypt(xk, b[i2 + 0], b[i2 + 1], b[i2 + 2], b[i2 + 3]);
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cbc = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cbc2(key, iv, opts = {}) {
  bytes3(key);
  bytes3(iv, 16);
  const pcks5 = !opts.disablePadding;
  return {
    encrypt: (plaintext, dst) => {
      const xk = expandKeyLE(key);
      const { b, o, out: _out } = validateBlockEncrypt(plaintext, pcks5, dst);
      const n32 = u32(iv);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      let i2 = 0;
      for (; i2 + 4 <= b.length; ) {
        s0 ^= b[i2 + 0], s1 ^= b[i2 + 1], s2 ^= b[i2 + 2], s3 ^= b[i2 + 3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      if (pcks5) {
        const tmp32 = padPCKS(plaintext.subarray(i2 * 4));
        s0 ^= tmp32[0], s1 ^= tmp32[1], s2 ^= tmp32[2], s3 ^= tmp32[3];
        ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
        o[i2++] = s0, o[i2++] = s1, o[i2++] = s2, o[i2++] = s3;
      }
      xk.fill(0);
      return _out;
    },
    decrypt: (ciphertext, dst) => {
      validateBlockDecrypt(ciphertext);
      const xk = expandKeyDecLE(key);
      const n32 = u32(iv);
      const out = getDst(ciphertext.length, dst);
      const b = u32(ciphertext);
      const o = u32(out);
      let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
      for (let i2 = 0; i2 + 4 <= b.length; ) {
        const ps0 = s0, ps1 = s1, ps2 = s2, ps3 = s3;
        s0 = b[i2 + 0], s1 = b[i2 + 1], s2 = b[i2 + 2], s3 = b[i2 + 3];
        const { s0: o0, s1: o1, s2: o2, s3: o3 } = decrypt(xk, s0, s1, s2, s3);
        o[i2++] = o0 ^ ps0, o[i2++] = o1 ^ ps1, o[i2++] = o2 ^ ps2, o[i2++] = o3 ^ ps3;
      }
      xk.fill(0);
      return validatePCKS(out, pcks5);
    }
  };
});
var cfb = wrapCipher({ blockSize: 16, nonceLength: 16 }, function cfb2(key, iv) {
  bytes3(key);
  bytes3(iv, 16);
  function processCfb(src, isEncrypt, dst) {
    const xk = expandKeyLE(key);
    const srcLen = src.length;
    dst = getDst(srcLen, dst);
    const src32 = u32(src);
    const dst32 = u32(dst);
    const next32 = isEncrypt ? dst32 : src32;
    const n32 = u32(iv);
    let s0 = n32[0], s1 = n32[1], s2 = n32[2], s3 = n32[3];
    for (let i2 = 0; i2 + 4 <= src32.length; ) {
      const { s0: e0, s1: e1, s2: e2, s3: e3 } = encrypt(xk, s0, s1, s2, s3);
      dst32[i2 + 0] = src32[i2 + 0] ^ e0;
      dst32[i2 + 1] = src32[i2 + 1] ^ e1;
      dst32[i2 + 2] = src32[i2 + 2] ^ e2;
      dst32[i2 + 3] = src32[i2 + 3] ^ e3;
      s0 = next32[i2++], s1 = next32[i2++], s2 = next32[i2++], s3 = next32[i2++];
    }
    const start = BLOCK_SIZE2 * Math.floor(src32.length / BLOCK_SIZE32);
    if (start < srcLen) {
      ({ s0, s1, s2, s3 } = encrypt(xk, s0, s1, s2, s3));
      const buf = u8(new Uint32Array([s0, s1, s2, s3]));
      for (let i2 = start, pos = 0; i2 < srcLen; i2++, pos++)
        dst[i2] = src[i2] ^ buf[pos];
      buf.fill(0);
    }
    xk.fill(0);
    return dst;
  }
  return {
    encrypt: (plaintext, dst) => processCfb(plaintext, true, dst),
    decrypt: (ciphertext, dst) => processCfb(ciphertext, false, dst)
  };
});
function computeTag(fn, isLE5, key, data, AAD) {
  const h = fn.create(key, data.length + ((AAD == null ? void 0 : AAD.length) || 0));
  if (AAD)
    h.update(AAD);
  h.update(data);
  const num = new Uint8Array(16);
  const view = createView3(num);
  if (AAD)
    setBigUint643(view, 0, BigInt(AAD.length * 8), isLE5);
  setBigUint643(view, 8, BigInt(data.length * 8), isLE5);
  h.update(num);
  return h.digest();
}
var gcm = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function gcm2(key, nonce, AAD) {
  bytes3(nonce);
  if (nonce.length === 0)
    throw new Error("aes/gcm: empty nonce");
  const tagLength = 16;
  function _computeTag(authKey, tagMask, data) {
    const tag = computeTag(ghash, false, authKey, data, AAD);
    for (let i2 = 0; i2 < tagMask.length; i2++)
      tag[i2] ^= tagMask[i2];
    return tag;
  }
  function deriveKeys() {
    const xk = expandKeyLE(key);
    const authKey = EMPTY_BLOCK.slice();
    const counter = EMPTY_BLOCK.slice();
    ctr32(xk, false, counter, counter, authKey);
    if (nonce.length === 12) {
      counter.set(nonce);
    } else {
      const nonceLen = EMPTY_BLOCK.slice();
      const view = createView3(nonceLen);
      setBigUint643(view, 8, BigInt(nonce.length * 8), false);
      ghash.create(authKey).update(nonce).update(nonceLen).digestInto(counter);
    }
    const tagMask = ctr32(xk, false, counter, EMPTY_BLOCK);
    return { xk, authKey, counter, tagMask };
  }
  return {
    encrypt: (plaintext) => {
      bytes3(plaintext);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const out = new Uint8Array(plaintext.length + tagLength);
      ctr32(xk, false, counter, plaintext, out);
      const tag = _computeTag(authKey, tagMask, out.subarray(0, out.length - tagLength));
      out.set(tag, plaintext.length);
      xk.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes3(ciphertext);
      if (ciphertext.length < tagLength)
        throw new Error(`aes/gcm: ciphertext less than tagLen (${tagLength})`);
      const { xk, authKey, counter, tagMask } = deriveKeys();
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = _computeTag(authKey, tagMask, data);
      if (!equalBytes2(tag, passedTag))
        throw new Error("aes/gcm: invalid ghash tag");
      const out = ctr32(xk, false, counter, data);
      authKey.fill(0);
      tagMask.fill(0);
      xk.fill(0);
      return out;
    }
  };
});
var limit = (name, min2, max2) => (value) => {
  if (!Number.isSafeInteger(value) || min2 > value || value > max2)
    throw new Error(`${name}: invalid value=${value}, must be [${min2}..${max2}]`);
};
var siv = wrapCipher({ blockSize: 16, nonceLength: 12, tagLength: 16 }, function siv2(key, nonce, AAD) {
  const tagLength = 16;
  const AAD_LIMIT = limit("AAD", 0, 2 ** 36);
  const PLAIN_LIMIT = limit("plaintext", 0, 2 ** 36);
  const NONCE_LIMIT = limit("nonce", 12, 12);
  const CIPHER_LIMIT = limit("ciphertext", 16, 2 ** 36 + 16);
  bytes3(nonce);
  NONCE_LIMIT(nonce.length);
  if (AAD) {
    bytes3(AAD);
    AAD_LIMIT(AAD.length);
  }
  function deriveKeys() {
    const len = key.length;
    if (len !== 16 && len !== 24 && len !== 32)
      throw new Error(`key length must be 16, 24 or 32 bytes, got: ${len} bytes`);
    const xk = expandKeyLE(key);
    const encKey = new Uint8Array(len);
    const authKey = new Uint8Array(16);
    const n32 = u32(nonce);
    let s0 = 0, s1 = n32[0], s2 = n32[1], s3 = n32[2];
    let counter = 0;
    for (const derivedKey of [authKey, encKey].map(u32)) {
      const d32 = u32(derivedKey);
      for (let i2 = 0; i2 < d32.length; i2 += 2) {
        const { s0: o0, s1: o1 } = encrypt(xk, s0, s1, s2, s3);
        d32[i2 + 0] = o0;
        d32[i2 + 1] = o1;
        s0 = ++counter;
      }
    }
    xk.fill(0);
    return { authKey, encKey: expandKeyLE(encKey) };
  }
  function _computeTag(encKey, authKey, data) {
    const tag = computeTag(polyval, true, authKey, data, AAD);
    for (let i2 = 0; i2 < 12; i2++)
      tag[i2] ^= nonce[i2];
    tag[15] &= 127;
    const t32 = u32(tag);
    let s0 = t32[0], s1 = t32[1], s2 = t32[2], s3 = t32[3];
    ({ s0, s1, s2, s3 } = encrypt(encKey, s0, s1, s2, s3));
    t32[0] = s0, t32[1] = s1, t32[2] = s2, t32[3] = s3;
    return tag;
  }
  function processSiv(encKey, tag, input) {
    let block = tag.slice();
    block[15] |= 128;
    return ctr32(encKey, true, block, input);
  }
  return {
    encrypt: (plaintext) => {
      bytes3(plaintext);
      PLAIN_LIMIT(plaintext.length);
      const { encKey, authKey } = deriveKeys();
      const tag = _computeTag(encKey, authKey, plaintext);
      const out = new Uint8Array(plaintext.length + tagLength);
      out.set(tag, plaintext.length);
      out.set(processSiv(encKey, tag, plaintext));
      encKey.fill(0);
      authKey.fill(0);
      return out;
    },
    decrypt: (ciphertext) => {
      bytes3(ciphertext);
      CIPHER_LIMIT(ciphertext.length);
      const tag = ciphertext.subarray(-tagLength);
      const { encKey, authKey } = deriveKeys();
      const plaintext = processSiv(encKey, tag, ciphertext.subarray(0, -tagLength));
      const expectedTag = _computeTag(encKey, authKey, plaintext);
      encKey.fill(0);
      authKey.fill(0);
      if (!equalBytes2(tag, expectedTag))
        throw new Error("invalid polyval tag");
      return plaintext;
    }
  };
});

// node_modules/@noble/ciphers/esm/_poly1305.js
var u8to16 = (a, i2) => a[i2++] & 255 | (a[i2++] & 255) << 8;
var Poly1305 = class {
  constructor(key) {
    this.blockLen = 16;
    this.outputLen = 16;
    this.buffer = new Uint8Array(16);
    this.r = new Uint16Array(10);
    this.h = new Uint16Array(10);
    this.pad = new Uint16Array(8);
    this.pos = 0;
    this.finished = false;
    key = toBytes3(key);
    bytes3(key, 32);
    const t0 = u8to16(key, 0);
    const t1 = u8to16(key, 2);
    const t2 = u8to16(key, 4);
    const t3 = u8to16(key, 6);
    const t4 = u8to16(key, 8);
    const t5 = u8to16(key, 10);
    const t6 = u8to16(key, 12);
    const t7 = u8to16(key, 14);
    this.r[0] = t0 & 8191;
    this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
    this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
    this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
    this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
    this.r[5] = t4 >>> 1 & 8190;
    this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
    this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
    this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
    this.r[9] = t7 >>> 5 & 127;
    for (let i2 = 0; i2 < 8; i2++)
      this.pad[i2] = u8to16(key, 16 + 2 * i2);
  }
  process(data, offset, isLast = false) {
    const hibit = isLast ? 0 : 1 << 11;
    const { h, r } = this;
    const r0 = r[0];
    const r1 = r[1];
    const r2 = r[2];
    const r3 = r[3];
    const r4 = r[4];
    const r5 = r[5];
    const r6 = r[6];
    const r7 = r[7];
    const r8 = r[8];
    const r9 = r[9];
    const t0 = u8to16(data, offset + 0);
    const t1 = u8to16(data, offset + 2);
    const t2 = u8to16(data, offset + 4);
    const t3 = u8to16(data, offset + 6);
    const t4 = u8to16(data, offset + 8);
    const t5 = u8to16(data, offset + 10);
    const t6 = u8to16(data, offset + 12);
    const t7 = u8to16(data, offset + 14);
    let h0 = h[0] + (t0 & 8191);
    let h1 = h[1] + ((t0 >>> 13 | t1 << 3) & 8191);
    let h2 = h[2] + ((t1 >>> 10 | t2 << 6) & 8191);
    let h3 = h[3] + ((t2 >>> 7 | t3 << 9) & 8191);
    let h4 = h[4] + ((t3 >>> 4 | t4 << 12) & 8191);
    let h5 = h[5] + (t4 >>> 1 & 8191);
    let h6 = h[6] + ((t4 >>> 14 | t5 << 2) & 8191);
    let h7 = h[7] + ((t5 >>> 11 | t6 << 5) & 8191);
    let h8 = h[8] + ((t6 >>> 8 | t7 << 8) & 8191);
    let h9 = h[9] + (t7 >>> 5 | hibit);
    let c = 0;
    let d0 = c + h0 * r0 + h1 * (5 * r9) + h2 * (5 * r8) + h3 * (5 * r7) + h4 * (5 * r6);
    c = d0 >>> 13;
    d0 &= 8191;
    d0 += h5 * (5 * r5) + h6 * (5 * r4) + h7 * (5 * r3) + h8 * (5 * r2) + h9 * (5 * r1);
    c += d0 >>> 13;
    d0 &= 8191;
    let d1 = c + h0 * r1 + h1 * r0 + h2 * (5 * r9) + h3 * (5 * r8) + h4 * (5 * r7);
    c = d1 >>> 13;
    d1 &= 8191;
    d1 += h5 * (5 * r6) + h6 * (5 * r5) + h7 * (5 * r4) + h8 * (5 * r3) + h9 * (5 * r2);
    c += d1 >>> 13;
    d1 &= 8191;
    let d2 = c + h0 * r2 + h1 * r1 + h2 * r0 + h3 * (5 * r9) + h4 * (5 * r8);
    c = d2 >>> 13;
    d2 &= 8191;
    d2 += h5 * (5 * r7) + h6 * (5 * r6) + h7 * (5 * r5) + h8 * (5 * r4) + h9 * (5 * r3);
    c += d2 >>> 13;
    d2 &= 8191;
    let d3 = c + h0 * r3 + h1 * r2 + h2 * r1 + h3 * r0 + h4 * (5 * r9);
    c = d3 >>> 13;
    d3 &= 8191;
    d3 += h5 * (5 * r8) + h6 * (5 * r7) + h7 * (5 * r6) + h8 * (5 * r5) + h9 * (5 * r4);
    c += d3 >>> 13;
    d3 &= 8191;
    let d4 = c + h0 * r4 + h1 * r3 + h2 * r2 + h3 * r1 + h4 * r0;
    c = d4 >>> 13;
    d4 &= 8191;
    d4 += h5 * (5 * r9) + h6 * (5 * r8) + h7 * (5 * r7) + h8 * (5 * r6) + h9 * (5 * r5);
    c += d4 >>> 13;
    d4 &= 8191;
    let d5 = c + h0 * r5 + h1 * r4 + h2 * r3 + h3 * r2 + h4 * r1;
    c = d5 >>> 13;
    d5 &= 8191;
    d5 += h5 * r0 + h6 * (5 * r9) + h7 * (5 * r8) + h8 * (5 * r7) + h9 * (5 * r6);
    c += d5 >>> 13;
    d5 &= 8191;
    let d6 = c + h0 * r6 + h1 * r5 + h2 * r4 + h3 * r3 + h4 * r2;
    c = d6 >>> 13;
    d6 &= 8191;
    d6 += h5 * r1 + h6 * r0 + h7 * (5 * r9) + h8 * (5 * r8) + h9 * (5 * r7);
    c += d6 >>> 13;
    d6 &= 8191;
    let d7 = c + h0 * r7 + h1 * r6 + h2 * r5 + h3 * r4 + h4 * r3;
    c = d7 >>> 13;
    d7 &= 8191;
    d7 += h5 * r2 + h6 * r1 + h7 * r0 + h8 * (5 * r9) + h9 * (5 * r8);
    c += d7 >>> 13;
    d7 &= 8191;
    let d8 = c + h0 * r8 + h1 * r7 + h2 * r6 + h3 * r5 + h4 * r4;
    c = d8 >>> 13;
    d8 &= 8191;
    d8 += h5 * r3 + h6 * r2 + h7 * r1 + h8 * r0 + h9 * (5 * r9);
    c += d8 >>> 13;
    d8 &= 8191;
    let d9 = c + h0 * r9 + h1 * r8 + h2 * r7 + h3 * r6 + h4 * r5;
    c = d9 >>> 13;
    d9 &= 8191;
    d9 += h5 * r4 + h6 * r3 + h7 * r2 + h8 * r1 + h9 * r0;
    c += d9 >>> 13;
    d9 &= 8191;
    c = (c << 2) + c | 0;
    c = c + d0 | 0;
    d0 = c & 8191;
    c = c >>> 13;
    d1 += c;
    h[0] = d0;
    h[1] = d1;
    h[2] = d2;
    h[3] = d3;
    h[4] = d4;
    h[5] = d5;
    h[6] = d6;
    h[7] = d7;
    h[8] = d8;
    h[9] = d9;
  }
  finalize() {
    const { h, pad: pad2 } = this;
    const g = new Uint16Array(10);
    let c = h[1] >>> 13;
    h[1] &= 8191;
    for (let i2 = 2; i2 < 10; i2++) {
      h[i2] += c;
      c = h[i2] >>> 13;
      h[i2] &= 8191;
    }
    h[0] += c * 5;
    c = h[0] >>> 13;
    h[0] &= 8191;
    h[1] += c;
    c = h[1] >>> 13;
    h[1] &= 8191;
    h[2] += c;
    g[0] = h[0] + 5;
    c = g[0] >>> 13;
    g[0] &= 8191;
    for (let i2 = 1; i2 < 10; i2++) {
      g[i2] = h[i2] + c;
      c = g[i2] >>> 13;
      g[i2] &= 8191;
    }
    g[9] -= 1 << 13;
    let mask = (c ^ 1) - 1;
    for (let i2 = 0; i2 < 10; i2++)
      g[i2] &= mask;
    mask = ~mask;
    for (let i2 = 0; i2 < 10; i2++)
      h[i2] = h[i2] & mask | g[i2];
    h[0] = (h[0] | h[1] << 13) & 65535;
    h[1] = (h[1] >>> 3 | h[2] << 10) & 65535;
    h[2] = (h[2] >>> 6 | h[3] << 7) & 65535;
    h[3] = (h[3] >>> 9 | h[4] << 4) & 65535;
    h[4] = (h[4] >>> 12 | h[5] << 1 | h[6] << 14) & 65535;
    h[5] = (h[6] >>> 2 | h[7] << 11) & 65535;
    h[6] = (h[7] >>> 5 | h[8] << 8) & 65535;
    h[7] = (h[8] >>> 8 | h[9] << 5) & 65535;
    let f = h[0] + pad2[0];
    h[0] = f & 65535;
    for (let i2 = 1; i2 < 8; i2++) {
      f = (h[i2] + pad2[i2] | 0) + (f >>> 16) | 0;
      h[i2] = f & 65535;
    }
  }
  update(data) {
    exists3(this);
    const { buffer: buffer2, blockLen } = this;
    data = toBytes3(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take2 = Math.min(blockLen - this.pos, len - pos);
      if (take2 === blockLen) {
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(data, pos);
        continue;
      }
      buffer2.set(data.subarray(pos, pos + take2), this.pos);
      this.pos += take2;
      pos += take2;
      if (this.pos === blockLen) {
        this.process(buffer2, 0, false);
        this.pos = 0;
      }
    }
    return this;
  }
  destroy() {
    this.h.fill(0);
    this.r.fill(0);
    this.buffer.fill(0);
    this.pad.fill(0);
  }
  digestInto(out) {
    exists3(this);
    output3(out, this);
    this.finished = true;
    const { buffer: buffer2, h } = this;
    let { pos } = this;
    if (pos) {
      buffer2[pos++] = 1;
      for (; pos < 16; pos++)
        buffer2[pos] = 0;
      this.process(buffer2, 0, true);
    }
    this.finalize();
    let opos = 0;
    for (let i2 = 0; i2 < 8; i2++) {
      out[opos++] = h[i2] >>> 0;
      out[opos++] = h[i2] >>> 8;
    }
    return out;
  }
  digest() {
    const { buffer: buffer2, outputLen } = this;
    this.digestInto(buffer2);
    const res = buffer2.slice(0, outputLen);
    this.destroy();
    return res;
  }
};
function wrapConstructorWithKey2(hashCons) {
  const hashC = (msg, key) => hashCons(key).update(toBytes3(msg)).digest();
  const tmp = hashCons(new Uint8Array(32));
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (key) => hashCons(key);
  return hashC;
}
var poly1305 = wrapConstructorWithKey2((key) => new Poly1305(key));

// node_modules/@noble/ciphers/esm/_arx.js
var _utf8ToBytes = (str) => Uint8Array.from(str.split("").map((c) => c.charCodeAt(0)));
var sigma16 = _utf8ToBytes("expand 16-byte k");
var sigma32 = _utf8ToBytes("expand 32-byte k");
var sigma16_32 = u32(sigma16);
var sigma32_32 = u32(sigma32);
var sigma = sigma32_32.slice();
function rotl(a, b) {
  return a << b | a >>> 32 - b;
}
function isAligned32(b) {
  return b.byteOffset % 4 === 0;
}
var BLOCK_LEN = 64;
var BLOCK_LEN32 = 16;
var MAX_COUNTER = 2 ** 32 - 1;
var U32_EMPTY = new Uint32Array();
function runCipher(core, sigma2, key, nonce, data, output4, counter, rounds) {
  const len = data.length;
  const block = new Uint8Array(BLOCK_LEN);
  const b32 = u32(block);
  const isAligned = isAligned32(data) && isAligned32(output4);
  const d32 = isAligned ? u32(data) : U32_EMPTY;
  const o32 = isAligned ? u32(output4) : U32_EMPTY;
  for (let pos = 0; pos < len; counter++) {
    core(sigma2, key, nonce, b32, counter, rounds);
    if (counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    const take2 = Math.min(BLOCK_LEN, len - pos);
    if (isAligned && take2 === BLOCK_LEN) {
      const pos32 = pos / 4;
      if (pos % 4 !== 0)
        throw new Error("arx: invalid block position");
      for (let j = 0, posj; j < BLOCK_LEN32; j++) {
        posj = pos32 + j;
        o32[posj] = d32[posj] ^ b32[j];
      }
      pos += BLOCK_LEN;
      continue;
    }
    for (let j = 0, posj; j < take2; j++) {
      posj = pos + j;
      output4[posj] = data[posj] ^ block[j];
    }
    pos += take2;
  }
}
function createCipher(core, opts) {
  const { allowShortKeys, extendNonceFn, counterLength, counterRight, rounds } = checkOpts({ allowShortKeys: false, counterLength: 8, counterRight: false, rounds: 20 }, opts);
  if (typeof core !== "function")
    throw new Error("core must be a function");
  number3(counterLength);
  number3(rounds);
  bool2(counterRight);
  bool2(allowShortKeys);
  return (key, nonce, data, output4, counter = 0) => {
    bytes3(key);
    bytes3(nonce);
    bytes3(data);
    const len = data.length;
    if (!output4)
      output4 = new Uint8Array(len);
    bytes3(output4);
    number3(counter);
    if (counter < 0 || counter >= MAX_COUNTER)
      throw new Error("arx: counter overflow");
    if (output4.length < len)
      throw new Error(`arx: output (${output4.length}) is shorter than data (${len})`);
    const toClean = [];
    let l = key.length, k, sigma2;
    if (l === 32) {
      k = key.slice();
      toClean.push(k);
      sigma2 = sigma32_32;
    } else if (l === 16 && allowShortKeys) {
      k = new Uint8Array(32);
      k.set(key);
      k.set(key, 16);
      sigma2 = sigma16_32;
      toClean.push(k);
    } else {
      throw new Error(`arx: invalid 32-byte key, got length=${l}`);
    }
    if (!isAligned32(nonce)) {
      nonce = nonce.slice();
      toClean.push(nonce);
    }
    const k32 = u32(k);
    if (extendNonceFn) {
      if (nonce.length !== 24)
        throw new Error(`arx: extended nonce must be 24 bytes`);
      extendNonceFn(sigma2, k32, u32(nonce.subarray(0, 16)), k32);
      nonce = nonce.subarray(16);
    }
    const nonceNcLen = 16 - counterLength;
    if (nonceNcLen !== nonce.length)
      throw new Error(`arx: nonce must be ${nonceNcLen} or 16 bytes`);
    if (nonceNcLen !== 12) {
      const nc = new Uint8Array(12);
      nc.set(nonce, counterRight ? 0 : 12 - nonce.length);
      nonce = nc;
      toClean.push(nonce);
    }
    const n32 = u32(nonce);
    runCipher(core, sigma2, k32, n32, data, output4, counter, rounds);
    while (toClean.length > 0)
      toClean.pop().fill(0);
    return output4;
  };
}

// node_modules/@noble/ciphers/esm/chacha.js
function chachaCore(s, k, n, out, cnt, rounds = 20) {
  let y00 = s[0], y01 = s[1], y02 = s[2], y03 = s[3], y04 = k[0], y05 = k[1], y06 = k[2], y07 = k[3], y08 = k[4], y09 = k[5], y10 = k[6], y11 = k[7], y12 = cnt, y13 = n[0], y14 = n[1], y15 = n[2];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let r = 0; r < rounds; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function hchacha(s, k, i2, o32) {
  let x00 = s[0], x01 = s[1], x02 = s[2], x03 = s[3], x04 = k[0], x05 = k[1], x06 = k[2], x07 = k[3], x08 = k[4], x09 = k[5], x10 = k[6], x11 = k[7], x12 = i2[0], x13 = i2[1], x14 = i2[2], x15 = i2[3];
  for (let r = 0; r < 20; r += 2) {
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 16);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 12);
    x00 = x00 + x04 | 0;
    x12 = rotl(x12 ^ x00, 8);
    x08 = x08 + x12 | 0;
    x04 = rotl(x04 ^ x08, 7);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 16);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 12);
    x01 = x01 + x05 | 0;
    x13 = rotl(x13 ^ x01, 8);
    x09 = x09 + x13 | 0;
    x05 = rotl(x05 ^ x09, 7);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 16);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 12);
    x02 = x02 + x06 | 0;
    x14 = rotl(x14 ^ x02, 8);
    x10 = x10 + x14 | 0;
    x06 = rotl(x06 ^ x10, 7);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 16);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 12);
    x03 = x03 + x07 | 0;
    x15 = rotl(x15 ^ x03, 8);
    x11 = x11 + x15 | 0;
    x07 = rotl(x07 ^ x11, 7);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 16);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 12);
    x00 = x00 + x05 | 0;
    x15 = rotl(x15 ^ x00, 8);
    x10 = x10 + x15 | 0;
    x05 = rotl(x05 ^ x10, 7);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 16);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 12);
    x01 = x01 + x06 | 0;
    x12 = rotl(x12 ^ x01, 8);
    x11 = x11 + x12 | 0;
    x06 = rotl(x06 ^ x11, 7);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 16);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 12);
    x02 = x02 + x07 | 0;
    x13 = rotl(x13 ^ x02, 8);
    x08 = x08 + x13 | 0;
    x07 = rotl(x07 ^ x08, 7);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 16);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 12);
    x03 = x03 + x04 | 0;
    x14 = rotl(x14 ^ x03, 8);
    x09 = x09 + x14 | 0;
    x04 = rotl(x04 ^ x09, 7);
  }
  let oi = 0;
  o32[oi++] = x00;
  o32[oi++] = x01;
  o32[oi++] = x02;
  o32[oi++] = x03;
  o32[oi++] = x12;
  o32[oi++] = x13;
  o32[oi++] = x14;
  o32[oi++] = x15;
}
var chacha20orig = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  allowShortKeys: true
});
var chacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  allowShortKeys: false
});
var xchacha20 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 8,
  extendNonceFn: hchacha,
  allowShortKeys: false
});
var chacha8 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 8
});
var chacha12 = createCipher(chachaCore, {
  counterRight: false,
  counterLength: 4,
  rounds: 12
});
var ZEROS162 = new Uint8Array(16);
var updatePadded = (h, msg) => {
  h.update(msg);
  const left = msg.length % 16;
  if (left)
    h.update(ZEROS162.subarray(left));
};
var ZEROS322 = new Uint8Array(32);
function computeTag2(fn, key, nonce, data, AAD) {
  const authKey = fn(key, nonce, ZEROS322);
  const h = poly1305.create(authKey);
  if (AAD)
    updatePadded(h, AAD);
  updatePadded(h, data);
  const num = new Uint8Array(16);
  const view = createView3(num);
  setBigUint643(view, 0, BigInt(AAD ? AAD.length : 0), true);
  setBigUint643(view, 8, BigInt(data.length), true);
  h.update(num);
  const res = h.digest();
  authKey.fill(0);
  return res;
}
var _poly1305_aead = (xorStream) => (key, nonce, AAD) => {
  const tagLength = 16;
  bytes3(key, 32);
  bytes3(nonce);
  return {
    encrypt: (plaintext, output4) => {
      const plength = plaintext.length;
      const clength = plength + tagLength;
      if (output4) {
        bytes3(output4, clength);
      } else {
        output4 = new Uint8Array(clength);
      }
      xorStream(key, nonce, plaintext, output4, 1);
      const tag = computeTag2(xorStream, key, nonce, output4.subarray(0, -tagLength), AAD);
      output4.set(tag, plength);
      return output4;
    },
    decrypt: (ciphertext, output4) => {
      const clength = ciphertext.length;
      const plength = clength - tagLength;
      if (clength < tagLength)
        throw new Error(`encrypted data must be at least ${tagLength} bytes`);
      if (output4) {
        bytes3(output4, plength);
      } else {
        output4 = new Uint8Array(plength);
      }
      const data = ciphertext.subarray(0, -tagLength);
      const passedTag = ciphertext.subarray(-tagLength);
      const tag = computeTag2(xorStream, key, nonce, data, AAD);
      if (!equalBytes2(passedTag, tag))
        throw new Error("invalid tag");
      xorStream(key, nonce, data, output4, 1);
      return output4;
    }
  };
};
var chacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 12, tagLength: 16 }, _poly1305_aead(chacha20));
var xchacha20poly1305 = wrapCipher({ blockSize: 64, nonceLength: 24, tagLength: 16 }, _poly1305_aead(xchacha20));

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash2 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    assert_default.hash(hash3);
    const key = toBytes2(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash3.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    assert_default.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    assert_default.exists(this);
    assert_default.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);

// node_modules/nostr-tools/node_modules/@noble/hashes/esm/hkdf.js
function extract(hash3, ikm, salt) {
  assert_default.hash(hash3);
  if (salt === void 0)
    salt = new Uint8Array(hash3.outputLen);
  return hmac2(hash3, toBytes2(salt), toBytes2(ikm));
}
var HKDF_COUNTER = new Uint8Array([0]);
var EMPTY_BUFFER = new Uint8Array();
function expand(hash3, prk, info, length = 32) {
  assert_default.hash(hash3);
  assert_default.number(length);
  if (length > 255 * hash3.outputLen)
    throw new Error("Length should be <= 255*HashLen");
  const blocks = Math.ceil(length / hash3.outputLen);
  if (info === void 0)
    info = EMPTY_BUFFER;
  const okm = new Uint8Array(blocks * hash3.outputLen);
  const HMAC3 = hmac2.create(hash3, prk);
  const HMACTmp = HMAC3._cloneInto();
  const T = new Uint8Array(HMAC3.outputLen);
  for (let counter = 0; counter < blocks; counter++) {
    HKDF_COUNTER[0] = counter + 1;
    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);
    okm.set(T, hash3.outputLen * counter);
    HMAC3._cloneInto(HMACTmp);
  }
  HMAC3.destroy();
  HMACTmp.destroy();
  T.fill(0);
  HKDF_COUNTER.fill(0);
  return okm.slice(0, length);
}

// node_modules/nostr-tools/lib/esm/index.js
var __defProp = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var verifiedSymbol = Symbol("verified");
var isRecord = (obj) => obj instanceof Object;
function validateEvent(event) {
  if (!isRecord(event))
    return false;
  if (typeof event.kind !== "number")
    return false;
  if (typeof event.content !== "string")
    return false;
  if (typeof event.created_at !== "number")
    return false;
  if (typeof event.pubkey !== "string")
    return false;
  if (!event.pubkey.match(/^[a-f0-9]{64}$/))
    return false;
  if (!Array.isArray(event.tags))
    return false;
  for (let i2 = 0; i2 < event.tags.length; i2++) {
    let tag = event.tags[i2];
    if (!Array.isArray(tag))
      return false;
    for (let j = 0; j < tag.length; j++) {
      if (typeof tag[j] !== "string")
        return false;
    }
  }
  return true;
}
var utils_exports2 = {};
__export2(utils_exports2, {
  Queue: () => Queue,
  QueueNode: () => QueueNode,
  binarySearch: () => binarySearch,
  bytesToHex: () => bytesToHex2,
  hexToBytes: () => hexToBytes2,
  insertEventIntoAscendingList: () => insertEventIntoAscendingList,
  insertEventIntoDescendingList: () => insertEventIntoDescendingList,
  normalizeURL: () => normalizeURL,
  utf8Decoder: () => utf8Decoder,
  utf8Encoder: () => utf8Encoder
});
var utf8Decoder = new TextDecoder("utf-8");
var utf8Encoder = new TextEncoder();
function normalizeURL(url) {
  try {
    if (url.indexOf("://") === -1)
      url = "wss://" + url;
    let p = new URL(url);
    p.pathname = p.pathname.replace(/\/+/g, "/");
    if (p.pathname.endsWith("/"))
      p.pathname = p.pathname.slice(0, -1);
    if (p.port === "80" && p.protocol === "ws:" || p.port === "443" && p.protocol === "wss:")
      p.port = "";
    p.searchParams.sort();
    p.hash = "";
    return p.toString();
  } catch (e) {
    throw new Error(`Invalid URL: ${url}`);
  }
}
function insertEventIntoDescendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b) => {
    if (event.id === b.id)
      return 0;
    if (event.created_at === b.created_at)
      return -1;
    return b.created_at - event.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function insertEventIntoAscendingList(sortedArray, event) {
  const [idx, found] = binarySearch(sortedArray, (b) => {
    if (event.id === b.id)
      return 0;
    if (event.created_at === b.created_at)
      return -1;
    return event.created_at - b.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function binarySearch(arr, compare) {
  let start = 0;
  let end = arr.length - 1;
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    const cmp = compare(arr[mid]);
    if (cmp === 0) {
      return [mid, true];
    }
    if (cmp < 0) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return [start, false];
}
var QueueNode = class {
  constructor(message) {
    __publicField(this, "value");
    __publicField(this, "next", null);
    __publicField(this, "prev", null);
    this.value = message;
  }
};
var Queue = class {
  constructor() {
    __publicField(this, "first");
    __publicField(this, "last");
    this.first = null;
    this.last = null;
  }
  enqueue(value) {
    const newNode = new QueueNode(value);
    if (!this.last) {
      this.first = newNode;
      this.last = newNode;
    } else if (this.last === this.first) {
      this.last = newNode;
      this.last.prev = this.first;
      this.first.next = newNode;
    } else {
      newNode.prev = this.last;
      this.last.next = newNode;
      this.last = newNode;
    }
    return true;
  }
  dequeue() {
    if (!this.first)
      return null;
    if (this.first === this.last) {
      const target2 = this.first;
      this.first = null;
      this.last = null;
      return target2.value;
    }
    const target = this.first;
    this.first = target.next;
    if (this.first) {
      this.first.prev = null;
    }
    return target.value;
  }
};
var JS = class {
  generateSecretKey() {
    return schnorr.utils.randomPrivateKey();
  }
  getPublicKey(secretKey) {
    return bytesToHex2(schnorr.getPublicKey(secretKey));
  }
  finalizeEvent(t, secretKey) {
    const event = t;
    event.pubkey = bytesToHex2(schnorr.getPublicKey(secretKey));
    event.id = getEventHash(event);
    event.sig = bytesToHex2(schnorr.sign(getEventHash(event), secretKey));
    event[verifiedSymbol] = true;
    return event;
  }
  verifyEvent(event) {
    if (typeof event[verifiedSymbol] === "boolean")
      return event[verifiedSymbol];
    const hash3 = getEventHash(event);
    if (hash3 !== event.id) {
      event[verifiedSymbol] = false;
      return false;
    }
    try {
      const valid = schnorr.verify(event.sig, hash3, event.pubkey);
      event[verifiedSymbol] = valid;
      return valid;
    } catch (err) {
      event[verifiedSymbol] = false;
      return false;
    }
  }
};
function serializeEvent(evt) {
  if (!validateEvent(evt))
    throw new Error("can't serialize event with wrong or missing properties");
  return JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content]);
}
function getEventHash(event) {
  let eventHash = sha2562(utf8Encoder.encode(serializeEvent(event)));
  return bytesToHex2(eventHash);
}
var i = new JS();
var generateSecretKey = i.generateSecretKey;
var getPublicKey = i.getPublicKey;
var finalizeEvent = i.finalizeEvent;
var verifyEvent = i.verifyEvent;
var kinds_exports = {};
__export2(kinds_exports, {
  Application: () => Application,
  BadgeAward: () => BadgeAward,
  BadgeDefinition: () => BadgeDefinition,
  BlockedRelaysList: () => BlockedRelaysList,
  BookmarkList: () => BookmarkList,
  Bookmarksets: () => Bookmarksets,
  Calendar: () => Calendar,
  CalendarEventRSVP: () => CalendarEventRSVP,
  ChannelCreation: () => ChannelCreation,
  ChannelHideMessage: () => ChannelHideMessage,
  ChannelMessage: () => ChannelMessage,
  ChannelMetadata: () => ChannelMetadata,
  ChannelMuteUser: () => ChannelMuteUser,
  ClassifiedListing: () => ClassifiedListing,
  ClientAuth: () => ClientAuth,
  CommunitiesList: () => CommunitiesList,
  CommunityDefinition: () => CommunityDefinition,
  CommunityPostApproval: () => CommunityPostApproval,
  Contacts: () => Contacts,
  CreateOrUpdateProduct: () => CreateOrUpdateProduct,
  CreateOrUpdateStall: () => CreateOrUpdateStall,
  Curationsets: () => Curationsets,
  Date: () => Date2,
  DirectMessageRelaysList: () => DirectMessageRelaysList,
  DraftClassifiedListing: () => DraftClassifiedListing,
  DraftLong: () => DraftLong,
  Emojisets: () => Emojisets,
  EncryptedDirectMessage: () => EncryptedDirectMessage,
  EventDeletion: () => EventDeletion,
  FileMetadata: () => FileMetadata,
  FileServerPreference: () => FileServerPreference,
  Followsets: () => Followsets,
  GenericRepost: () => GenericRepost,
  Genericlists: () => Genericlists,
  GiftWrap: () => GiftWrap,
  HTTPAuth: () => HTTPAuth,
  Handlerinformation: () => Handlerinformation,
  Handlerrecommendation: () => Handlerrecommendation,
  Highlights: () => Highlights,
  InterestsList: () => InterestsList,
  Interestsets: () => Interestsets,
  JobFeedback: () => JobFeedback,
  JobRequest: () => JobRequest,
  JobResult: () => JobResult,
  Label: () => Label,
  LightningPubRPC: () => LightningPubRPC,
  LiveChatMessage: () => LiveChatMessage,
  LiveEvent: () => LiveEvent,
  LongFormArticle: () => LongFormArticle,
  Metadata: () => Metadata,
  Mutelist: () => Mutelist,
  NWCWalletInfo: () => NWCWalletInfo,
  NWCWalletRequest: () => NWCWalletRequest,
  NWCWalletResponse: () => NWCWalletResponse,
  NostrConnect: () => NostrConnect,
  OpenTimestamps: () => OpenTimestamps,
  Pinlist: () => Pinlist,
  PrivateDirectMessage: () => PrivateDirectMessage,
  ProblemTracker: () => ProblemTracker,
  ProfileBadges: () => ProfileBadges,
  PublicChatsList: () => PublicChatsList,
  Reaction: () => Reaction,
  RecommendRelay: () => RecommendRelay,
  RelayList: () => RelayList,
  Relaysets: () => Relaysets,
  Report: () => Report,
  Reporting: () => Reporting,
  Repost: () => Repost,
  Seal: () => Seal,
  SearchRelaysList: () => SearchRelaysList,
  ShortTextNote: () => ShortTextNote,
  Time: () => Time,
  UserEmojiList: () => UserEmojiList,
  UserStatuses: () => UserStatuses,
  Zap: () => Zap,
  ZapGoal: () => ZapGoal,
  ZapRequest: () => ZapRequest,
  classifyKind: () => classifyKind,
  isAddressableKind: () => isAddressableKind,
  isEphemeralKind: () => isEphemeralKind,
  isKind: () => isKind,
  isRegularKind: () => isRegularKind,
  isReplaceableKind: () => isReplaceableKind
});
function isRegularKind(kind) {
  return 1e3 <= kind && kind < 1e4 || [1, 2, 4, 5, 6, 7, 8, 16, 40, 41, 42, 43, 44].includes(kind);
}
function isReplaceableKind(kind) {
  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
}
function isEphemeralKind(kind) {
  return 2e4 <= kind && kind < 3e4;
}
function isAddressableKind(kind) {
  return 3e4 <= kind && kind < 4e4;
}
function classifyKind(kind) {
  if (isRegularKind(kind))
    return "regular";
  if (isReplaceableKind(kind))
    return "replaceable";
  if (isEphemeralKind(kind))
    return "ephemeral";
  if (isAddressableKind(kind))
    return "parameterized";
  return "unknown";
}
function isKind(event, kind) {
  const kindAsArray = kind instanceof Array ? kind : [kind];
  return validateEvent(event) && kindAsArray.includes(event.kind) || false;
}
var Metadata = 0;
var ShortTextNote = 1;
var RecommendRelay = 2;
var Contacts = 3;
var EncryptedDirectMessage = 4;
var EventDeletion = 5;
var Repost = 6;
var Reaction = 7;
var BadgeAward = 8;
var Seal = 13;
var PrivateDirectMessage = 14;
var GenericRepost = 16;
var ChannelCreation = 40;
var ChannelMetadata = 41;
var ChannelMessage = 42;
var ChannelHideMessage = 43;
var ChannelMuteUser = 44;
var OpenTimestamps = 1040;
var GiftWrap = 1059;
var FileMetadata = 1063;
var LiveChatMessage = 1311;
var ProblemTracker = 1971;
var Report = 1984;
var Reporting = 1984;
var Label = 1985;
var CommunityPostApproval = 4550;
var JobRequest = 5999;
var JobResult = 6999;
var JobFeedback = 7e3;
var ZapGoal = 9041;
var ZapRequest = 9734;
var Zap = 9735;
var Highlights = 9802;
var Mutelist = 1e4;
var Pinlist = 10001;
var RelayList = 10002;
var BookmarkList = 10003;
var CommunitiesList = 10004;
var PublicChatsList = 10005;
var BlockedRelaysList = 10006;
var SearchRelaysList = 10007;
var InterestsList = 10015;
var UserEmojiList = 10030;
var DirectMessageRelaysList = 10050;
var FileServerPreference = 10096;
var NWCWalletInfo = 13194;
var LightningPubRPC = 21e3;
var ClientAuth = 22242;
var NWCWalletRequest = 23194;
var NWCWalletResponse = 23195;
var NostrConnect = 24133;
var HTTPAuth = 27235;
var Followsets = 3e4;
var Genericlists = 30001;
var Relaysets = 30002;
var Bookmarksets = 30003;
var Curationsets = 30004;
var ProfileBadges = 30008;
var BadgeDefinition = 30009;
var Interestsets = 30015;
var CreateOrUpdateStall = 30017;
var CreateOrUpdateProduct = 30018;
var LongFormArticle = 30023;
var DraftLong = 30024;
var Emojisets = 30030;
var Application = 30078;
var LiveEvent = 30311;
var UserStatuses = 30315;
var ClassifiedListing = 30402;
var DraftClassifiedListing = 30403;
var Date2 = 31922;
var Time = 31923;
var Calendar = 31924;
var CalendarEventRSVP = 31925;
var Handlerrecommendation = 31989;
var Handlerinformation = 31990;
var CommunityDefinition = 34550;
var fakejson_exports = {};
__export2(fakejson_exports, {
  getHex64: () => getHex64,
  getInt: () => getInt,
  getSubscriptionId: () => getSubscriptionId,
  matchEventId: () => matchEventId,
  matchEventKind: () => matchEventKind,
  matchEventPubkey: () => matchEventPubkey
});
function getHex64(json, field) {
  let len = field.length + 3;
  let idx = json.indexOf(`"${field}":`) + len;
  let s = json.slice(idx).indexOf(`"`) + idx + 1;
  return json.slice(s, s + 64);
}
function getInt(json, field) {
  let len = field.length;
  let idx = json.indexOf(`"${field}":`) + len + 3;
  let sliced = json.slice(idx);
  let end = Math.min(sliced.indexOf(","), sliced.indexOf("}"));
  return parseInt(sliced.slice(0, end), 10);
}
function getSubscriptionId(json) {
  let idx = json.slice(0, 22).indexOf(`"EVENT"`);
  if (idx === -1)
    return null;
  let pstart = json.slice(idx + 7 + 1).indexOf(`"`);
  if (pstart === -1)
    return null;
  let start = idx + 7 + 1 + pstart;
  let pend = json.slice(start + 1, 80).indexOf(`"`);
  if (pend === -1)
    return null;
  let end = start + 1 + pend;
  return json.slice(start + 1, end);
}
function matchEventId(json, id) {
  return id === getHex64(json, "id");
}
function matchEventPubkey(json, pubkey) {
  return pubkey === getHex64(json, "pubkey");
}
function matchEventKind(json, kind) {
  return kind === getInt(json, "kind");
}
var nip42_exports = {};
__export2(nip42_exports, {
  makeAuthEvent: () => makeAuthEvent
});
function makeAuthEvent(relayURL, challenge2) {
  return {
    kind: ClientAuth,
    created_at: Math.floor(Date.now() / 1e3),
    tags: [
      ["relay", relayURL],
      ["challenge", challenge2]
    ],
    content: ""
  };
}
var _WebSocket;
try {
  _WebSocket = WebSocket;
} catch {
}
var _WebSocket2;
try {
  _WebSocket2 = WebSocket;
} catch {
}
var nip19_exports = {};
__export2(nip19_exports, {
  BECH32_REGEX: () => BECH32_REGEX,
  Bech32MaxSize: () => Bech32MaxSize,
  NostrTypeGuard: () => NostrTypeGuard,
  decode: () => decode,
  decodeNostrURI: () => decodeNostrURI,
  encodeBytes: () => encodeBytes,
  naddrEncode: () => naddrEncode,
  neventEncode: () => neventEncode,
  noteEncode: () => noteEncode,
  nprofileEncode: () => nprofileEncode,
  npubEncode: () => npubEncode,
  nsecEncode: () => nsecEncode
});
var NostrTypeGuard = {
  isNProfile: (value) => /^nprofile1[a-z\d]+$/.test(value || ""),
  isNEvent: (value) => /^nevent1[a-z\d]+$/.test(value || ""),
  isNAddr: (value) => /^naddr1[a-z\d]+$/.test(value || ""),
  isNSec: (value) => /^nsec1[a-z\d]{58}$/.test(value || ""),
  isNPub: (value) => /^npub1[a-z\d]{58}$/.test(value || ""),
  isNote: (value) => /^note1[a-z\d]+$/.test(value || ""),
  isNcryptsec: (value) => /^ncryptsec1[a-z\d]+$/.test(value || "")
};
var Bech32MaxSize = 5e3;
var BECH32_REGEX = /[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;
function integerToUint8Array(number4) {
  const uint8Array = new Uint8Array(4);
  uint8Array[0] = number4 >> 24 & 255;
  uint8Array[1] = number4 >> 16 & 255;
  uint8Array[2] = number4 >> 8 & 255;
  uint8Array[3] = number4 & 255;
  return uint8Array;
}
function decodeNostrURI(nip19code) {
  try {
    if (nip19code.startsWith("nostr:"))
      nip19code = nip19code.substring(6);
    return decode(nip19code);
  } catch (_err) {
    return { type: "invalid", data: null };
  }
}
function decode(code) {
  var _a, _b, _c, _d, _e, _f, _g;
  let { prefix, words } = bech32.decode(code, Bech32MaxSize);
  let data = new Uint8Array(bech32.fromWords(words));
  switch (prefix) {
    case "nprofile": {
      let tlv = parseTLV(data);
      if (!((_a = tlv[0]) == null ? void 0 : _a[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nevent": {
      let tlv = parseTLV(data);
      if (!((_b = tlv[0]) == null ? void 0 : _b[0]))
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (tlv[2] && tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (tlv[3] && tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : [],
          author: ((_c = tlv[2]) == null ? void 0 : _c[0]) ? bytesToHex2(tlv[2][0]) : void 0,
          kind: ((_d = tlv[3]) == null ? void 0 : _d[0]) ? parseInt(bytesToHex2(tlv[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let tlv = parseTLV(data);
      if (!((_e = tlv[0]) == null ? void 0 : _e[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((_f = tlv[2]) == null ? void 0 : _f[0]))
        throw new Error("missing TLV 2 for naddr");
      if (tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_g = tlv[3]) == null ? void 0 : _g[0]))
        throw new Error("missing TLV 3 for naddr");
      if (tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder.decode(tlv[0][0]),
          pubkey: bytesToHex2(tlv[2][0]),
          kind: parseInt(bytesToHex2(tlv[3][0]), 16),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder.decode(d)) : []
        }
      };
    }
    case "nsec":
      return { type: prefix, data };
    case "npub":
    case "note":
      return { type: prefix, data: bytesToHex2(data) };
    default:
      throw new Error(`unknown prefix ${prefix}`);
  }
}
function parseTLV(data) {
  let result = {};
  let rest = data;
  while (rest.length > 0) {
    let t = rest[0];
    let l = rest[1];
    let v = rest.slice(2, 2 + l);
    rest = rest.slice(2 + l);
    if (v.length < l)
      throw new Error(`not enough data to read on TLV ${t}`);
    result[t] = result[t] || [];
    result[t].push(v);
  }
  return result;
}
function nsecEncode(key) {
  return encodeBytes("nsec", key);
}
function npubEncode(hex3) {
  return encodeBytes("npub", hexToBytes2(hex3));
}
function noteEncode(hex3) {
  return encodeBytes("note", hexToBytes2(hex3));
}
function encodeBech32(prefix, data) {
  let words = bech32.toWords(data);
  return bech32.encode(prefix, words, Bech32MaxSize);
}
function encodeBytes(prefix, bytes4) {
  return encodeBech32(prefix, bytes4);
}
function nprofileEncode(profile) {
  let data = encodeTLV({
    0: [hexToBytes2(profile.pubkey)],
    1: (profile.relays || []).map((url) => utf8Encoder.encode(url))
  });
  return encodeBech32("nprofile", data);
}
function neventEncode(event) {
  let kindArray;
  if (event.kind !== void 0) {
    kindArray = integerToUint8Array(event.kind);
  }
  let data = encodeTLV({
    0: [hexToBytes2(event.id)],
    1: (event.relays || []).map((url) => utf8Encoder.encode(url)),
    2: event.author ? [hexToBytes2(event.author)] : [],
    3: kindArray ? [new Uint8Array(kindArray)] : []
  });
  return encodeBech32("nevent", data);
}
function naddrEncode(addr) {
  let kind = new ArrayBuffer(4);
  new DataView(kind).setUint32(0, addr.kind, false);
  let data = encodeTLV({
    0: [utf8Encoder.encode(addr.identifier)],
    1: (addr.relays || []).map((url) => utf8Encoder.encode(url)),
    2: [hexToBytes2(addr.pubkey)],
    3: [new Uint8Array(kind)]
  });
  return encodeBech32("naddr", data);
}
function encodeTLV(tlv) {
  let entries = [];
  Object.entries(tlv).reverse().forEach(([t, vs]) => {
    vs.forEach((v) => {
      let entry = new Uint8Array(v.length + 2);
      entry.set([parseInt(t)], 0);
      entry.set([v.length], 1);
      entry.set(v, 2);
      entries.push(entry);
    });
  });
  return concatBytes3(...entries);
}
var nip04_exports = {};
__export2(nip04_exports, {
  decrypt: () => decrypt2,
  encrypt: () => encrypt2
});
function encrypt2(secretKey, pubkey, text) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex2(secretKey) : secretKey;
  const key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
  const normalizedKey = getNormalizedX(key);
  let iv = Uint8Array.from(randomBytes2(16));
  let plaintext = utf8Encoder.encode(text);
  let ciphertext = cbc(normalizedKey, iv).encrypt(plaintext);
  let ctb64 = base64.encode(new Uint8Array(ciphertext));
  let ivb64 = base64.encode(new Uint8Array(iv.buffer));
  return `${ctb64}?iv=${ivb64}`;
}
function decrypt2(secretKey, pubkey, data) {
  const privkey = secretKey instanceof Uint8Array ? bytesToHex2(secretKey) : secretKey;
  let [ctb64, ivb64] = data.split("?iv=");
  let key = secp256k1.getSharedSecret(privkey, "02" + pubkey);
  let normalizedKey = getNormalizedX(key);
  let iv = base64.decode(ivb64);
  let ciphertext = base64.decode(ctb64);
  let plaintext = cbc(normalizedKey, iv).decrypt(ciphertext);
  return utf8Decoder.decode(plaintext);
}
function getNormalizedX(key) {
  return key.slice(1, 33);
}
var nip05_exports = {};
__export2(nip05_exports, {
  NIP05_REGEX: () => NIP05_REGEX,
  isNip05: () => isNip05,
  isValid: () => isValid,
  queryProfile: () => queryProfile,
  searchDomain: () => searchDomain,
  useFetchImplementation: () => useFetchImplementation
});
var NIP05_REGEX = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/;
var isNip05 = (value) => NIP05_REGEX.test(value || "");
var _fetch;
try {
  _fetch = fetch;
} catch (_) {
  null;
}
function useFetchImplementation(fetchImplementation) {
  _fetch = fetchImplementation;
}
async function searchDomain(domain, query = "") {
  try {
    const url = `https://${domain}/.well-known/nostr.json?name=${query}`;
    const res = await _fetch(url, { redirect: "manual" });
    if (res.status !== 200) {
      throw Error("Wrong response code");
    }
    const json = await res.json();
    return json.names;
  } catch (_) {
    return {};
  }
}
async function queryProfile(fullname) {
  var _a;
  const match = fullname.match(NIP05_REGEX);
  if (!match)
    return null;
  const [, name = "_", domain] = match;
  try {
    const url = `https://${domain}/.well-known/nostr.json?name=${name}`;
    const res = await _fetch(url, { redirect: "manual" });
    if (res.status !== 200) {
      throw Error("Wrong response code");
    }
    const json = await res.json();
    const pubkey = json.names[name];
    return pubkey ? { pubkey, relays: (_a = json.relays) == null ? void 0 : _a[pubkey] } : null;
  } catch (_e) {
    return null;
  }
}
async function isValid(pubkey, nip05) {
  const res = await queryProfile(nip05);
  return res ? res.pubkey === pubkey : false;
}
var nip10_exports = {};
__export2(nip10_exports, {
  parse: () => parse
});
function parse(event) {
  const result = {
    reply: void 0,
    root: void 0,
    mentions: [],
    profiles: [],
    quotes: []
  };
  let maybeParent;
  let maybeRoot;
  for (let i2 = event.tags.length - 1; i2 >= 0; i2--) {
    const tag = event.tags[i2];
    if (tag[0] === "e" && tag[1]) {
      const [_, eTagEventId, eTagRelayUrl, eTagMarker, eTagAuthor] = tag;
      const eventPointer = {
        id: eTagEventId,
        relays: eTagRelayUrl ? [eTagRelayUrl] : [],
        author: eTagAuthor
      };
      if (eTagMarker === "root") {
        result.root = eventPointer;
        continue;
      }
      if (eTagMarker === "reply") {
        result.reply = eventPointer;
        continue;
      }
      if (eTagMarker === "mention") {
        result.mentions.push(eventPointer);
        continue;
      }
      if (!maybeParent) {
        maybeParent = eventPointer;
      } else {
        maybeRoot = eventPointer;
      }
      result.mentions.push(eventPointer);
      continue;
    }
    if (tag[0] === "q" && tag[1]) {
      const [_, eTagEventId, eTagRelayUrl] = tag;
      result.quotes.push({
        id: eTagEventId,
        relays: eTagRelayUrl ? [eTagRelayUrl] : []
      });
    }
    if (tag[0] === "p" && tag[1]) {
      result.profiles.push({
        pubkey: tag[1],
        relays: tag[2] ? [tag[2]] : []
      });
      continue;
    }
  }
  if (!result.root) {
    result.root = maybeRoot || maybeParent || result.reply;
  }
  if (!result.reply) {
    result.reply = maybeParent || result.root;
  }
  ;
  [result.reply, result.root].forEach((ref) => {
    if (!ref)
      return;
    let idx = result.mentions.indexOf(ref);
    if (idx !== -1) {
      result.mentions.splice(idx, 1);
    }
    if (ref.author) {
      let author = result.profiles.find((p) => p.pubkey === ref.author);
      if (author && author.relays) {
        if (!ref.relays) {
          ref.relays = [];
        }
        author.relays.forEach((url) => {
          var _a;
          if (((_a = ref.relays) == null ? void 0 : _a.indexOf(url)) === -1)
            ref.relays.push(url);
        });
        author.relays = ref.relays;
      }
    }
  });
  result.mentions.forEach((ref) => {
    if (ref.author) {
      let author = result.profiles.find((p) => p.pubkey === ref.author);
      if (author && author.relays) {
        if (!ref.relays) {
          ref.relays = [];
        }
        author.relays.forEach((url) => {
          if (ref.relays.indexOf(url) === -1)
            ref.relays.push(url);
        });
        author.relays = ref.relays;
      }
    }
  });
  return result;
}
var nip11_exports = {};
__export2(nip11_exports, {
  fetchRelayInformation: () => fetchRelayInformation,
  useFetchImplementation: () => useFetchImplementation2
});
var _fetch2;
try {
  _fetch2 = fetch;
} catch {
}
function useFetchImplementation2(fetchImplementation) {
  _fetch2 = fetchImplementation;
}
async function fetchRelayInformation(url) {
  return await (await fetch(url.replace("ws://", "http://").replace("wss://", "https://"), {
    headers: { Accept: "application/nostr+json" }
  })).json();
}
var nip13_exports = {};
__export2(nip13_exports, {
  fastEventHash: () => fastEventHash,
  getPow: () => getPow,
  minePow: () => minePow
});
function getPow(hex3) {
  let count2 = 0;
  for (let i2 = 0; i2 < 64; i2 += 8) {
    const nibble = parseInt(hex3.substring(i2, i2 + 8), 16);
    if (nibble === 0) {
      count2 += 32;
    } else {
      count2 += Math.clz32(nibble);
      break;
    }
  }
  return count2;
}
function minePow(unsigned, difficulty) {
  let count2 = 0;
  const event = unsigned;
  const tag = ["nonce", count2.toString(), difficulty.toString()];
  event.tags.push(tag);
  while (true) {
    const now2 = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
    if (now2 !== event.created_at) {
      count2 = 0;
      event.created_at = now2;
    }
    tag[1] = (++count2).toString();
    event.id = fastEventHash(event);
    if (getPow(event.id) >= difficulty) {
      break;
    }
  }
  return event;
}
function fastEventHash(evt) {
  return bytesToHex2(
    sha2562(utf8Encoder.encode(JSON.stringify([0, evt.pubkey, evt.created_at, evt.kind, evt.tags, evt.content])))
  );
}
var nip17_exports = {};
__export2(nip17_exports, {
  unwrapEvent: () => unwrapEvent2,
  unwrapManyEvents: () => unwrapManyEvents2,
  wrapEvent: () => wrapEvent2,
  wrapManyEvents: () => wrapManyEvents2
});
var nip59_exports = {};
__export2(nip59_exports, {
  createRumor: () => createRumor,
  createSeal: () => createSeal,
  createWrap: () => createWrap,
  unwrapEvent: () => unwrapEvent,
  unwrapManyEvents: () => unwrapManyEvents,
  wrapEvent: () => wrapEvent,
  wrapManyEvents: () => wrapManyEvents
});
var nip44_exports = {};
__export2(nip44_exports, {
  decrypt: () => decrypt22,
  encrypt: () => encrypt22,
  getConversationKey: () => getConversationKey,
  v2: () => v2
});
var minPlaintextSize = 1;
var maxPlaintextSize = 65535;
function getConversationKey(privkeyA, pubkeyB) {
  const sharedX = secp256k1.getSharedSecret(privkeyA, "02" + pubkeyB).subarray(1, 33);
  return extract(sha2562, sharedX, "nip44-v2");
}
function getMessageKeys(conversationKey, nonce) {
  const keys = expand(sha2562, conversationKey, nonce, 76);
  return {
    chacha_key: keys.subarray(0, 32),
    chacha_nonce: keys.subarray(32, 44),
    hmac_key: keys.subarray(44, 76)
  };
}
function calcPaddedLen(len) {
  if (!Number.isSafeInteger(len) || len < 1)
    throw new Error("expected positive integer");
  if (len <= 32)
    return 32;
  const nextPower = 1 << Math.floor(Math.log2(len - 1)) + 1;
  const chunk = nextPower <= 256 ? 32 : nextPower / 8;
  return chunk * (Math.floor((len - 1) / chunk) + 1);
}
function writeU16BE(num) {
  if (!Number.isSafeInteger(num) || num < minPlaintextSize || num > maxPlaintextSize)
    throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");
  const arr = new Uint8Array(2);
  new DataView(arr.buffer).setUint16(0, num, false);
  return arr;
}
function pad(plaintext) {
  const unpadded = utf8Encoder.encode(plaintext);
  const unpaddedLen = unpadded.length;
  const prefix = writeU16BE(unpaddedLen);
  const suffix = new Uint8Array(calcPaddedLen(unpaddedLen) - unpaddedLen);
  return concatBytes3(prefix, unpadded, suffix);
}
function unpad(padded) {
  const unpaddedLen = new DataView(padded.buffer).getUint16(0);
  const unpadded = padded.subarray(2, 2 + unpaddedLen);
  if (unpaddedLen < minPlaintextSize || unpaddedLen > maxPlaintextSize || unpadded.length !== unpaddedLen || padded.length !== 2 + calcPaddedLen(unpaddedLen))
    throw new Error("invalid padding");
  return utf8Decoder.decode(unpadded);
}
function hmacAad(key, message, aad) {
  if (aad.length !== 32)
    throw new Error("AAD associated data must be 32 bytes");
  const combined = concatBytes3(aad, message);
  return hmac2(sha2562, key, combined);
}
function decodePayload(payload) {
  if (typeof payload !== "string")
    throw new Error("payload must be a valid string");
  const plen = payload.length;
  if (plen < 132 || plen > 87472)
    throw new Error("invalid payload length: " + plen);
  if (payload[0] === "#")
    throw new Error("unknown encryption version");
  let data;
  try {
    data = base64.decode(payload);
  } catch (error) {
    throw new Error("invalid base64: " + error.message);
  }
  const dlen = data.length;
  if (dlen < 99 || dlen > 65603)
    throw new Error("invalid data length: " + dlen);
  const vers = data[0];
  if (vers !== 2)
    throw new Error("unknown encryption version " + vers);
  return {
    nonce: data.subarray(1, 33),
    ciphertext: data.subarray(33, -32),
    mac: data.subarray(-32)
  };
}
function encrypt22(plaintext, conversationKey, nonce = randomBytes2(32)) {
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
  const padded = pad(plaintext);
  const ciphertext = chacha20(chacha_key, chacha_nonce, padded);
  const mac = hmacAad(hmac_key, ciphertext, nonce);
  return base64.encode(concatBytes3(new Uint8Array([2]), nonce, ciphertext, mac));
}
function decrypt22(payload, conversationKey) {
  const { nonce, ciphertext, mac } = decodePayload(payload);
  const { chacha_key, chacha_nonce, hmac_key } = getMessageKeys(conversationKey, nonce);
  const calculatedMac = hmacAad(hmac_key, ciphertext, nonce);
  if (!equalBytes2(calculatedMac, mac))
    throw new Error("invalid MAC");
  const padded = chacha20(chacha_key, chacha_nonce, ciphertext);
  return unpad(padded);
}
var v2 = {
  utils: {
    getConversationKey,
    calcPaddedLen
  },
  encrypt: encrypt22,
  decrypt: decrypt22
};
var TWO_DAYS = 2 * 24 * 60 * 60;
var now = () => Math.round(Date.now() / 1e3);
var randomNow = () => Math.round(now() - Math.random() * TWO_DAYS);
var nip44ConversationKey = (privateKey, publicKey) => getConversationKey(privateKey, publicKey);
var nip44Encrypt = (data, privateKey, publicKey) => encrypt22(JSON.stringify(data), nip44ConversationKey(privateKey, publicKey));
var nip44Decrypt = (data, privateKey) => JSON.parse(decrypt22(data.content, nip44ConversationKey(privateKey, data.pubkey)));
function createRumor(event, privateKey) {
  const rumor = {
    created_at: now(),
    content: "",
    tags: [],
    ...event,
    pubkey: getPublicKey(privateKey)
  };
  rumor.id = getEventHash(rumor);
  return rumor;
}
function createSeal(rumor, privateKey, recipientPublicKey) {
  return finalizeEvent(
    {
      kind: Seal,
      content: nip44Encrypt(rumor, privateKey, recipientPublicKey),
      created_at: randomNow(),
      tags: []
    },
    privateKey
  );
}
function createWrap(seal, recipientPublicKey) {
  const randomKey = generateSecretKey();
  return finalizeEvent(
    {
      kind: GiftWrap,
      content: nip44Encrypt(seal, randomKey, recipientPublicKey),
      created_at: randomNow(),
      tags: [["p", recipientPublicKey]]
    },
    randomKey
  );
}
function wrapEvent(event, senderPrivateKey, recipientPublicKey) {
  const rumor = createRumor(event, senderPrivateKey);
  const seal = createSeal(rumor, senderPrivateKey, recipientPublicKey);
  return createWrap(seal, recipientPublicKey);
}
function wrapManyEvents(event, senderPrivateKey, recipientsPublicKeys) {
  if (!recipientsPublicKeys || recipientsPublicKeys.length === 0) {
    throw new Error("At least one recipient is required.");
  }
  const senderPublicKey = getPublicKey(senderPrivateKey);
  const wrappeds = [wrapEvent(event, senderPrivateKey, senderPublicKey)];
  recipientsPublicKeys.forEach((recipientPublicKey) => {
    wrappeds.push(wrapEvent(event, senderPrivateKey, recipientPublicKey));
  });
  return wrappeds;
}
function unwrapEvent(wrap, recipientPrivateKey) {
  const unwrappedSeal = nip44Decrypt(wrap, recipientPrivateKey);
  return nip44Decrypt(unwrappedSeal, recipientPrivateKey);
}
function unwrapManyEvents(wrappedEvents, recipientPrivateKey) {
  let unwrappedEvents = [];
  wrappedEvents.forEach((e) => {
    unwrappedEvents.push(unwrapEvent(e, recipientPrivateKey));
  });
  unwrappedEvents.sort((a, b) => a.created_at - b.created_at);
  return unwrappedEvents;
}
function createEvent(recipients, message, conversationTitle, replyTo) {
  const baseEvent = {
    created_at: Math.ceil(Date.now() / 1e3),
    kind: PrivateDirectMessage,
    tags: [],
    content: message
  };
  const recipientsArray = Array.isArray(recipients) ? recipients : [recipients];
  recipientsArray.forEach(({ publicKey, relayUrl }) => {
    baseEvent.tags.push(relayUrl ? ["p", publicKey, relayUrl] : ["p", publicKey]);
  });
  if (replyTo) {
    baseEvent.tags.push(["e", replyTo.eventId, replyTo.relayUrl || "", "reply"]);
  }
  if (conversationTitle) {
    baseEvent.tags.push(["subject", conversationTitle]);
  }
  return baseEvent;
}
function wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo) {
  const event = createEvent(recipient, message, conversationTitle, replyTo);
  return wrapEvent(event, senderPrivateKey, recipient.publicKey);
}
function wrapManyEvents2(senderPrivateKey, recipients, message, conversationTitle, replyTo) {
  if (!recipients || recipients.length === 0) {
    throw new Error("At least one recipient is required.");
  }
  const senderPublicKey = getPublicKey(senderPrivateKey);
  return [{ publicKey: senderPublicKey }, ...recipients].map(
    (recipient) => wrapEvent2(senderPrivateKey, recipient, message, conversationTitle, replyTo)
  );
}
var unwrapEvent2 = unwrapEvent;
var unwrapManyEvents2 = unwrapManyEvents;
var nip18_exports = {};
__export2(nip18_exports, {
  finishRepostEvent: () => finishRepostEvent,
  getRepostedEvent: () => getRepostedEvent,
  getRepostedEventPointer: () => getRepostedEventPointer
});
function finishRepostEvent(t, reposted, relayUrl, privateKey) {
  var _a;
  let kind;
  const tags = [...t.tags ?? [], ["e", reposted.id, relayUrl], ["p", reposted.pubkey]];
  if (reposted.kind === ShortTextNote) {
    kind = Repost;
  } else {
    kind = GenericRepost;
    tags.push(["k", String(reposted.kind)]);
  }
  return finalizeEvent(
    {
      kind,
      tags,
      content: t.content === "" || ((_a = reposted.tags) == null ? void 0 : _a.find((tag) => tag[0] === "-")) ? "" : JSON.stringify(reposted),
      created_at: t.created_at
    },
    privateKey
  );
}
function getRepostedEventPointer(event) {
  if (![Repost, GenericRepost].includes(event.kind)) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
    const tag = event.tags[i2];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag == null ? void 0 : lastPTag[2]].filter((x) => typeof x === "string"),
    author: lastPTag == null ? void 0 : lastPTag[1]
  };
}
function getRepostedEvent(event, { skipVerification } = {}) {
  const pointer = getRepostedEventPointer(event);
  if (pointer === void 0 || event.content === "") {
    return void 0;
  }
  let repostedEvent;
  try {
    repostedEvent = JSON.parse(event.content);
  } catch (error) {
    return void 0;
  }
  if (repostedEvent.id !== pointer.id) {
    return void 0;
  }
  if (!skipVerification && !verifyEvent(repostedEvent)) {
    return void 0;
  }
  return repostedEvent;
}
var nip21_exports = {};
__export2(nip21_exports, {
  NOSTR_URI_REGEX: () => NOSTR_URI_REGEX,
  parse: () => parse2,
  test: () => test
});
var NOSTR_URI_REGEX = new RegExp(`nostr:(${BECH32_REGEX.source})`);
function test(value) {
  return typeof value === "string" && new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(value);
}
function parse2(uri) {
  const match = uri.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));
  if (!match)
    throw new Error(`Invalid Nostr URI: ${uri}`);
  return {
    uri: match[0],
    value: match[1],
    decoded: decode(match[1])
  };
}
var nip25_exports = {};
__export2(nip25_exports, {
  finishReactionEvent: () => finishReactionEvent,
  getReactedEventPointer: () => getReactedEventPointer
});
function finishReactionEvent(t, reacted, privateKey) {
  const inheritedTags = reacted.tags.filter((tag) => tag.length >= 2 && (tag[0] === "e" || tag[0] === "p"));
  return finalizeEvent(
    {
      ...t,
      kind: Reaction,
      tags: [...t.tags ?? [], ...inheritedTags, ["e", reacted.id], ["p", reacted.pubkey]],
      content: t.content ?? "+"
    },
    privateKey
  );
}
function getReactedEventPointer(event) {
  if (event.kind !== Reaction) {
    return void 0;
  }
  let lastETag;
  let lastPTag;
  for (let i2 = event.tags.length - 1; i2 >= 0 && (lastETag === void 0 || lastPTag === void 0); i2--) {
    const tag = event.tags[i2];
    if (tag.length >= 2) {
      if (tag[0] === "e" && lastETag === void 0) {
        lastETag = tag;
      } else if (tag[0] === "p" && lastPTag === void 0) {
        lastPTag = tag;
      }
    }
  }
  if (lastETag === void 0 || lastPTag === void 0) {
    return void 0;
  }
  return {
    id: lastETag[1],
    relays: [lastETag[2], lastPTag[2]].filter((x) => x !== void 0),
    author: lastPTag[1]
  };
}
var nip27_exports = {};
__export2(nip27_exports, {
  parse: () => parse3
});
var noCharacter = /\W/m;
var noURLCharacter = /\W |\W$|$|,| /m;
function* parse3(content) {
  const max2 = content.length;
  let prevIndex = 0;
  let index = 0;
  while (index < max2) {
    let u = content.indexOf(":", index);
    if (u === -1) {
      break;
    }
    if (content.substring(u - 5, u) === "nostr") {
      const m = content.substring(u + 60).match(noCharacter);
      const end = m ? u + 60 + m.index : max2;
      try {
        let pointer;
        let { data, type } = decode(content.substring(u + 1, end));
        switch (type) {
          case "npub":
            pointer = { pubkey: data };
            break;
          case "nsec":
          case "note":
            index = end + 1;
            continue;
          default:
            pointer = data;
        }
        if (prevIndex !== u - 5) {
          yield { type: "text", text: content.substring(prevIndex, u - 5) };
        }
        yield { type: "reference", pointer };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = u + 1;
        continue;
      }
    } else if (content.substring(u - 5, u) === "https" || content.substring(u - 4, u) === "http") {
      const m = content.substring(u + 4).match(noURLCharacter);
      const end = m ? u + 4 + m.index : max2;
      const prefixLen = content[u - 1] === "s" ? 5 : 4;
      try {
        let url = new URL(content.substring(u - prefixLen, end));
        if (url.hostname.indexOf(".") === -1) {
          throw new Error("invalid url");
        }
        if (prevIndex !== u - prefixLen) {
          yield { type: "text", text: content.substring(prevIndex, u - prefixLen) };
        }
        if (url.pathname.endsWith(".png") || url.pathname.endsWith(".jpg") || url.pathname.endsWith(".jpeg") || url.pathname.endsWith(".gif") || url.pathname.endsWith(".webp")) {
          yield { type: "image", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        if (url.pathname.endsWith(".mp4") || url.pathname.endsWith(".avi") || url.pathname.endsWith(".webm") || url.pathname.endsWith(".mkv")) {
          yield { type: "video", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        if (url.pathname.endsWith(".mp3") || url.pathname.endsWith(".aac") || url.pathname.endsWith(".ogg") || url.pathname.endsWith(".opus")) {
          yield { type: "audio", url: url.toString() };
          index = end;
          prevIndex = index;
          continue;
        }
        yield { type: "url", url: url.toString() };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = end + 1;
        continue;
      }
    } else if (content.substring(u - 3, u) === "wss" || content.substring(u - 2, u) === "ws") {
      const m = content.substring(u + 4).match(noURLCharacter);
      const end = m ? u + 4 + m.index : max2;
      const prefixLen = content[u - 1] === "s" ? 3 : 2;
      try {
        let url = new URL(content.substring(u - prefixLen, end));
        if (url.hostname.indexOf(".") === -1) {
          throw new Error("invalid ws url");
        }
        if (prevIndex !== u - prefixLen) {
          yield { type: "text", text: content.substring(prevIndex, u - prefixLen) };
        }
        yield { type: "relay", url: url.toString() };
        index = end;
        prevIndex = index;
        continue;
      } catch (_err) {
        index = end + 1;
        continue;
      }
    } else {
      index = u + 1;
      continue;
    }
  }
  if (prevIndex !== max2) {
    yield { type: "text", text: content.substring(prevIndex) };
  }
}
var nip28_exports = {};
__export2(nip28_exports, {
  channelCreateEvent: () => channelCreateEvent,
  channelHideMessageEvent: () => channelHideMessageEvent,
  channelMessageEvent: () => channelMessageEvent,
  channelMetadataEvent: () => channelMetadataEvent,
  channelMuteUserEvent: () => channelMuteUserEvent
});
var channelCreateEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelCreation,
      tags: [...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMetadataEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMetadata,
      tags: [["e", t.channel_create_event_id], ...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMessageEvent = (t, privateKey) => {
  const tags = [["e", t.channel_create_event_id, t.relay_url, "root"]];
  if (t.reply_to_channel_message_event_id) {
    tags.push(["e", t.reply_to_channel_message_event_id, t.relay_url, "reply"]);
  }
  return finalizeEvent(
    {
      kind: ChannelMessage,
      tags: [...tags, ...t.tags ?? []],
      content: t.content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelHideMessageEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelHideMessage,
      tags: [["e", t.channel_message_event_id], ...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var channelMuteUserEvent = (t, privateKey) => {
  let content;
  if (typeof t.content === "object") {
    content = JSON.stringify(t.content);
  } else if (typeof t.content === "string") {
    content = t.content;
  } else {
    return void 0;
  }
  return finalizeEvent(
    {
      kind: ChannelMuteUser,
      tags: [["p", t.pubkey_to_mute], ...t.tags ?? []],
      content,
      created_at: t.created_at
    },
    privateKey
  );
};
var nip30_exports = {};
__export2(nip30_exports, {
  EMOJI_SHORTCODE_REGEX: () => EMOJI_SHORTCODE_REGEX,
  matchAll: () => matchAll,
  regex: () => regex,
  replaceAll: () => replaceAll
});
var EMOJI_SHORTCODE_REGEX = /:(\w+):/;
var regex = () => new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`, "g");
function* matchAll(content) {
  const matches = content.matchAll(regex());
  for (const match of matches) {
    try {
      const [shortcode, name] = match;
      yield {
        shortcode,
        name,
        start: match.index,
        end: match.index + shortcode.length
      };
    } catch (_e) {
    }
  }
}
function replaceAll(content, replacer) {
  return content.replaceAll(regex(), (shortcode, name) => {
    return replacer({
      shortcode,
      name
    });
  });
}
var nip39_exports = {};
__export2(nip39_exports, {
  useFetchImplementation: () => useFetchImplementation3,
  validateGithub: () => validateGithub
});
var _fetch3;
try {
  _fetch3 = fetch;
} catch {
}
function useFetchImplementation3(fetchImplementation) {
  _fetch3 = fetchImplementation;
}
async function validateGithub(pubkey, username, proof) {
  try {
    let res = await (await _fetch3(`https://gist.github.com/${username}/${proof}/raw`)).text();
    return res === `Verifying that I control the following Nostr public key: ${pubkey}`;
  } catch (_) {
    return false;
  }
}
var nip47_exports = {};
__export2(nip47_exports, {
  makeNwcRequestEvent: () => makeNwcRequestEvent,
  parseConnectionString: () => parseConnectionString
});
function parseConnectionString(connectionString) {
  const { host, pathname, searchParams } = new URL(connectionString);
  const pubkey = pathname || host;
  const relay = searchParams.get("relay");
  const secret = searchParams.get("secret");
  if (!pubkey || !relay || !secret) {
    throw new Error("invalid connection string");
  }
  return { pubkey, relay, secret };
}
async function makeNwcRequestEvent(pubkey, secretKey, invoice) {
  const content = {
    method: "pay_invoice",
    params: {
      invoice
    }
  };
  const encryptedContent = encrypt2(secretKey, pubkey, JSON.stringify(content));
  const eventTemplate = {
    kind: NWCWalletRequest,
    created_at: Math.round(Date.now() / 1e3),
    content: encryptedContent,
    tags: [["p", pubkey]]
  };
  return finalizeEvent(eventTemplate, secretKey);
}
var nip54_exports = {};
__export2(nip54_exports, {
  normalizeIdentifier: () => normalizeIdentifier
});
function normalizeIdentifier(name) {
  name = name.trim().toLowerCase();
  name = name.normalize("NFKC");
  return Array.from(name).map((char) => {
    if (new RegExp("\\p{Letter}", "u").test(char) || new RegExp("\\p{Number}", "u").test(char)) {
      return char;
    }
    return "-";
  }).join("");
}
var nip57_exports = {};
__export2(nip57_exports, {
  getSatoshisAmountFromBolt11: () => getSatoshisAmountFromBolt11,
  getZapEndpoint: () => getZapEndpoint,
  makeZapReceipt: () => makeZapReceipt,
  makeZapRequest: () => makeZapRequest,
  useFetchImplementation: () => useFetchImplementation4,
  validateZapRequest: () => validateZapRequest
});
var _fetch4;
try {
  _fetch4 = fetch;
} catch {
}
function useFetchImplementation4(fetchImplementation) {
  _fetch4 = fetchImplementation;
}
async function getZapEndpoint(metadata) {
  try {
    let lnurl = "";
    let { lud06, lud16 } = JSON.parse(metadata.content);
    if (lud06) {
      let { words } = bech32.decode(lud06, 1e3);
      let data = bech32.fromWords(words);
      lnurl = utf8Decoder.decode(data);
    } else if (lud16) {
      let [name, domain] = lud16.split("@");
      lnurl = new URL(`/.well-known/lnurlp/${name}`, `https://${domain}`).toString();
    } else {
      return null;
    }
    let res = await _fetch4(lnurl);
    let body = await res.json();
    if (body.allowsNostr && body.nostrPubkey) {
      return body.callback;
    }
  } catch (err) {
  }
  return null;
}
function makeZapRequest({
  profile,
  event,
  amount,
  relays,
  comment = ""
}) {
  if (!amount)
    throw new Error("amount not given");
  if (!profile)
    throw new Error("profile not given");
  let zr = {
    kind: 9734,
    created_at: Math.round(Date.now() / 1e3),
    content: comment,
    tags: [
      ["p", profile],
      ["amount", amount.toString()],
      ["relays", ...relays]
    ]
  };
  if (event && typeof event === "string") {
    zr.tags.push(["e", event]);
  }
  if (event && typeof event === "object") {
    if (isReplaceableKind(event.kind)) {
      const a = ["a", `${event.kind}:${event.pubkey}:`];
      zr.tags.push(a);
    } else if (isAddressableKind(event.kind)) {
      let d = event.tags.find(([t, v]) => t === "d" && v);
      if (!d)
        throw new Error("d tag not found or is empty");
      const a = ["a", `${event.kind}:${event.pubkey}:${d[1]}`];
      zr.tags.push(a);
    }
  }
  return zr;
}
function validateZapRequest(zapRequestString) {
  let zapRequest;
  try {
    zapRequest = JSON.parse(zapRequestString);
  } catch (err) {
    return "Invalid zap request JSON.";
  }
  if (!validateEvent(zapRequest))
    return "Zap request is not a valid Nostr event.";
  if (!verifyEvent(zapRequest))
    return "Invalid signature on zap request.";
  let p = zapRequest.tags.find(([t, v]) => t === "p" && v);
  if (!p)
    return "Zap request doesn't have a 'p' tag.";
  if (!p[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'p' tag is not valid hex.";
  let e = zapRequest.tags.find(([t, v]) => t === "e" && v);
  if (e && !e[1].match(/^[a-f0-9]{64}$/))
    return "Zap request 'e' tag is not valid hex.";
  let relays = zapRequest.tags.find(([t, v]) => t === "relays" && v);
  if (!relays)
    return "Zap request doesn't have a 'relays' tag.";
  return null;
}
function makeZapReceipt({
  zapRequest,
  preimage,
  bolt11,
  paidAt
}) {
  let zr = JSON.parse(zapRequest);
  let tagsFromZapRequest = zr.tags.filter(([t]) => t === "e" || t === "p" || t === "a");
  let zap = {
    kind: 9735,
    created_at: Math.round(paidAt.getTime() / 1e3),
    content: "",
    tags: [...tagsFromZapRequest, ["P", zr.pubkey], ["bolt11", bolt11], ["description", zapRequest]]
  };
  if (preimage) {
    zap.tags.push(["preimage", preimage]);
  }
  return zap;
}
function getSatoshisAmountFromBolt11(bolt11) {
  if (bolt11.length < 50) {
    return 0;
  }
  bolt11 = bolt11.substring(0, 50);
  const idx = bolt11.lastIndexOf("1");
  if (idx === -1) {
    return 0;
  }
  const hrp = bolt11.substring(0, idx);
  if (!hrp.startsWith("lnbc")) {
    return 0;
  }
  const amount = hrp.substring(4);
  if (amount.length < 1) {
    return 0;
  }
  const char = amount[amount.length - 1];
  const digit = char.charCodeAt(0) - "0".charCodeAt(0);
  const isDigit = digit >= 0 && digit <= 9;
  let cutPoint = amount.length - 1;
  if (isDigit) {
    cutPoint++;
  }
  if (cutPoint < 1) {
    return 0;
  }
  const num = parseInt(amount.substring(0, cutPoint));
  switch (char) {
    case "m":
      return num * 1e5;
    case "u":
      return num * 100;
    case "n":
      return num / 10;
    case "p":
      return num / 1e4;
    default:
      return num * 1e8;
  }
}
var nip98_exports = {};
__export2(nip98_exports, {
  getToken: () => getToken,
  hashPayload: () => hashPayload,
  unpackEventFromToken: () => unpackEventFromToken,
  validateEvent: () => validateEvent2,
  validateEventKind: () => validateEventKind,
  validateEventMethodTag: () => validateEventMethodTag,
  validateEventPayloadTag: () => validateEventPayloadTag,
  validateEventTimestamp: () => validateEventTimestamp,
  validateEventUrlTag: () => validateEventUrlTag,
  validateToken: () => validateToken
});
var _authorizationScheme = "Nostr ";
async function getToken(loginUrl, httpMethod, sign, includeAuthorizationScheme = false, payload) {
  const event = {
    kind: HTTPAuth,
    tags: [
      ["u", loginUrl],
      ["method", httpMethod]
    ],
    created_at: Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3),
    content: ""
  };
  if (payload) {
    event.tags.push(["payload", hashPayload(payload)]);
  }
  const signedEvent = await sign(event);
  const authorizationScheme = includeAuthorizationScheme ? _authorizationScheme : "";
  return authorizationScheme + base64.encode(utf8Encoder.encode(JSON.stringify(signedEvent)));
}
async function validateToken(token, url, method) {
  const event = await unpackEventFromToken(token).catch((error) => {
    throw error;
  });
  const valid = await validateEvent2(event, url, method).catch((error) => {
    throw error;
  });
  return valid;
}
async function unpackEventFromToken(token) {
  if (!token) {
    throw new Error("Missing token");
  }
  token = token.replace(_authorizationScheme, "");
  const eventB64 = utf8Decoder.decode(base64.decode(token));
  if (!eventB64 || eventB64.length === 0 || !eventB64.startsWith("{")) {
    throw new Error("Invalid token");
  }
  const event = JSON.parse(eventB64);
  return event;
}
function validateEventTimestamp(event) {
  if (!event.created_at) {
    return false;
  }
  return Math.round((/* @__PURE__ */ new Date()).getTime() / 1e3) - event.created_at < 60;
}
function validateEventKind(event) {
  return event.kind === HTTPAuth;
}
function validateEventUrlTag(event, url) {
  const urlTag = event.tags.find((t) => t[0] === "u");
  if (!urlTag) {
    return false;
  }
  return urlTag.length > 0 && urlTag[1] === url;
}
function validateEventMethodTag(event, method) {
  const methodTag = event.tags.find((t) => t[0] === "method");
  if (!methodTag) {
    return false;
  }
  return methodTag.length > 0 && methodTag[1].toLowerCase() === method.toLowerCase();
}
function hashPayload(payload) {
  const hash3 = sha2562(utf8Encoder.encode(JSON.stringify(payload)));
  return bytesToHex2(hash3);
}
function validateEventPayloadTag(event, payload) {
  const payloadTag = event.tags.find((t) => t[0] === "payload");
  if (!payloadTag) {
    return false;
  }
  const payloadHash = hashPayload(payload);
  return payloadTag.length > 0 && payloadTag[1] === payloadHash;
}
async function validateEvent2(event, url, method, body) {
  if (!verifyEvent(event)) {
    throw new Error("Invalid nostr event, signature invalid");
  }
  if (!validateEventKind(event)) {
    throw new Error("Invalid nostr event, kind invalid");
  }
  if (!validateEventTimestamp(event)) {
    throw new Error("Invalid nostr event, created_at timestamp invalid");
  }
  if (!validateEventUrlTag(event, url)) {
    throw new Error("Invalid nostr event, url tag invalid");
  }
  if (!validateEventMethodTag(event, method)) {
    throw new Error("Invalid nostr event, method tag invalid");
  }
  if (Boolean(body) && typeof body === "object" && Object.keys(body).length > 0) {
    if (!validateEventPayloadTag(event, body)) {
      throw new Error("Invalid nostr event, payload tag does not match request body hash");
    }
  }
  return true;
}

// node_modules/nostr-tools/lib/esm/kinds.js
var verifiedSymbol2 = Symbol("verified");
function isReplaceableKind2(kind) {
  return [0, 3].includes(kind) || 1e4 <= kind && kind < 2e4;
}
function isAddressableKind2(kind) {
  return 3e4 <= kind && kind < 4e4;
}

// node_modules/tslib/tslib.es6.mjs
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i2 = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i2 >= o.length) o = void 0;
      return { value: o && o[i2++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i2 = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i2.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i2["return"])) m.call(i2);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l = from2.length, ar; i2 < l; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i2, q = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i2[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i2[n] = f(i2[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i2;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n) {
    i2[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject);
  }
}

// node_modules/rxjs/dist/esm5/internal/util/isFunction.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
function createErrorClass(createImpl) {
  var _super = function(instance) {
    Error.call(instance);
    instance.stack = new Error().stack;
  };
  var ctorFunc = createImpl(_super);
  ctorFunc.prototype = Object.create(Error.prototype);
  ctorFunc.prototype.constructor = ctorFunc;
  return ctorFunc;
}

// node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
var UnsubscriptionError = createErrorClass(function(_super) {
  return function UnsubscriptionErrorImpl(errors) {
    _super(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
function arrRemove(arr, item) {
  if (arr) {
    var index = arr.indexOf(item);
    0 <= index && arr.splice(index, 1);
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscription.js
var Subscription = function() {
  function Subscription2(initialTeardown) {
    this.initialTeardown = initialTeardown;
    this.closed = false;
    this._parentage = null;
    this._finalizers = null;
  }
  Subscription2.prototype.unsubscribe = function() {
    var e_1, _a, e_2, _b;
    var errors;
    if (!this.closed) {
      this.closed = true;
      var _parentage = this._parentage;
      if (_parentage) {
        this._parentage = null;
        if (Array.isArray(_parentage)) {
          try {
            for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
              var parent_1 = _parentage_1_1.value;
              parent_1.remove(this);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        } else {
          _parentage.remove(this);
        }
      }
      var initialFinalizer = this.initialTeardown;
      if (isFunction(initialFinalizer)) {
        try {
          initialFinalizer();
        } catch (e) {
          errors = e instanceof UnsubscriptionError ? e.errors : [e];
        }
      }
      var _finalizers = this._finalizers;
      if (_finalizers) {
        this._finalizers = null;
        try {
          for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
            var finalizer = _finalizers_1_1.value;
            try {
              execFinalizer(finalizer);
            } catch (err) {
              errors = errors !== null && errors !== void 0 ? errors : [];
              if (err instanceof UnsubscriptionError) {
                errors = __spreadArray(__spreadArray([], __read(errors)), __read(err.errors));
              } else {
                errors.push(err);
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_finalizers_1_1 && !_finalizers_1_1.done && (_b = _finalizers_1.return)) _b.call(_finalizers_1);
          } finally {
            if (e_2) throw e_2.error;
          }
        }
      }
      if (errors) {
        throw new UnsubscriptionError(errors);
      }
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var _a;
    if (teardown && teardown !== this) {
      if (this.closed) {
        execFinalizer(teardown);
      } else {
        if (teardown instanceof Subscription2) {
          if (teardown.closed || teardown._hasParent(this)) {
            return;
          }
          teardown._addParent(this);
        }
        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);
      }
    }
  };
  Subscription2.prototype._hasParent = function(parent2) {
    var _parentage = this._parentage;
    return _parentage === parent2 || Array.isArray(_parentage) && _parentage.includes(parent2);
  };
  Subscription2.prototype._addParent = function(parent2) {
    var _parentage = this._parentage;
    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent2), _parentage) : _parentage ? [_parentage, parent2] : parent2;
  };
  Subscription2.prototype._removeParent = function(parent2) {
    var _parentage = this._parentage;
    if (_parentage === parent2) {
      this._parentage = null;
    } else if (Array.isArray(_parentage)) {
      arrRemove(_parentage, parent2);
    }
  };
  Subscription2.prototype.remove = function(teardown) {
    var _finalizers = this._finalizers;
    _finalizers && arrRemove(_finalizers, teardown);
    if (teardown instanceof Subscription2) {
      teardown._removeParent(this);
    }
  };
  Subscription2.EMPTY = function() {
    var empty2 = new Subscription2();
    empty2.closed = true;
    return empty2;
  }();
  return Subscription2;
}();
var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
function isSubscription(value) {
  return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
}
function execFinalizer(finalizer) {
  if (isFunction(finalizer)) {
    finalizer();
  } else {
    finalizer.unsubscribe();
  }
}

// node_modules/rxjs/dist/esm5/internal/config.js
var config = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: false,
  useDeprecatedNextContext: false
};

// node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
var timeoutProvider = {
  setTimeout: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = timeoutProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
      return delegate.setTimeout.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setTimeout.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearTimeout: function(handle) {
    var delegate = timeoutProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
function reportUnhandledError(err) {
  timeoutProvider.setTimeout(function() {
    var onUnhandledError = config.onUnhandledError;
    if (onUnhandledError) {
      onUnhandledError(err);
    } else {
      throw err;
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/util/noop.js
function noop() {
}

// node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
var COMPLETE_NOTIFICATION = function() {
  return createNotification("C", void 0, void 0);
}();
function errorNotification(error) {
  return createNotification("E", void 0, error);
}
function nextNotification(value) {
  return createNotification("N", value, void 0);
}
function createNotification(kind, value, error) {
  return {
    kind,
    value,
    error
  };
}

// node_modules/rxjs/dist/esm5/internal/util/errorContext.js
var context = null;
function errorContext(cb) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    var isRoot = !context;
    if (isRoot) {
      context = { errorThrown: false, error: null };
    }
    cb();
    if (isRoot) {
      var _a = context, errorThrown = _a.errorThrown, error = _a.error;
      context = null;
      if (errorThrown) {
        throw error;
      }
    }
  } else {
    cb();
  }
}
function captureError(err) {
  if (config.useDeprecatedSynchronousErrorHandling && context) {
    context.errorThrown = true;
    context.error = err;
  }
}

// node_modules/rxjs/dist/esm5/internal/Subscriber.js
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destination) {
    var _this = _super.call(this) || this;
    _this.isStopped = false;
    if (destination) {
      _this.destination = destination;
      if (isSubscription(destination)) {
        destination.add(_this);
      }
    } else {
      _this.destination = EMPTY_OBSERVER;
    }
    return _this;
  }
  Subscriber2.create = function(next, error, complete) {
    return new SafeSubscriber(next, error, complete);
  };
  Subscriber2.prototype.next = function(value) {
    if (this.isStopped) {
      handleStoppedNotification(nextNotification(value), this);
    } else {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (this.isStopped) {
      handleStoppedNotification(errorNotification(err), this);
    } else {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (this.isStopped) {
      handleStoppedNotification(COMPLETE_NOTIFICATION, this);
    } else {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (!this.closed) {
      this.isStopped = true;
      _super.prototype.unsubscribe.call(this);
      this.destination = null;
    }
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    try {
      this.destination.error(err);
    } finally {
      this.unsubscribe();
    }
  };
  Subscriber2.prototype._complete = function() {
    try {
      this.destination.complete();
    } finally {
      this.unsubscribe();
    }
  };
  return Subscriber2;
}(Subscription);
var _bind = Function.prototype.bind;
function bind(fn, thisArg) {
  return _bind.call(fn, thisArg);
}
var ConsumerObserver = function() {
  function ConsumerObserver2(partialObserver) {
    this.partialObserver = partialObserver;
  }
  ConsumerObserver2.prototype.next = function(value) {
    var partialObserver = this.partialObserver;
    if (partialObserver.next) {
      try {
        partialObserver.next(value);
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  ConsumerObserver2.prototype.error = function(err) {
    var partialObserver = this.partialObserver;
    if (partialObserver.error) {
      try {
        partialObserver.error(err);
      } catch (error) {
        handleUnhandledError(error);
      }
    } else {
      handleUnhandledError(err);
    }
  };
  ConsumerObserver2.prototype.complete = function() {
    var partialObserver = this.partialObserver;
    if (partialObserver.complete) {
      try {
        partialObserver.complete();
      } catch (error) {
        handleUnhandledError(error);
      }
    }
  };
  return ConsumerObserver2;
}();
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    var partialObserver;
    if (isFunction(observerOrNext) || !observerOrNext) {
      partialObserver = {
        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
        error: error !== null && error !== void 0 ? error : void 0,
        complete: complete !== null && complete !== void 0 ? complete : void 0
      };
    } else {
      var context_1;
      if (_this && config.useDeprecatedNextContext) {
        context_1 = Object.create(observerOrNext);
        context_1.unsubscribe = function() {
          return _this.unsubscribe();
        };
        partialObserver = {
          next: observerOrNext.next && bind(observerOrNext.next, context_1),
          error: observerOrNext.error && bind(observerOrNext.error, context_1),
          complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
        };
      } else {
        partialObserver = observerOrNext;
      }
    }
    _this.destination = new ConsumerObserver(partialObserver);
    return _this;
  }
  return SafeSubscriber2;
}(Subscriber);
function handleUnhandledError(error) {
  if (config.useDeprecatedSynchronousErrorHandling) {
    captureError(error);
  } else {
    reportUnhandledError(error);
  }
}
function defaultErrorHandler(err) {
  throw err;
}
function handleStoppedNotification(notification, subscriber) {
  var onStoppedNotification = config.onStoppedNotification;
  onStoppedNotification && timeoutProvider.setTimeout(function() {
    return onStoppedNotification(notification, subscriber);
  });
}
var EMPTY_OBSERVER = {
  closed: true,
  next: noop,
  error: defaultErrorHandler,
  complete: noop
};

// node_modules/rxjs/dist/esm5/internal/symbol/observable.js
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();

// node_modules/rxjs/dist/esm5/internal/util/identity.js
function identity(x) {
  return x;
}

// node_modules/rxjs/dist/esm5/internal/util/pipe.js
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}

// node_modules/rxjs/dist/esm5/internal/Observable.js
var Observable = function() {
  function Observable2(subscribe) {
    if (subscribe) {
      this._subscribe = subscribe;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var _this = this;
    var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
    errorContext(function() {
      var _a = _this, operator = _a.operator, source = _a.source;
      subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
    });
    return subscriber;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      sink.error(err);
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscriber.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
      _this.subscribe(subscriber);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var _a;
    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x) {
        return value = x;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe) {
    return new Observable2(subscribe);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  var _a;
  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;
}
function isObserver(value) {
  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
}
function isSubscriber(value) {
  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
}

// node_modules/rxjs/dist/esm5/internal/util/lift.js
function hasLift(source) {
  return isFunction(source === null || source === void 0 ? void 0 : source.lift);
}
function operate(init) {
  return function(source) {
    if (hasLift(source)) {
      return source.lift(function(liftedSource) {
        try {
          return init(liftedSource, this);
        } catch (err) {
          this.error(err);
        }
      });
    }
    throw new TypeError("Unable to lift unknown Observable type");
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
}
var OperatorSubscriber = function(_super) {
  __extends(OperatorSubscriber2, _super);
  function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
    var _this = _super.call(this, destination) || this;
    _this.onFinalize = onFinalize;
    _this.shouldUnsubscribe = shouldUnsubscribe;
    _this._next = onNext ? function(value) {
      try {
        onNext(value);
      } catch (err) {
        destination.error(err);
      }
    } : _super.prototype._next;
    _this._error = onError ? function(err) {
      try {
        onError(err);
      } catch (err2) {
        destination.error(err2);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._error;
    _this._complete = onComplete ? function() {
      try {
        onComplete();
      } catch (err) {
        destination.error(err);
      } finally {
        this.unsubscribe();
      }
    } : _super.prototype._complete;
    return _this;
  }
  OperatorSubscriber2.prototype.unsubscribe = function() {
    var _a;
    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
      var closed_1 = this.closed;
      _super.prototype.unsubscribe.call(this);
      !closed_1 && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    }
  };
  return OperatorSubscriber2;
}(Subscriber);

// node_modules/rxjs/dist/esm5/internal/operators/refCount.js
function refCount() {
  return operate(function(source, subscriber) {
    var connection = null;
    source._refCount++;
    var refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, function() {
      if (!source || source._refCount <= 0 || 0 < --source._refCount) {
        connection = null;
        return;
      }
      var sharedConnection = source._connection;
      var conn = connection;
      connection = null;
      if (sharedConnection && (!conn || sharedConnection === conn)) {
        sharedConnection.unsubscribe();
      }
      subscriber.unsubscribe();
    });
    source.subscribe(refCounter);
    if (!refCounter.closed) {
      connection = source.connect();
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/ConnectableObservable.js
var ConnectableObservable = function(_super) {
  __extends(ConnectableObservable2, _super);
  function ConnectableObservable2(source, subjectFactory) {
    var _this = _super.call(this) || this;
    _this.source = source;
    _this.subjectFactory = subjectFactory;
    _this._subject = null;
    _this._refCount = 0;
    _this._connection = null;
    if (hasLift(source)) {
      _this.lift = source.lift;
    }
    return _this;
  }
  ConnectableObservable2.prototype._subscribe = function(subscriber) {
    return this.getSubject().subscribe(subscriber);
  };
  ConnectableObservable2.prototype.getSubject = function() {
    var subject = this._subject;
    if (!subject || subject.isStopped) {
      this._subject = this.subjectFactory();
    }
    return this._subject;
  };
  ConnectableObservable2.prototype._teardown = function() {
    this._refCount = 0;
    var _connection = this._connection;
    this._subject = this._connection = null;
    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();
  };
  ConnectableObservable2.prototype.connect = function() {
    var _this = this;
    var connection = this._connection;
    if (!connection) {
      connection = this._connection = new Subscription();
      var subject_1 = this.getSubject();
      connection.add(this.source.subscribe(createOperatorSubscriber(subject_1, void 0, function() {
        _this._teardown();
        subject_1.complete();
      }, function(err) {
        _this._teardown();
        subject_1.error(err);
      }, function() {
        return _this._teardown();
      })));
      if (connection.closed) {
        this._connection = null;
        connection = Subscription.EMPTY;
      }
    }
    return connection;
  };
  ConnectableObservable2.prototype.refCount = function() {
    return refCount()(this);
  };
  return ConnectableObservable2;
}(Observable);

// node_modules/rxjs/dist/esm5/internal/scheduler/performanceTimestampProvider.js
var performanceTimestampProvider = {
  now: function() {
    return (performanceTimestampProvider.delegate || performance).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrameProvider.js
var animationFrameProvider = {
  schedule: function(callback) {
    var request = requestAnimationFrame;
    var cancel = cancelAnimationFrame;
    var delegate = animationFrameProvider.delegate;
    if (delegate) {
      request = delegate.requestAnimationFrame;
      cancel = delegate.cancelAnimationFrame;
    }
    var handle = request(function(timestamp2) {
      cancel = void 0;
      callback(timestamp2);
    });
    return new Subscription(function() {
      return cancel === null || cancel === void 0 ? void 0 : cancel(handle);
    });
  },
  requestAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  cancelAnimationFrame: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = animationFrameProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/observable/dom/animationFrames.js
function animationFramesFactory(timestampProvider) {
  return new Observable(function(subscriber) {
    var provider = timestampProvider || performanceTimestampProvider;
    var start = provider.now();
    var id = 0;
    var run = function() {
      if (!subscriber.closed) {
        id = animationFrameProvider.requestAnimationFrame(function(timestamp2) {
          id = 0;
          var now2 = provider.now();
          subscriber.next({
            timestamp: timestampProvider ? now2 : timestamp2,
            elapsed: now2 - start
          });
          run();
        });
      }
    };
    run();
    return function() {
      if (id) {
        animationFrameProvider.cancelAnimationFrame(id);
      }
    };
  });
}
var DEFAULT_ANIMATION_FRAMES = animationFramesFactory();

// node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
var ObjectUnsubscribedError = createErrorClass(function(_super) {
  return function ObjectUnsubscribedErrorImpl() {
    _super(this);
    this.name = "ObjectUnsubscribedError";
    this.message = "object unsubscribed";
  };
});

// node_modules/rxjs/dist/esm5/internal/Subject.js
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.closed = false;
    _this.currentObservers = null;
    _this.observers = [];
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype._throwIfClosed = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
  };
  Subject2.prototype.next = function(value) {
    var _this = this;
    errorContext(function() {
      var e_1, _a;
      _this._throwIfClosed();
      if (!_this.isStopped) {
        if (!_this.currentObservers) {
          _this.currentObservers = Array.from(_this.observers);
        }
        try {
          for (var _b = __values(_this.currentObservers), _c = _b.next(); !_c.done; _c = _b.next()) {
            var observer = _c.value;
            observer.next(value);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    });
  };
  Subject2.prototype.error = function(err) {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.hasError = _this.isStopped = true;
        _this.thrownError = err;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().error(err);
        }
      }
    });
  };
  Subject2.prototype.complete = function() {
    var _this = this;
    errorContext(function() {
      _this._throwIfClosed();
      if (!_this.isStopped) {
        _this.isStopped = true;
        var observers = _this.observers;
        while (observers.length) {
          observers.shift().complete();
        }
      }
    });
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = this.closed = true;
    this.observers = this.currentObservers = null;
  };
  Object.defineProperty(Subject2.prototype, "observed", {
    get: function() {
      var _a;
      return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
    },
    enumerable: false,
    configurable: true
  });
  Subject2.prototype._trySubscribe = function(subscriber) {
    this._throwIfClosed();
    return _super.prototype._trySubscribe.call(this, subscriber);
  };
  Subject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._checkFinalizedStatuses(subscriber);
    return this._innerSubscribe(subscriber);
  };
  Subject2.prototype._innerSubscribe = function(subscriber) {
    var _this = this;
    var _a = this, hasError = _a.hasError, isStopped = _a.isStopped, observers = _a.observers;
    if (hasError || isStopped) {
      return EMPTY_SUBSCRIPTION;
    }
    this.currentObservers = null;
    observers.push(subscriber);
    return new Subscription(function() {
      _this.currentObservers = null;
      arrRemove(observers, subscriber);
    });
  };
  Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, isStopped = _a.isStopped;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped) {
      subscriber.complete();
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
  };
  AnonymousSubject2.prototype.error = function(err) {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
  };
  AnonymousSubject2.prototype.complete = function() {
    var _a, _b;
    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var _a, _b;
    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
  };
  return AnonymousSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
var BehaviorSubject = function(_super) {
  __extends(BehaviorSubject2, _super);
  function BehaviorSubject2(_value) {
    var _this = _super.call(this) || this;
    _this._value = _value;
    return _this;
  }
  Object.defineProperty(BehaviorSubject2.prototype, "value", {
    get: function() {
      return this.getValue();
    },
    enumerable: false,
    configurable: true
  });
  BehaviorSubject2.prototype._subscribe = function(subscriber) {
    var subscription = _super.prototype._subscribe.call(this, subscriber);
    !subscription.closed && subscriber.next(this._value);
    return subscription;
  };
  BehaviorSubject2.prototype.getValue = function() {
    var _a = this, hasError = _a.hasError, thrownError = _a.thrownError, _value = _a._value;
    if (hasError) {
      throw thrownError;
    }
    this._throwIfClosed();
    return _value;
  };
  BehaviorSubject2.prototype.next = function(value) {
    _super.prototype.next.call(this, this._value = value);
  };
  return BehaviorSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
var dateTimestampProvider = {
  now: function() {
    return (dateTimestampProvider.delegate || Date).now();
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
var ReplaySubject = function(_super) {
  __extends(ReplaySubject2, _super);
  function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
    if (_bufferSize === void 0) {
      _bufferSize = Infinity;
    }
    if (_windowTime === void 0) {
      _windowTime = Infinity;
    }
    if (_timestampProvider === void 0) {
      _timestampProvider = dateTimestampProvider;
    }
    var _this = _super.call(this) || this;
    _this._bufferSize = _bufferSize;
    _this._windowTime = _windowTime;
    _this._timestampProvider = _timestampProvider;
    _this._buffer = [];
    _this._infiniteTimeWindow = true;
    _this._infiniteTimeWindow = _windowTime === Infinity;
    _this._bufferSize = Math.max(1, _bufferSize);
    _this._windowTime = Math.max(1, _windowTime);
    return _this;
  }
  ReplaySubject2.prototype.next = function(value) {
    var _a = this, isStopped = _a.isStopped, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow, _timestampProvider = _a._timestampProvider, _windowTime = _a._windowTime;
    if (!isStopped) {
      _buffer.push(value);
      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
    }
    this._trimBuffer();
    _super.prototype.next.call(this, value);
  };
  ReplaySubject2.prototype._subscribe = function(subscriber) {
    this._throwIfClosed();
    this._trimBuffer();
    var subscription = this._innerSubscribe(subscriber);
    var _a = this, _infiniteTimeWindow = _a._infiniteTimeWindow, _buffer = _a._buffer;
    var copy = _buffer.slice();
    for (var i2 = 0; i2 < copy.length && !subscriber.closed; i2 += _infiniteTimeWindow ? 1 : 2) {
      subscriber.next(copy[i2]);
    }
    this._checkFinalizedStatuses(subscriber);
    return subscription;
  };
  ReplaySubject2.prototype._trimBuffer = function() {
    var _a = this, _bufferSize = _a._bufferSize, _timestampProvider = _a._timestampProvider, _buffer = _a._buffer, _infiniteTimeWindow = _a._infiniteTimeWindow;
    var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
    if (!_infiniteTimeWindow) {
      var now2 = _timestampProvider.now();
      var last3 = 0;
      for (var i2 = 1; i2 < _buffer.length && _buffer[i2] <= now2; i2 += 2) {
        last3 = i2;
      }
      last3 && _buffer.splice(0, last3 + 1);
    }
  };
  return ReplaySubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/AsyncSubject.js
var AsyncSubject = function(_super) {
  __extends(AsyncSubject2, _super);
  function AsyncSubject2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._value = null;
    _this._hasValue = false;
    _this._isComplete = false;
    return _this;
  }
  AsyncSubject2.prototype._checkFinalizedStatuses = function(subscriber) {
    var _a = this, hasError = _a.hasError, _hasValue = _a._hasValue, _value = _a._value, thrownError = _a.thrownError, isStopped = _a.isStopped, _isComplete = _a._isComplete;
    if (hasError) {
      subscriber.error(thrownError);
    } else if (isStopped || _isComplete) {
      _hasValue && subscriber.next(_value);
      subscriber.complete();
    }
  };
  AsyncSubject2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._value = value;
      this._hasValue = true;
    }
  };
  AsyncSubject2.prototype.complete = function() {
    var _a = this, _hasValue = _a._hasValue, _value = _a._value, _isComplete = _a._isComplete;
    if (!_isComplete) {
      this._isComplete = true;
      _hasValue && _super.prototype.next.call(this, _value);
      _super.prototype.complete.call(this);
    }
  };
  return AsyncSubject2;
}(Subject);

// node_modules/rxjs/dist/esm5/internal/scheduler/Action.js
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return this;
  };
  return Action2;
}(Subscription);

// node_modules/rxjs/dist/esm5/internal/scheduler/intervalProvider.js
var intervalProvider = {
  setInterval: function(handler, timeout2) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var delegate = intervalProvider.delegate;
    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {
      return delegate.setInterval.apply(delegate, __spreadArray([handler, timeout2], __read(args)));
    }
    return setInterval.apply(void 0, __spreadArray([handler, timeout2], __read(args)));
  },
  clearInterval: function(handle) {
    var delegate = intervalProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncAction.js
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay2);
    }
    this.pending = true;
    this.delay = delay2;
    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay2);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, _id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay2);
  };
  AsyncAction2.prototype.recycleAsyncId = function(_scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && this.delay === delay2 && this.pending === false) {
      return id;
    }
    if (id != null) {
      intervalProvider.clearInterval(id);
    }
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay2) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay2);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, _delay) {
    var errored = false;
    var errorValue;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = e ? e : new Error("Scheduled action threw falsy error");
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype.unsubscribe = function() {
    if (!this.closed) {
      var _a = this, id = _a.id, scheduler = _a.scheduler;
      var actions = scheduler.actions;
      this.work = this.state = this.scheduler = null;
      this.pending = false;
      arrRemove(actions, this);
      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, null);
      }
      this.delay = null;
      _super.prototype.unsubscribe.call(this);
    }
  };
  return AsyncAction2;
}(Action);

// node_modules/rxjs/dist/esm5/internal/util/Immediate.js
var nextHandle = 1;
var resolved;
var activeHandles = {};
function findAndClearHandle(handle) {
  if (handle in activeHandles) {
    delete activeHandles[handle];
    return true;
  }
  return false;
}
var Immediate = {
  setImmediate: function(cb) {
    var handle = nextHandle++;
    activeHandles[handle] = true;
    if (!resolved) {
      resolved = Promise.resolve();
    }
    resolved.then(function() {
      return findAndClearHandle(handle) && cb();
    });
    return handle;
  },
  clearImmediate: function(handle) {
    findAndClearHandle(handle);
  }
};

// node_modules/rxjs/dist/esm5/internal/scheduler/immediateProvider.js
var setImmediate = Immediate.setImmediate;
var clearImmediate = Immediate.clearImmediate;
var immediateProvider = {
  setImmediate: function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));
  },
  clearImmediate: function(handle) {
    var delegate = immediateProvider.delegate;
    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);
  },
  delegate: void 0
};

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapAction.js
var AsapAction = function(_super) {
  __extends(AsapAction2, _super);
  function AsapAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AsapAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, void 0)));
  };
  AsapAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      immediateProvider.clearImmediate(id);
      if (scheduler._scheduled === id) {
        scheduler._scheduled = void 0;
      }
    }
    return void 0;
  };
  return AsapAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/Scheduler.js
var Scheduler = function() {
  function Scheduler2(schedulerActionCtor, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.schedulerActionCtor = schedulerActionCtor;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay2, state) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return new this.schedulerActionCtor(this, work).schedule(state, delay2);
  };
  Scheduler2.now = dateTimestampProvider.now;
  return Scheduler2;
}();

// node_modules/rxjs/dist/esm5/internal/scheduler/AsyncScheduler.js
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, now2) || this;
    _this.actions = [];
    _this._active = false;
    return _this;
  }
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this._active) {
      actions.push(action);
      return;
    }
    var error;
    this._active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this._active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/AsapScheduler.js
var AsapScheduler = function(_super) {
  __extends(AsapScheduler2, _super);
  function AsapScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AsapScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId = this._scheduled;
    this._scheduled = void 0;
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsapScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/asap.js
var asapScheduler = new AsapScheduler(AsapAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/async.js
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueAction.js
var QueueAction = function(_super) {
  __extends(QueueAction2, _super);
  function QueueAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  QueueAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 > 0) {
      return _super.prototype.schedule.call(this, state, delay2);
    }
    this.delay = delay2;
    this.state = state;
    this.scheduler.flush(this);
    return this;
  };
  QueueAction2.prototype.execute = function(state, delay2) {
    return delay2 > 0 || this.closed ? _super.prototype.execute.call(this, state, delay2) : this._execute(state, delay2);
  };
  QueueAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null && delay2 > 0 || delay2 == null && this.delay > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.flush(this);
    return 0;
  };
  return QueueAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/QueueScheduler.js
var QueueScheduler = function(_super) {
  __extends(QueueScheduler2, _super);
  function QueueScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return QueueScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/queue.js
var queueScheduler = new QueueScheduler(QueueAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameAction.js
var AnimationFrameAction = function(_super) {
  __extends(AnimationFrameAction2, _super);
  function AnimationFrameAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    return _this;
  }
  AnimationFrameAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 !== null && delay2 > 0) {
      return _super.prototype.requestAsyncId.call(this, scheduler, id, delay2);
    }
    scheduler.actions.push(this);
    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function() {
      return scheduler.flush(void 0);
    }));
  };
  AnimationFrameAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    var _a;
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (delay2 != null ? delay2 > 0 : this.delay > 0) {
      return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay2);
    }
    var actions = scheduler.actions;
    if (id != null && id === scheduler._scheduled && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {
      animationFrameProvider.cancelAnimationFrame(id);
      scheduler._scheduled = void 0;
    }
    return void 0;
  };
  return AnimationFrameAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/AnimationFrameScheduler.js
var AnimationFrameScheduler = function(_super) {
  __extends(AnimationFrameScheduler2, _super);
  function AnimationFrameScheduler2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  AnimationFrameScheduler2.prototype.flush = function(action) {
    this._active = true;
    var flushId;
    if (action) {
      flushId = action.id;
    } else {
      flushId = this._scheduled;
      this._scheduled = void 0;
    }
    var actions = this.actions;
    var error;
    action = action || actions.shift();
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while ((action = actions[0]) && action.id === flushId && actions.shift());
    this._active = false;
    if (error) {
      while ((action = actions[0]) && action.id === flushId && actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AnimationFrameScheduler2;
}(AsyncScheduler);

// node_modules/rxjs/dist/esm5/internal/scheduler/animationFrame.js
var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);

// node_modules/rxjs/dist/esm5/internal/scheduler/VirtualTimeScheduler.js
var VirtualTimeScheduler = function(_super) {
  __extends(VirtualTimeScheduler2, _super);
  function VirtualTimeScheduler2(schedulerActionCtor, maxFrames) {
    if (schedulerActionCtor === void 0) {
      schedulerActionCtor = VirtualAction;
    }
    if (maxFrames === void 0) {
      maxFrames = Infinity;
    }
    var _this = _super.call(this, schedulerActionCtor, function() {
      return _this.frame;
    }) || this;
    _this.maxFrames = maxFrames;
    _this.frame = 0;
    _this.index = -1;
    return _this;
  }
  VirtualTimeScheduler2.prototype.flush = function() {
    var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
    var error;
    var action;
    while ((action = actions[0]) && action.delay <= maxFrames) {
      actions.shift();
      this.frame = action.delay;
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    }
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  VirtualTimeScheduler2.frameTimeFactor = 10;
  return VirtualTimeScheduler2;
}(AsyncScheduler);
var VirtualAction = function(_super) {
  __extends(VirtualAction2, _super);
  function VirtualAction2(scheduler, work, index) {
    if (index === void 0) {
      index = scheduler.index += 1;
    }
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.index = index;
    _this.active = true;
    _this.index = scheduler.index = index;
    return _this;
  }
  VirtualAction2.prototype.schedule = function(state, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    if (Number.isFinite(delay2)) {
      if (!this.id) {
        return _super.prototype.schedule.call(this, state, delay2);
      }
      this.active = false;
      var action = new VirtualAction2(this.scheduler, this.work);
      this.add(action);
      return action.schedule(state, delay2);
    } else {
      return Subscription.EMPTY;
    }
  };
  VirtualAction2.prototype.requestAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    this.delay = scheduler.frame + delay2;
    var actions = scheduler.actions;
    actions.push(this);
    actions.sort(VirtualAction2.sortActions);
    return 1;
  };
  VirtualAction2.prototype.recycleAsyncId = function(scheduler, id, delay2) {
    if (delay2 === void 0) {
      delay2 = 0;
    }
    return void 0;
  };
  VirtualAction2.prototype._execute = function(state, delay2) {
    if (this.active === true) {
      return _super.prototype._execute.call(this, state, delay2);
    }
  };
  VirtualAction2.sortActions = function(a, b) {
    if (a.delay === b.delay) {
      if (a.index === b.index) {
        return 0;
      } else if (a.index > b.index) {
        return 1;
      } else {
        return -1;
      }
    } else if (a.delay > b.delay) {
      return 1;
    } else {
      return -1;
    }
  };
  return VirtualAction2;
}(AsyncAction);

// node_modules/rxjs/dist/esm5/internal/observable/empty.js
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});

// node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
function isScheduler(value) {
  return value && isFunction(value.schedule);
}

// node_modules/rxjs/dist/esm5/internal/util/args.js
function last(arr) {
  return arr[arr.length - 1];
}
function popResultSelector(args) {
  return isFunction(last(args)) ? args.pop() : void 0;
}
function popScheduler(args) {
  return isScheduler(last(args)) ? args.pop() : void 0;
}
function popNumber(args, defaultValue) {
  return typeof last(args) === "number" ? args.pop() : defaultValue;
}

// node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
var isArrayLike = function(x) {
  return x && typeof x.length === "number" && typeof x !== "function";
};

// node_modules/rxjs/dist/esm5/internal/util/isPromise.js
function isPromise(value) {
  return isFunction(value === null || value === void 0 ? void 0 : value.then);
}

// node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
function isInteropObservable(input) {
  return isFunction(input[observable]);
}

// node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
function isAsyncIterable(obj) {
  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
function createInvalidObservableTypeError(input) {
  return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
}

// node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();

// node_modules/rxjs/dist/esm5/internal/util/isIterable.js
function isIterable(input) {
  return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
}

// node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
function readableStreamLikeToAsyncGenerator(readableStream) {
  return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
    var reader, _a, value, done;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          reader = readableStream.getReader();
          _b.label = 1;
        case 1:
          _b.trys.push([1, , 9, 10]);
          _b.label = 2;
        case 2:
          if (false) return [3, 8];
          return [4, __await(reader.read())];
        case 3:
          _a = _b.sent(), value = _a.value, done = _a.done;
          if (!done) return [3, 5];
          return [4, __await(void 0)];
        case 4:
          return [2, _b.sent()];
        case 5:
          return [4, __await(value)];
        case 6:
          return [4, _b.sent()];
        case 7:
          _b.sent();
          return [3, 2];
        case 8:
          return [3, 10];
        case 9:
          reader.releaseLock();
          return [7];
        case 10:
          return [2];
      }
    });
  });
}
function isReadableStreamLike(obj) {
  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
}

// node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
function innerFrom(input) {
  if (input instanceof Observable) {
    return input;
  }
  if (input != null) {
    if (isInteropObservable(input)) {
      return fromInteropObservable(input);
    }
    if (isArrayLike(input)) {
      return fromArrayLike(input);
    }
    if (isPromise(input)) {
      return fromPromise(input);
    }
    if (isAsyncIterable(input)) {
      return fromAsyncIterable(input);
    }
    if (isIterable(input)) {
      return fromIterable(input);
    }
    if (isReadableStreamLike(input)) {
      return fromReadableStreamLike(input);
    }
  }
  throw createInvalidObservableTypeError(input);
}
function fromInteropObservable(obj) {
  return new Observable(function(subscriber) {
    var obs = obj[observable]();
    if (isFunction(obs.subscribe)) {
      return obs.subscribe(subscriber);
    }
    throw new TypeError("Provided object does not correctly implement Symbol.observable");
  });
}
function fromArrayLike(array) {
  return new Observable(function(subscriber) {
    for (var i2 = 0; i2 < array.length && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  });
}
function fromPromise(promise) {
  return new Observable(function(subscriber) {
    promise.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, reportUnhandledError);
  });
}
function fromIterable(iterable) {
  return new Observable(function(subscriber) {
    var e_1, _a;
    try {
      for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
        var value = iterable_1_1.value;
        subscriber.next(value);
        if (subscriber.closed) {
          return;
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    subscriber.complete();
  });
}
function fromAsyncIterable(asyncIterable) {
  return new Observable(function(subscriber) {
    process2(asyncIterable, subscriber).catch(function(err) {
      return subscriber.error(err);
    });
  });
}
function fromReadableStreamLike(readableStream) {
  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
}
function process2(asyncIterable, subscriber) {
  var asyncIterable_1, asyncIterable_1_1;
  var e_2, _a;
  return __awaiter(this, void 0, void 0, function() {
    var value, e_2_1;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          _b.trys.push([0, 5, 6, 11]);
          asyncIterable_1 = __asyncValues(asyncIterable);
          _b.label = 1;
        case 1:
          return [4, asyncIterable_1.next()];
        case 2:
          if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
          value = asyncIterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return [2];
          }
          _b.label = 3;
        case 3:
          return [3, 1];
        case 4:
          return [3, 11];
        case 5:
          e_2_1 = _b.sent();
          e_2 = { error: e_2_1 };
          return [3, 11];
        case 6:
          _b.trys.push([6, , 9, 10]);
          if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
          return [4, _a.call(asyncIterable_1)];
        case 7:
          _b.sent();
          _b.label = 8;
        case 8:
          return [3, 10];
        case 9:
          if (e_2) throw e_2.error;
          return [7];
        case 10:
          return [7];
        case 11:
          subscriber.complete();
          return [2];
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
function executeSchedule(parentSubscription, scheduler, work, delay2, repeat2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  if (repeat2 === void 0) {
    repeat2 = false;
  }
  var scheduleSubscription = scheduler.schedule(function() {
    work();
    if (repeat2) {
      parentSubscription.add(this.schedule(null, delay2));
    } else {
      this.unsubscribe();
    }
  }, delay2);
  parentSubscription.add(scheduleSubscription);
  if (!repeat2) {
    return scheduleSubscription;
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
function observeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.next(value);
      }, delay2);
    }, function() {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.complete();
      }, delay2);
    }, function(err) {
      return executeSchedule(subscriber, scheduler, function() {
        return subscriber.error(err);
      }, delay2);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
function subscribeOn(scheduler, delay2) {
  if (delay2 === void 0) {
    delay2 = 0;
  }
  return operate(function(source, subscriber) {
    subscriber.add(scheduler.schedule(function() {
      return source.subscribe(subscriber);
    }, delay2));
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
function scheduleObservable(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
function schedulePromise(input, scheduler) {
  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
function scheduleArray(input, scheduler) {
  return new Observable(function(subscriber) {
    var i2 = 0;
    return scheduler.schedule(function() {
      if (i2 === input.length) {
        subscriber.complete();
      } else {
        subscriber.next(input[i2++]);
        if (!subscriber.closed) {
          this.schedule();
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
function scheduleIterable(input, scheduler) {
  return new Observable(function(subscriber) {
    var iterator2;
    executeSchedule(subscriber, scheduler, function() {
      iterator2 = input[iterator]();
      executeSchedule(subscriber, scheduler, function() {
        var _a;
        var value;
        var done;
        try {
          _a = iterator2.next(), value = _a.value, done = _a.done;
        } catch (err) {
          subscriber.error(err);
          return;
        }
        if (done) {
          subscriber.complete();
        } else {
          subscriber.next(value);
        }
      }, 0, true);
    });
    return function() {
      return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
    };
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
function scheduleAsyncIterable(input, scheduler) {
  if (!input) {
    throw new Error("Iterable cannot be null");
  }
  return new Observable(function(subscriber) {
    executeSchedule(subscriber, scheduler, function() {
      var iterator2 = input[Symbol.asyncIterator]();
      executeSchedule(subscriber, scheduler, function() {
        iterator2.next().then(function(result) {
          if (result.done) {
            subscriber.complete();
          } else {
            subscriber.next(result.value);
          }
        });
      }, 0, true);
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
function scheduleReadableStreamLike(input, scheduler) {
  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
}

// node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
function scheduled(input, scheduler) {
  if (input != null) {
    if (isInteropObservable(input)) {
      return scheduleObservable(input, scheduler);
    }
    if (isArrayLike(input)) {
      return scheduleArray(input, scheduler);
    }
    if (isPromise(input)) {
      return schedulePromise(input, scheduler);
    }
    if (isAsyncIterable(input)) {
      return scheduleAsyncIterable(input, scheduler);
    }
    if (isIterable(input)) {
      return scheduleIterable(input, scheduler);
    }
    if (isReadableStreamLike(input)) {
      return scheduleReadableStreamLike(input, scheduler);
    }
  }
  throw createInvalidObservableTypeError(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/from.js
function from(input, scheduler) {
  return scheduler ? scheduled(input, scheduler) : innerFrom(input);
}

// node_modules/rxjs/dist/esm5/internal/observable/of.js
function of() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  return from(args, scheduler);
}

// node_modules/rxjs/dist/esm5/internal/observable/throwError.js
function throwError(errorOrErrorFactory, scheduler) {
  var errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : function() {
    return errorOrErrorFactory;
  };
  var init = function(subscriber) {
    return subscriber.error(errorFactory());
  };
  return new Observable(scheduler ? function(subscriber) {
    return scheduler.schedule(init, 0, subscriber);
  } : init);
}

// node_modules/rxjs/dist/esm5/internal/Notification.js
var NotificationKind;
(function(NotificationKind2) {
  NotificationKind2["NEXT"] = "N";
  NotificationKind2["ERROR"] = "E";
  NotificationKind2["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = function() {
  function Notification2(kind, value, error) {
    this.kind = kind;
    this.value = value;
    this.error = error;
    this.hasValue = kind === "N";
  }
  Notification2.prototype.observe = function(observer) {
    return observeNotification(this, observer);
  };
  Notification2.prototype.do = function(nextHandler, errorHandler, completeHandler) {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    return kind === "N" ? nextHandler === null || nextHandler === void 0 ? void 0 : nextHandler(value) : kind === "E" ? errorHandler === null || errorHandler === void 0 ? void 0 : errorHandler(error) : completeHandler === null || completeHandler === void 0 ? void 0 : completeHandler();
  };
  Notification2.prototype.accept = function(nextOrObserver, error, complete) {
    var _a;
    return isFunction((_a = nextOrObserver) === null || _a === void 0 ? void 0 : _a.next) ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete);
  };
  Notification2.prototype.toObservable = function() {
    var _a = this, kind = _a.kind, value = _a.value, error = _a.error;
    var result = kind === "N" ? of(value) : kind === "E" ? throwError(function() {
      return error;
    }) : kind === "C" ? EMPTY : 0;
    if (!result) {
      throw new TypeError("Unexpected notification kind " + kind);
    }
    return result;
  };
  Notification2.createNext = function(value) {
    return new Notification2("N", value);
  };
  Notification2.createError = function(err) {
    return new Notification2("E", void 0, err);
  };
  Notification2.createComplete = function() {
    return Notification2.completeNotification;
  };
  Notification2.completeNotification = new Notification2("C");
  return Notification2;
}();
function observeNotification(notification, observer) {
  var _a, _b, _c;
  var _d = notification, kind = _d.kind, value = _d.value, error = _d.error;
  if (typeof kind !== "string") {
    throw new TypeError('Invalid notification, missing "kind"');
  }
  kind === "N" ? (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, value) : kind === "E" ? (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, error) : (_c = observer.complete) === null || _c === void 0 ? void 0 : _c.call(observer);
}

// node_modules/rxjs/dist/esm5/internal/util/isObservable.js
function isObservable(obj) {
  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
}

// node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
var EmptyError = createErrorClass(function(_super) {
  return function EmptyErrorImpl() {
    _super(this);
    this.name = "EmptyError";
    this.message = "no elements in sequence";
  };
});

// node_modules/rxjs/dist/esm5/internal/lastValueFrom.js
function lastValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var _hasValue = false;
    var _value;
    source.subscribe({
      next: function(value) {
        _value = value;
        _hasValue = true;
      },
      error: reject,
      complete: function() {
        if (_hasValue) {
          resolve(_value);
        } else if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
  });
}

// node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
function firstValueFrom(source, config2) {
  var hasConfig = typeof config2 === "object";
  return new Promise(function(resolve, reject) {
    var subscriber = new SafeSubscriber({
      next: function(value) {
        resolve(value);
        subscriber.unsubscribe();
      },
      error: reject,
      complete: function() {
        if (hasConfig) {
          resolve(config2.defaultValue);
        } else {
          reject(new EmptyError());
        }
      }
    });
    source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/ArgumentOutOfRangeError.js
var ArgumentOutOfRangeError = createErrorClass(function(_super) {
  return function ArgumentOutOfRangeErrorImpl() {
    _super(this);
    this.name = "ArgumentOutOfRangeError";
    this.message = "argument out of range";
  };
});

// node_modules/rxjs/dist/esm5/internal/util/NotFoundError.js
var NotFoundError = createErrorClass(function(_super) {
  return function NotFoundErrorImpl(message) {
    _super(this);
    this.name = "NotFoundError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/SequenceError.js
var SequenceError = createErrorClass(function(_super) {
  return function SequenceErrorImpl(message) {
    _super(this);
    this.name = "SequenceError";
    this.message = message;
  };
});

// node_modules/rxjs/dist/esm5/internal/util/isDate.js
function isValidDate(value) {
  return value instanceof Date && !isNaN(value);
}

// node_modules/rxjs/dist/esm5/internal/operators/timeout.js
var TimeoutError = createErrorClass(function(_super) {
  return function TimeoutErrorImpl(info) {
    if (info === void 0) {
      info = null;
    }
    _super(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    this.info = info;
  };
});
function timeout(config2, schedulerArg) {
  var _a = isValidDate(config2) ? { first: config2 } : typeof config2 === "number" ? { each: config2 } : config2, first2 = _a.first, each = _a.each, _b = _a.with, _with = _b === void 0 ? timeoutErrorFactory : _b, _c = _a.scheduler, scheduler = _c === void 0 ? schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler : _c, _d = _a.meta, meta = _d === void 0 ? null : _d;
  if (first2 == null && each == null) {
    throw new TypeError("No timeout provided.");
  }
  return operate(function(source, subscriber) {
    var originalSourceSubscription;
    var timerSubscription;
    var lastValue = null;
    var seen = 0;
    var startTimer = function(delay2) {
      timerSubscription = executeSchedule(subscriber, scheduler, function() {
        try {
          originalSourceSubscription.unsubscribe();
          innerFrom(_with({
            meta,
            lastValue,
            seen
          })).subscribe(subscriber);
        } catch (err) {
          subscriber.error(err);
        }
      }, delay2);
    };
    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      seen++;
      subscriber.next(lastValue = value);
      each > 0 && startTimer(each);
    }, void 0, void 0, function() {
      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {
        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();
      }
      lastValue = null;
    }));
    !seen && startTimer(first2 != null ? typeof first2 === "number" ? first2 : +first2 - scheduler.now() : each);
  });
}
function timeoutErrorFactory(info) {
  throw new TimeoutError(info);
}

// node_modules/rxjs/dist/esm5/internal/operators/map.js
function map(project, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      subscriber.next(project.call(thisArg, value, index++));
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
var isArray = Array.isArray;
function callOrApply(fn, args) {
  return isArray(args) ? fn.apply(void 0, __spreadArray([], __read(args))) : fn(args);
}
function mapOneOrManyArgs(fn) {
  return map(function(args) {
    return callOrApply(fn, args);
  });
}

// node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
var isArray2 = Array.isArray;
var getPrototypeOf = Object.getPrototypeOf;
var objectProto = Object.prototype;
var getKeys = Object.keys;
function argsArgArrayOrObject(args) {
  if (args.length === 1) {
    var first_1 = args[0];
    if (isArray2(first_1)) {
      return { args: first_1, keys: null };
    }
    if (isPOJO(first_1)) {
      var keys = getKeys(first_1);
      return {
        args: keys.map(function(key) {
          return first_1[key];
        }),
        keys
      };
    }
  }
  return { args, keys: null };
}
function isPOJO(obj) {
  return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
}

// node_modules/rxjs/dist/esm5/internal/util/createObject.js
function createObject(keys, values) {
  return keys.reduce(function(result, key, i2) {
    return result[key] = values[i2], result;
  }, {});
}

// node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
function combineLatest() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var resultSelector = popResultSelector(args);
  var _a = argsArgArrayOrObject(args), observables = _a.args, keys = _a.keys;
  if (observables.length === 0) {
    return from([], scheduler);
  }
  var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
    return createObject(keys, values);
  } : identity));
  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
}
function combineLatestInit(observables, scheduler, valueTransform) {
  if (valueTransform === void 0) {
    valueTransform = identity;
  }
  return function(subscriber) {
    maybeSchedule(scheduler, function() {
      var length = observables.length;
      var values = new Array(length);
      var active = length;
      var remainingFirstValues = length;
      var _loop_1 = function(i3) {
        maybeSchedule(scheduler, function() {
          var source = from(observables[i3], scheduler);
          var hasFirstValue = false;
          source.subscribe(createOperatorSubscriber(subscriber, function(value) {
            values[i3] = value;
            if (!hasFirstValue) {
              hasFirstValue = true;
              remainingFirstValues--;
            }
            if (!remainingFirstValues) {
              subscriber.next(valueTransform(values.slice()));
            }
          }, function() {
            if (!--active) {
              subscriber.complete();
            }
          }));
        }, subscriber);
      };
      for (var i2 = 0; i2 < length; i2++) {
        _loop_1(i2);
      }
    }, subscriber);
  };
}
function maybeSchedule(scheduler, execute, subscription) {
  if (scheduler) {
    executeSchedule(subscription, scheduler, execute);
  } else {
    execute();
  }
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand3, innerSubScheduler, additionalFinalizer) {
  var buffer2 = [];
  var active = 0;
  var index = 0;
  var isComplete = false;
  var checkComplete = function() {
    if (isComplete && !buffer2.length && !active) {
      subscriber.complete();
    }
  };
  var outerNext = function(value) {
    return active < concurrent ? doInnerSub(value) : buffer2.push(value);
  };
  var doInnerSub = function(value) {
    expand3 && subscriber.next(value);
    active++;
    var innerComplete = false;
    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
      if (expand3) {
        outerNext(innerValue);
      } else {
        subscriber.next(innerValue);
      }
    }, function() {
      innerComplete = true;
    }, void 0, function() {
      if (innerComplete) {
        try {
          active--;
          var _loop_1 = function() {
            var bufferedValue = buffer2.shift();
            if (innerSubScheduler) {
              executeSchedule(subscriber, innerSubScheduler, function() {
                return doInnerSub(bufferedValue);
              });
            } else {
              doInnerSub(bufferedValue);
            }
          };
          while (buffer2.length && active < concurrent) {
            _loop_1();
          }
          checkComplete();
        } catch (err) {
          subscriber.error(err);
        }
      }
    }));
  };
  source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
    isComplete = true;
    checkComplete();
  }));
  return function() {
    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
function mergeMap(project, resultSelector, concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  if (isFunction(resultSelector)) {
    return mergeMap(function(a, i2) {
      return map(function(b, ii) {
        return resultSelector(a, b, i2, ii);
      })(innerFrom(project(a, i2)));
    }, concurrent);
  } else if (typeof resultSelector === "number") {
    concurrent = resultSelector;
  }
  return operate(function(source, subscriber) {
    return mergeInternals(source, subscriber, project, concurrent);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
function mergeAll(concurrent) {
  if (concurrent === void 0) {
    concurrent = Infinity;
  }
  return mergeMap(identity, concurrent);
}

// node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
function concatAll() {
  return mergeAll(1);
}

// node_modules/rxjs/dist/esm5/internal/observable/concat.js
function concat() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  return concatAll()(from(args, popScheduler(args)));
}

// node_modules/rxjs/dist/esm5/internal/observable/defer.js
function defer(observableFactory) {
  return new Observable(function(subscriber) {
    innerFrom(observableFactory()).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/timer.js
function timer(dueTime, intervalOrScheduler, scheduler) {
  if (dueTime === void 0) {
    dueTime = 0;
  }
  if (scheduler === void 0) {
    scheduler = async;
  }
  var intervalDuration = -1;
  if (intervalOrScheduler != null) {
    if (isScheduler(intervalOrScheduler)) {
      scheduler = intervalOrScheduler;
    } else {
      intervalDuration = intervalOrScheduler;
    }
  }
  return new Observable(function(subscriber) {
    var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;
    if (due < 0) {
      due = 0;
    }
    var n = 0;
    return scheduler.schedule(function() {
      if (!subscriber.closed) {
        subscriber.next(n++);
        if (0 <= intervalDuration) {
          this.schedule(void 0, intervalDuration);
        } else {
          subscriber.complete();
        }
      }
    }, due);
  });
}

// node_modules/rxjs/dist/esm5/internal/observable/merge.js
function merge() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  var sources = args;
  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));
}

// node_modules/rxjs/dist/esm5/internal/observable/never.js
var NEVER = new Observable(noop);

// node_modules/rxjs/dist/esm5/internal/util/argsOrArgArray.js
var isArray3 = Array.isArray;

// node_modules/rxjs/dist/esm5/internal/operators/filter.js
function filter(predicate, thisArg) {
  return operate(function(source, subscriber) {
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      return predicate.call(thisArg, value, index++) && subscriber.next(value);
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/bufferTime.js
function bufferTime(bufferTimeSpan) {
  var _a, _b;
  var otherArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    otherArgs[_i - 1] = arguments[_i];
  }
  var scheduler = (_a = popScheduler(otherArgs)) !== null && _a !== void 0 ? _a : asyncScheduler;
  var bufferCreationInterval = (_b = otherArgs[0]) !== null && _b !== void 0 ? _b : null;
  var maxBufferSize = otherArgs[1] || Infinity;
  return operate(function(source, subscriber) {
    var bufferRecords = [];
    var restartOnEmit = false;
    var emit = function(record) {
      var buffer2 = record.buffer, subs = record.subs;
      subs.unsubscribe();
      arrRemove(bufferRecords, record);
      subscriber.next(buffer2);
      restartOnEmit && startBuffer();
    };
    var startBuffer = function() {
      if (bufferRecords) {
        var subs = new Subscription();
        subscriber.add(subs);
        var buffer2 = [];
        var record_1 = {
          buffer: buffer2,
          subs
        };
        bufferRecords.push(record_1);
        executeSchedule(subs, scheduler, function() {
          return emit(record_1);
        }, bufferTimeSpan);
      }
    };
    if (bufferCreationInterval !== null && bufferCreationInterval >= 0) {
      executeSchedule(subscriber, scheduler, startBuffer, bufferCreationInterval, true);
    } else {
      restartOnEmit = true;
    }
    startBuffer();
    var bufferTimeSubscriber = createOperatorSubscriber(subscriber, function(value) {
      var e_1, _a2;
      var recordsCopy = bufferRecords.slice();
      try {
        for (var recordsCopy_1 = __values(recordsCopy), recordsCopy_1_1 = recordsCopy_1.next(); !recordsCopy_1_1.done; recordsCopy_1_1 = recordsCopy_1.next()) {
          var record = recordsCopy_1_1.value;
          var buffer2 = record.buffer;
          buffer2.push(value);
          maxBufferSize <= buffer2.length && emit(record);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (recordsCopy_1_1 && !recordsCopy_1_1.done && (_a2 = recordsCopy_1.return)) _a2.call(recordsCopy_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }, function() {
      while (bufferRecords === null || bufferRecords === void 0 ? void 0 : bufferRecords.length) {
        subscriber.next(bufferRecords.shift().buffer);
      }
      bufferTimeSubscriber === null || bufferTimeSubscriber === void 0 ? void 0 : bufferTimeSubscriber.unsubscribe();
      subscriber.complete();
      subscriber.unsubscribe();
    }, void 0, function() {
      return bufferRecords = null;
    });
    source.subscribe(bufferTimeSubscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/catchError.js
function catchError(selector) {
  return operate(function(source, subscriber) {
    var innerSub = null;
    var syncUnsub = false;
    var handledResult;
    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, function(err) {
      handledResult = innerFrom(selector(err, catchError(selector)(source)));
      if (innerSub) {
        innerSub.unsubscribe();
        innerSub = null;
        handledResult.subscribe(subscriber);
      } else {
        syncUnsub = true;
      }
    }));
    if (syncUnsub) {
      innerSub.unsubscribe();
      innerSub = null;
      handledResult.subscribe(subscriber);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scanInternals.js
function scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {
  return function(source, subscriber) {
    var hasState = hasSeed;
    var state = seed;
    var index = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var i2 = index++;
      state = hasState ? accumulator(state, value, i2) : (hasState = true, value);
      emitOnNext && subscriber.next(state);
    }, emitBeforeComplete && function() {
      hasState && subscriber.next(state);
      subscriber.complete();
    }));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/take.js
function take(count2) {
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var seen = 0;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      if (++seen <= count2) {
        subscriber.next(value);
        if (count2 <= seen) {
          subscriber.complete();
        }
      }
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinct.js
function distinct(keySelector, flushes) {
  return operate(function(source, subscriber) {
    var distinctKeys = /* @__PURE__ */ new Set();
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var key = keySelector ? keySelector(value) : value;
      if (!distinctKeys.has(key)) {
        distinctKeys.add(key);
        subscriber.next(value);
      }
    }));
    flushes && innerFrom(flushes).subscribe(createOperatorSubscriber(subscriber, function() {
      return distinctKeys.clear();
    }, noop));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
function distinctUntilChanged(comparator, keySelector) {
  if (keySelector === void 0) {
    keySelector = identity;
  }
  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
  return operate(function(source, subscriber) {
    var previousKey;
    var first2 = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var currentKey = keySelector(value);
      if (first2 || !comparator(previousKey, currentKey)) {
        first2 = false;
        previousKey = currentKey;
        subscriber.next(value);
      }
    }));
  });
}
function defaultCompare(a, b) {
  return a === b;
}

// node_modules/rxjs/dist/esm5/internal/operators/endWith.js
function endWith() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  return function(source) {
    return concat(source, of.apply(void 0, __spreadArray([], __read(values))));
  };
}

// node_modules/rxjs/dist/esm5/internal/operators/finalize.js
function finalize(callback) {
  return operate(function(source, subscriber) {
    try {
      source.subscribe(subscriber);
    } finally {
      subscriber.add(callback);
    }
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/merge.js
function merge2() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var scheduler = popScheduler(args);
  var concurrent = popNumber(args, Infinity);
  return operate(function(source, subscriber) {
    mergeAll(concurrent)(from(__spreadArray([source], __read(args)), scheduler)).subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/mergeWith.js
function mergeWith() {
  var otherSources = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    otherSources[_i] = arguments[_i];
  }
  return merge2.apply(void 0, __spreadArray([], __read(otherSources)));
}

// node_modules/rxjs/dist/esm5/internal/operators/repeat.js
function repeat(countOrConfig) {
  var _a;
  var count2 = Infinity;
  var delay2;
  if (countOrConfig != null) {
    if (typeof countOrConfig === "object") {
      _a = countOrConfig.count, count2 = _a === void 0 ? Infinity : _a, delay2 = countOrConfig.delay;
    } else {
      count2 = countOrConfig;
    }
  }
  return count2 <= 0 ? function() {
    return EMPTY;
  } : operate(function(source, subscriber) {
    var soFar = 0;
    var sourceSub;
    var resubscribe = function() {
      sourceSub === null || sourceSub === void 0 ? void 0 : sourceSub.unsubscribe();
      sourceSub = null;
      if (delay2 != null) {
        var notifier = typeof delay2 === "number" ? timer(delay2) : innerFrom(delay2(soFar));
        var notifierSubscriber_1 = createOperatorSubscriber(subscriber, function() {
          notifierSubscriber_1.unsubscribe();
          subscribeToSource();
        });
        notifier.subscribe(notifierSubscriber_1);
      } else {
        subscribeToSource();
      }
    };
    var subscribeToSource = function() {
      var syncUnsub = false;
      sourceSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, function() {
        if (++soFar < count2) {
          if (sourceSub) {
            resubscribe();
          } else {
            syncUnsub = true;
          }
        } else {
          subscriber.complete();
        }
      }));
      if (syncUnsub) {
        resubscribe();
      }
    };
    subscribeToSource();
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/scan.js
function scan(accumulator, seed) {
  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));
}

// node_modules/rxjs/dist/esm5/internal/operators/share.js
function share(options) {
  if (options === void 0) {
    options = {};
  }
  var _a = options.connector, connector = _a === void 0 ? function() {
    return new Subject();
  } : _a, _b = options.resetOnError, resetOnError = _b === void 0 ? true : _b, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
  return function(wrapperSource) {
    var connection;
    var resetConnection;
    var subject;
    var refCount2 = 0;
    var hasCompleted = false;
    var hasErrored = false;
    var cancelReset = function() {
      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
      resetConnection = void 0;
    };
    var reset = function() {
      cancelReset();
      connection = subject = void 0;
      hasCompleted = hasErrored = false;
    };
    var resetAndUnsubscribe = function() {
      var conn = connection;
      reset();
      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
    };
    return operate(function(source, subscriber) {
      refCount2++;
      if (!hasErrored && !hasCompleted) {
        cancelReset();
      }
      var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
      subscriber.add(function() {
        refCount2--;
        if (refCount2 === 0 && !hasErrored && !hasCompleted) {
          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
        }
      });
      dest.subscribe(subscriber);
      if (!connection && refCount2 > 0) {
        connection = new SafeSubscriber({
          next: function(value) {
            return dest.next(value);
          },
          error: function(err) {
            hasErrored = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnError, err);
            dest.error(err);
          },
          complete: function() {
            hasCompleted = true;
            cancelReset();
            resetConnection = handleReset(reset, resetOnComplete);
            dest.complete();
          }
        });
        innerFrom(source).subscribe(connection);
      }
    })(wrapperSource);
  };
}
function handleReset(reset, on) {
  var args = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    args[_i - 2] = arguments[_i];
  }
  if (on === true) {
    reset();
    return;
  }
  if (on === false) {
    return;
  }
  var onSubscriber = new SafeSubscriber({
    next: function() {
      onSubscriber.unsubscribe();
      reset();
    }
  });
  return innerFrom(on.apply(void 0, __spreadArray([], __read(args)))).subscribe(onSubscriber);
}

// node_modules/rxjs/dist/esm5/internal/operators/switchMap.js
function switchMap(project, resultSelector) {
  return operate(function(source, subscriber) {
    var innerSubscriber = null;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      return isComplete && !innerSubscriber && subscriber.complete();
    };
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
      var innerIndex = 0;
      var outerIndex = index++;
      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, function(innerValue) {
        return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
      }, function() {
        innerSubscriber = null;
        checkComplete();
      }));
    }, function() {
      isComplete = true;
      checkComplete();
    }));
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
function takeUntil(notifier) {
  return operate(function(source, subscriber) {
    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
      return subscriber.complete();
    }, noop));
    !subscriber.closed && source.subscribe(subscriber);
  });
}

// node_modules/rxjs/dist/esm5/internal/operators/tap.js
function tap(observerOrNext, error, complete) {
  var tapObserver = isFunction(observerOrNext) || error || complete ? { next: observerOrNext, error, complete } : observerOrNext;
  return tapObserver ? operate(function(source, subscriber) {
    var _a;
    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
    var isUnsub = true;
    source.subscribe(createOperatorSubscriber(subscriber, function(value) {
      var _a2;
      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);
      subscriber.next(value);
    }, function() {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      subscriber.complete();
    }, function(err) {
      var _a2;
      isUnsub = false;
      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);
      subscriber.error(err);
    }, function() {
      var _a2, _b;
      if (isUnsub) {
        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);
      }
      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
    }));
  }) : identity;
}

// node_modules/applesauce-core/dist/event-store/event-store.js
var import_hash_sum = __toESM(require_hash_sum(), 1);

// node_modules/applesauce-core/dist/helpers/tags.js
function isNameValueTag(tag, name) {
  return tag[0] !== void 0 && tag[1] !== void 0 && (name ? tag[0] === name : true);
}
function isETag(tag) {
  return isNameValueTag(tag, "e");
}
function isPTag(tag) {
  return isNameValueTag(tag, "p");
}
function isRTag(tag) {
  return isNameValueTag(tag, "r");
}
function isDTag(tag) {
  return isNameValueTag(tag, "d");
}
function isATag(tag) {
  return isNameValueTag(tag, "a");
}
function isTTag(tag) {
  return isNameValueTag(tag, "t");
}
var processTags = (tags, ...fns) => {
  return fns.reduce((step, fn) => {
    const next = [];
    for (const value of step) {
      try {
        const result = fn(value);
        if (result === void 0)
          continue;
        next.push(result);
      } catch (error) {
      }
    }
    return next;
  }, tags);
};

// node_modules/applesauce-core/dist/helpers/delete.js
function getDeleteIds(deleteEvent) {
  return deleteEvent.tags.filter(isETag).map((t) => t[1]);
}
function getDeleteCoordinates(deleteEvent) {
  return deleteEvent.tags.filter(isATag).map((t) => t[1]);
}

// node_modules/applesauce-core/dist/helpers/cache.js
function getCachedValue(event, symbol) {
  return Reflect.get(event, symbol);
}
function setCachedValue(event, symbol, value) {
  Reflect.set(event, symbol, value);
}
function getOrComputeCachedValue(event, symbol, compute) {
  if (Reflect.has(event, symbol)) {
    return Reflect.get(event, symbol);
  } else {
    const value = compute();
    Reflect.set(event, symbol, value);
    return value;
  }
}

// node_modules/applesauce-core/dist/helpers/event.js
var EventStoreSymbol = Symbol.for("event-store");
var EventUIDSymbol = Symbol.for("event-uid");
var ReplaceableAddressSymbol = Symbol.for("replaceable-address");
var FromCacheSymbol = Symbol.for("from-cache");
var ReplaceableIdentifierSymbol = Symbol.for("replaceable-identifier");
function isEvent(event) {
  var _a;
  if (event === void 0 || event === null)
    return false;
  return ((_a = event.id) == null ? void 0 : _a.length) === 64 && typeof event.sig === "string" && typeof event.pubkey === "string" && event.pubkey.length === 64 && typeof event.content === "string" && Array.isArray(event.tags) && typeof event.created_at === "number" && event.created_at > 0;
}
function isReplaceable(kind) {
  return isReplaceableKind2(kind) || isAddressableKind2(kind);
}
function getEventUID(event) {
  let uid = Reflect.get(event, EventUIDSymbol);
  if (!uid) {
    if (isReplaceable(event.kind))
      uid = getReplaceableAddress(event);
    else
      uid = event.id;
    Reflect.set(event, EventUIDSymbol, uid);
  }
  return uid;
}
function getReplaceableAddress(event) {
  if (!isReplaceable(event.kind))
    throw new Error("Event is not replaceable or addressable");
  return getOrComputeCachedValue(event, ReplaceableAddressSymbol, () => {
    const identifier = isAddressableKind2(event.kind) ? getReplaceableIdentifier(event) : void 0;
    return createReplaceableAddress(event.kind, event.pubkey, identifier);
  });
}
function createReplaceableAddress(kind, pubkey, identifier) {
  return kind + ":" + pubkey + ":" + (identifier ?? "");
}
var getReplaceableUID = createReplaceableAddress;
function fakeVerifyEvent(event) {
  event[verifiedSymbol] = true;
  return true;
}
function markFromCache(event) {
  Reflect.set(event, FromCacheSymbol, true);
}
function isFromCache(event) {
  return Reflect.get(event, FromCacheSymbol) === true;
}
function getParentEventStore(event) {
  return Reflect.get(event, EventStoreSymbol);
}
function notifyEventUpdate(event) {
  const eventStore = getParentEventStore(event);
  if (eventStore)
    eventStore.update(event);
}
function getReplaceableIdentifier(event) {
  return getOrComputeCachedValue(event, ReplaceableIdentifierSymbol, () => {
    var _a;
    return ((_a = event.tags.find((t) => t[0] === "d")) == null ? void 0 : _a[1]) ?? "";
  });
}
function isProtectedEvent(event) {
  return event.tags.some((t) => t[0] === "-");
}

// node_modules/applesauce-core/dist/helpers/time.js
function unixNow() {
  return Math.round(Date.now() / 1e3);
}

// node_modules/applesauce-core/dist/helpers/expiration.js
var ExpirationTimestampSymbol = Symbol("expiration-timestamp");
function getExpirationTimestamp(event) {
  return getOrComputeCachedValue(event, ExpirationTimestampSymbol, () => {
    var _a;
    const expiration = (_a = event.tags.find((t) => t[0] === "expiration")) == null ? void 0 : _a[1];
    return expiration ? parseInt(expiration) : void 0;
  });
}
function isExpired(event) {
  const expiration = getExpirationTimestamp(event);
  return expiration ? unixNow() > expiration : false;
}

// node_modules/applesauce-core/dist/helpers/filter.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// node_modules/applesauce-core/dist/helpers/encrypted-content.js
var EncryptedContentSymbol = Symbol.for("encrypted-content");
var EventContentEncryptionMethod = {
  [kinds_exports.EncryptedDirectMessage]: "nip04",
  [kinds_exports.Seal]: "nip44",
  [kinds_exports.GiftWrap]: "nip44"
};
function setEncryptedContentEncryptionMethod(kind, method) {
  EventContentEncryptionMethod[kind] = method;
  return kind;
}
function getEncryptedContentEncryptionMethods(kind, signer, override) {
  const method = override ?? EventContentEncryptionMethod[kind];
  if (!method)
    throw new Error(`Event kind ${kind} does not support encrypted content`);
  const encryption = signer[method];
  if (!encryption)
    throw new Error(`Signer does not support ${method} encryption`);
  return encryption;
}
function canHaveEncryptedContent(kind) {
  return EventContentEncryptionMethod[kind] !== void 0;
}
function hasEncryptedContent(event) {
  return event.content.length > 0;
}
function getEncryptedContent(event) {
  return Reflect.get(event, EncryptedContentSymbol);
}
function isEncryptedContentLocked(event) {
  return Reflect.has(event, EncryptedContentSymbol) === false;
}
async function unlockEncryptedContent(event, pubkey, signer) {
  const encryption = getEncryptedContentEncryptionMethods(event.kind, signer);
  const plaintext = await encryption.decrypt(pubkey, event.content);
  setEncryptedContentCache(event, plaintext);
  return plaintext;
}
function setEncryptedContentCache(event, plaintext) {
  Reflect.set(event, EncryptedContentSymbol, plaintext);
  if (isEvent(event))
    notifyEventUpdate(event);
}
function lockEncryptedContent(event) {
  Reflect.deleteProperty(event, EncryptedContentSymbol);
  if (isEvent(event))
    notifyEventUpdate(event);
}

// node_modules/applesauce-core/dist/helpers/hidden-content.js
var HiddenContentSymbol = EncryptedContentSymbol;
var getHiddenContentEncryptionMethods = getEncryptedContentEncryptionMethods;
var HiddenContentKinds = /* @__PURE__ */ new Set([setEncryptedContentEncryptionMethod(kinds_exports.DraftLong, "nip04")]);
function setHiddenContentEncryptionMethod(kind, method) {
  HiddenContentKinds.add(setEncryptedContentEncryptionMethod(kind, method));
  return kind;
}
function canHaveHiddenContent(kind) {
  return canHaveEncryptedContent(kind) && HiddenContentKinds.has(kind);
}
function hasHiddenContent(event) {
  return canHaveHiddenContent(event.kind) && hasEncryptedContent(event);
}
function isHiddenContentLocked(event) {
  return isEncryptedContentLocked(event);
}
function getHiddenContent(event) {
  if (!canHaveHiddenContent(event.kind) || isHiddenContentLocked(event))
    return void 0;
  return getEncryptedContent(event);
}
async function unlockHiddenContent(event, signer, override) {
  if (!canHaveHiddenContent(event.kind))
    throw new Error("Event kind does not support hidden content");
  const encryption = getEncryptedContentEncryptionMethods(event.kind, signer, override);
  const plaintext = await encryption.decrypt(event.pubkey, event.content);
  setHiddenContentCache(event, plaintext);
  return plaintext;
}
function setHiddenContentCache(event, plaintext) {
  if (!canHaveHiddenContent(event.kind))
    throw new Error("Event kind does not support hidden content");
  setEncryptedContentCache(event, plaintext);
}
function lockHiddenContent(event) {
  lockEncryptedContent(event);
}

// node_modules/applesauce-core/dist/helpers/url.js
var convertToUrl = (url) => url instanceof URL ? url : new URL(url);
var getURLFilename = (url) => {
  var _a, _b;
  return ((_a = url.pathname.split("/").pop()) == null ? void 0 : _a.toLocaleLowerCase()) || ((_b = url.searchParams.get("filename")) == null ? void 0 : _b.toLocaleLowerCase());
};
var IMAGE_EXT = [".svg", ".gif", ".png", ".jpg", ".jpeg", ".webp", ".avif"];
var VIDEO_EXT = [".mp4", ".mkv", ".webm", ".mov"];
var STREAM_EXT = [".m3u8"];
var AUDIO_EXT = [".mp3", ".wav", ".ogg", ".aac", ".m4a"];
function isImageURL(url) {
  url = convertToUrl(url);
  const filename = getURLFilename(url);
  return !!filename && IMAGE_EXT.some((ext) => filename.endsWith(ext));
}
function isVideoURL(url) {
  url = convertToUrl(url);
  const filename = getURLFilename(url);
  return !!filename && VIDEO_EXT.some((ext) => filename.endsWith(ext));
}
function isStreamURL(url) {
  url = convertToUrl(url);
  const filename = getURLFilename(url);
  return !!filename && STREAM_EXT.some((ext) => filename.endsWith(ext));
}
function isAudioURL(url) {
  url = convertToUrl(url);
  const filename = getURLFilename(url);
  return !!filename && AUDIO_EXT.some((ext) => filename.endsWith(ext));
}
function isSameURL(a, b) {
  try {
    a = normalizeURL2(a);
    b = normalizeURL2(b);
    return a === b;
  } catch (error) {
    return false;
  }
}
function ensureProtocol(url, protocol = "https:") {
  if (/^[a-zA-Z][a-zA-Z0-9+.-]+:/.test(url))
    return url;
  return protocol + "//" + url;
}
function ensureWebSocketURL(url) {
  const p = typeof url === "string" ? new URL(ensureProtocol(url, "wss:")) : new URL(url);
  if (p.protocol === "http:")
    p.protocol = "ws:";
  else if (p.protocol === "https:")
    p.protocol = "wss:";
  else
    p.protocol = "wss:";
  return typeof url === "string" ? p.toString() : p;
}
function ensureHttpURL(url) {
  const p = typeof url === "string" ? new URL(ensureProtocol(url, "http:")) : new URL(url);
  if (p.protocol === "ws:")
    p.protocol = "http:";
  else if (p.protocol === "wss:")
    p.protocol = "https:";
  else
    p.protocol = "https:";
  return typeof url === "string" ? p.toString() : p;
}
function normalizeURL2(url) {
  let p = new URL(url);
  p.pathname = p.pathname.replace(/\/+/g, "/");
  if (p.port === "80" && (p.protocol === "ws:" || p.protocol === "http:") || p.port === "443" && (p.protocol === "wss:" || p.protocol === "https:"))
    p.port = "";
  return typeof url === "string" ? p.toString() : p;
}

// node_modules/applesauce-core/dist/helpers/groups.js
var GROUPS_LIST_KIND = 10009;
var GROUP_MESSAGE_KIND = 9;
function decodeGroupPointer(str) {
  let [relay, id] = str.split("'");
  if (!relay)
    throw new Error("Group pointer missing relay");
  if (!relay.match(/^wss?:/))
    relay = `wss://${relay}`;
  relay = normalizeURL2(relay);
  return { relay, id: id || "_" };
}
function encodeGroupPointer(pointer) {
  const hostname = URL.canParse(pointer.relay) ? new URL(pointer.relay).hostname : pointer.relay;
  return `${hostname}'${pointer.id}`;
}
var GroupsPublicSymbol = Symbol.for("groups-public");
var GroupsHiddenSymbol = Symbol.for("groups-hidden");
function getGroupPointerFromHTag(tag) {
  const [_, id, relay] = tag;
  if (!id || !relay)
    return void 0;
  return { id, relay };
}
function getGroupPointerFromGroupTag(tag) {
  const [_, id, relay, name] = tag;
  return { id, relay, name };
}
function getPublicGroups(bookmark) {
  return getOrComputeCachedValue(bookmark, GroupsPublicSymbol, () => processTags(bookmark.tags.filter((t) => t[0] === "group"), getGroupPointerFromGroupTag));
}
function getHiddenGroups(bookmark) {
  return getOrComputeCachedValue(bookmark, GroupsHiddenSymbol, () => {
    const tags = getHiddenTags(bookmark);
    return tags && processTags(bookmark.tags.filter((t) => t[0] === "group"), getGroupPointerFromGroupTag);
  });
}

// node_modules/applesauce-core/dist/helpers/hidden-tags.js
var HiddenTagsSymbol = Symbol.for("hidden-tags");
var HiddenTagsKinds = /* @__PURE__ */ new Set([
  // NIP-51 lists
  setHiddenContentEncryptionMethod(kinds_exports.BookmarkList, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.InterestsList, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.Mutelist, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.CommunitiesList, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.PublicChatsList, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.SearchRelaysList, "nip04"),
  setHiddenContentEncryptionMethod(GROUPS_LIST_KIND, "nip04"),
  // NIP-51 sets
  setHiddenContentEncryptionMethod(kinds_exports.Bookmarksets, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.Relaysets, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.Followsets, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.Curationsets, "nip04"),
  setHiddenContentEncryptionMethod(kinds_exports.Interestsets, "nip04")
]);
function canHaveHiddenTags(kind) {
  return canHaveHiddenContent(kind) && HiddenTagsKinds.has(kind);
}
function setHiddenTagsEncryptionMethod(kind, method) {
  HiddenTagsKinds.add(setHiddenContentEncryptionMethod(kind, method));
  return kind;
}
function hasHiddenTags(event) {
  return canHaveHiddenTags(event.kind) && hasHiddenContent(event);
}
function getHiddenTags(event) {
  if (!canHaveHiddenTags(event.kind) || isHiddenTagsLocked(event))
    return void 0;
  return getOrComputeCachedValue(event, HiddenTagsSymbol, () => {
    const plaintext = getHiddenContent(event);
    const parsed = JSON.parse(plaintext);
    if (!Array.isArray(parsed))
      throw new Error("Content is not an array of tags");
    return parsed.filter((t) => Array.isArray(t)).map((t) => t.map((v) => String(v)));
  });
}
function isHiddenTagsLocked(event) {
  return isHiddenContentLocked(event);
}
function getHiddenTagsEncryptionMethods(kind, signer) {
  return getHiddenContentEncryptionMethods(kind, signer);
}
async function unlockHiddenTags(event, signer, override) {
  if (!canHaveHiddenTags(event.kind))
    throw new Error("Event kind does not support hidden tags");
  if (isHiddenContentLocked(event))
    await unlockHiddenContent(event, signer, override);
  return getHiddenTags(event);
}
function setHiddenTagsCache(event, tags) {
  if (!canHaveHiddenTags(event.kind))
    throw new Error("Event kind does not support hidden tags");
  const plaintext = JSON.stringify(tags);
  setHiddenContentCache(event, plaintext);
}
function lockHiddenTags(event) {
  Reflect.deleteProperty(event, HiddenTagsSymbol);
  lockHiddenContent(event);
}

// node_modules/applesauce-core/dist/helpers/event-tags.js
var LETTERS = "abcdefghijklmnopqrstuvwxyz";
var INDEXABLE_TAGS = new Set((LETTERS + LETTERS.toUpperCase()).split(""));
var EventIndexableTagsSymbol = Symbol.for("indexable-tags");
function getTagValue(event, name) {
  var _a, _b;
  const hidden = getHiddenTags(event);
  const hiddenValue = (_a = hidden == null ? void 0 : hidden.find((t) => t[0] === name)) == null ? void 0 : _a[1];
  if (hiddenValue)
    return hiddenValue;
  return (_b = event.tags.find((t) => t[0] === name)) == null ? void 0 : _b[1];
}
function getIndexableTags(event) {
  let indexable = Reflect.get(event, EventIndexableTagsSymbol);
  if (!indexable) {
    const tags = /* @__PURE__ */ new Set();
    for (const tag of event.tags) {
      if (tag.length >= 2 && tag[0].length === 1 && INDEXABLE_TAGS.has(tag[0])) {
        tags.add(tag[0] + ":" + tag[1]);
      }
    }
    indexable = tags;
    Reflect.set(event, EventIndexableTagsSymbol, tags);
  }
  return indexable;
}

// node_modules/applesauce-core/dist/helpers/filter.js
function matchFilter(filter2, event) {
  if (filter2.ids && filter2.ids.indexOf(event.id) === -1) {
    return false;
  }
  if (filter2.kinds && filter2.kinds.indexOf(event.kind) === -1) {
    return false;
  }
  if (filter2.authors && filter2.authors.indexOf(event.pubkey) === -1) {
    return false;
  }
  for (let f in filter2) {
    if (f[0] === "#") {
      let tagName = f.slice(1);
      let values = filter2[f];
      if (values) {
        const tags = getIndexableTags(event);
        if (values.some((v) => tags.has(tagName + ":" + v)) === false)
          return false;
      }
    }
  }
  if (filter2.since && event.created_at < filter2.since)
    return false;
  if (filter2.until && event.created_at > filter2.until)
    return false;
  return true;
}
function matchFilters(filters, event) {
  for (let i2 = 0; i2 < filters.length; i2++) {
    if (matchFilter(filters[i2], event)) {
      return true;
    }
  }
  return false;
}
function mergeFilters(...filters) {
  let result = {};
  for (let i2 = 0; i2 < filters.length; i2++) {
    let filter2 = filters[i2];
    Object.entries(filter2).forEach(([property, values]) => {
      if (values === void 0)
        return;
      if (property === "kinds" || property === "ids" || property === "authors" || property[0] === "#") {
        result[property] = result[property] || [];
        for (let v = 0; v < values.length; v++) {
          let value = values[v];
          if (!result[property].includes(value))
            result[property].push(value);
        }
      }
    });
    if (filter2.limit && (!result.limit || filter2.limit > result.limit))
      result.limit = filter2.limit;
    if (filter2.until && (!result.until || filter2.until > result.until))
      result.until = filter2.until;
    if (filter2.since && (!result.since || filter2.since < result.since))
      result.since = filter2.since;
  }
  return result;
}
function isFilterEqual(a, b) {
  return (0, import_fast_deep_equal.default)(a, b);
}

// node_modules/nostr-tools/lib/esm/nip19.js
var utf8Decoder2 = new TextDecoder("utf-8");
var utf8Encoder2 = new TextEncoder();
var Bech32MaxSize2 = 5e3;
function integerToUint8Array2(number4) {
  const uint8Array = new Uint8Array(4);
  uint8Array[0] = number4 >> 24 & 255;
  uint8Array[1] = number4 >> 16 & 255;
  uint8Array[2] = number4 >> 8 & 255;
  uint8Array[3] = number4 & 255;
  return uint8Array;
}
function decode2(code) {
  var _a, _b, _c, _d, _e, _f, _g;
  let { prefix, words } = bech32.decode(code, Bech32MaxSize2);
  let data = new Uint8Array(bech32.fromWords(words));
  switch (prefix) {
    case "nprofile": {
      let tlv = parseTLV2(data);
      if (!((_a = tlv[0]) == null ? void 0 : _a[0]))
        throw new Error("missing TLV 0 for nprofile");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      return {
        type: "nprofile",
        data: {
          pubkey: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder2.decode(d)) : []
        }
      };
    }
    case "nevent": {
      let tlv = parseTLV2(data);
      if (!((_b = tlv[0]) == null ? void 0 : _b[0]))
        throw new Error("missing TLV 0 for nevent");
      if (tlv[0][0].length !== 32)
        throw new Error("TLV 0 should be 32 bytes");
      if (tlv[2] && tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (tlv[3] && tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "nevent",
        data: {
          id: bytesToHex2(tlv[0][0]),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder2.decode(d)) : [],
          author: ((_c = tlv[2]) == null ? void 0 : _c[0]) ? bytesToHex2(tlv[2][0]) : void 0,
          kind: ((_d = tlv[3]) == null ? void 0 : _d[0]) ? parseInt(bytesToHex2(tlv[3][0]), 16) : void 0
        }
      };
    }
    case "naddr": {
      let tlv = parseTLV2(data);
      if (!((_e = tlv[0]) == null ? void 0 : _e[0]))
        throw new Error("missing TLV 0 for naddr");
      if (!((_f = tlv[2]) == null ? void 0 : _f[0]))
        throw new Error("missing TLV 2 for naddr");
      if (tlv[2][0].length !== 32)
        throw new Error("TLV 2 should be 32 bytes");
      if (!((_g = tlv[3]) == null ? void 0 : _g[0]))
        throw new Error("missing TLV 3 for naddr");
      if (tlv[3][0].length !== 4)
        throw new Error("TLV 3 should be 4 bytes");
      return {
        type: "naddr",
        data: {
          identifier: utf8Decoder2.decode(tlv[0][0]),
          pubkey: bytesToHex2(tlv[2][0]),
          kind: parseInt(bytesToHex2(tlv[3][0]), 16),
          relays: tlv[1] ? tlv[1].map((d) => utf8Decoder2.decode(d)) : []
        }
      };
    }
    case "nsec":
      return { type: prefix, data };
    case "npub":
    case "note":
      return { type: prefix, data: bytesToHex2(data) };
    default:
      throw new Error(`unknown prefix ${prefix}`);
  }
}
function parseTLV2(data) {
  let result = {};
  let rest = data;
  while (rest.length > 0) {
    let t = rest[0];
    let l = rest[1];
    let v = rest.slice(2, 2 + l);
    rest = rest.slice(2 + l);
    if (v.length < l)
      throw new Error(`not enough data to read on TLV ${t}`);
    result[t] = result[t] || [];
    result[t].push(v);
  }
  return result;
}
function nsecEncode2(key) {
  return encodeBytes2("nsec", key);
}
function npubEncode2(hex3) {
  return encodeBytes2("npub", hexToBytes2(hex3));
}
function noteEncode2(hex3) {
  return encodeBytes2("note", hexToBytes2(hex3));
}
function encodeBech322(prefix, data) {
  let words = bech32.toWords(data);
  return bech32.encode(prefix, words, Bech32MaxSize2);
}
function encodeBytes2(prefix, bytes4) {
  return encodeBech322(prefix, bytes4);
}
function nprofileEncode2(profile) {
  let data = encodeTLV2({
    0: [hexToBytes2(profile.pubkey)],
    1: (profile.relays || []).map((url) => utf8Encoder2.encode(url))
  });
  return encodeBech322("nprofile", data);
}
function neventEncode2(event) {
  let kindArray;
  if (event.kind !== void 0) {
    kindArray = integerToUint8Array2(event.kind);
  }
  let data = encodeTLV2({
    0: [hexToBytes2(event.id)],
    1: (event.relays || []).map((url) => utf8Encoder2.encode(url)),
    2: event.author ? [hexToBytes2(event.author)] : [],
    3: kindArray ? [new Uint8Array(kindArray)] : []
  });
  return encodeBech322("nevent", data);
}
function naddrEncode2(addr) {
  let kind = new ArrayBuffer(4);
  new DataView(kind).setUint32(0, addr.kind, false);
  let data = encodeTLV2({
    0: [utf8Encoder2.encode(addr.identifier)],
    1: (addr.relays || []).map((url) => utf8Encoder2.encode(url)),
    2: [hexToBytes2(addr.pubkey)],
    3: [new Uint8Array(kind)]
  });
  return encodeBech322("naddr", data);
}
function encodeTLV2(tlv) {
  let entries = [];
  Object.entries(tlv).reverse().forEach(([t, vs]) => {
    vs.forEach((v) => {
      let entry = new Uint8Array(v.length + 2);
      entry.set([parseInt(t)], 0);
      entry.set([v.length], 1);
      entry.set(v, 2);
      entries.push(entry);
    });
  });
  return concatBytes3(...entries);
}

// node_modules/applesauce-core/dist/helpers/relays.js
var SeenRelaysSymbol = Symbol.for("seen-relays");
function addSeenRelay(event, relay) {
  if (!event[SeenRelaysSymbol])
    event[SeenRelaysSymbol] = /* @__PURE__ */ new Set();
  event[SeenRelaysSymbol].add(relay);
  return event[SeenRelaysSymbol];
}
function getSeenRelays(event) {
  return event[SeenRelaysSymbol];
}
var WEBSOCKET_URL_CHECK = /^wss?:\/\/([-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}|localhost)\b([-a-zA-Z0-9()@:%_\+.~#?&\/\/=]*)$/;
function isSafeRelayURL(relay) {
  return relay.length >= 8 && WEBSOCKET_URL_CHECK.test(relay);
}
function mergeRelaySets(...sources) {
  const set = /* @__PURE__ */ new Set();
  for (const src of sources) {
    if (!src)
      continue;
    for (const url of src) {
      try {
        const safe = normalizeURL2(url).toString();
        if (safe)
          set.add(safe);
      } catch (error) {
      }
    }
  }
  return Array.from(set);
}

// node_modules/applesauce-core/dist/helpers/string.js
function isHex(str) {
  if (str == null ? void 0 : str.match(/^[0-9a-f]+$/i))
    return true;
  return false;
}
function isHexKey(key) {
  var _a;
  if ((_a = key == null ? void 0 : key.toLowerCase()) == null ? void 0 : _a.match(/^[0-9a-f]{64}$/))
    return true;
  return false;
}
function stripInvisibleChar(str) {
  return str && str.replaceAll(/[\p{Cf}\p{Zs}]/gu, "");
}

// node_modules/@noble/hashes/esm/crypto.js
var crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/utils.js
function isBytes3(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes3(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min2 = instance.outputLen;
  if (out.length < min2) {
    throw new Error("digestInto() expects output buffer of length at least " + min2);
  }
}
function clean(...arrays) {
  for (let i2 = 0; i2 < arrays.length; i2++) {
    arrays[i2].fill(0);
  }
}
function createView4(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr3(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE4 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (() => (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
))();
var hexes5 = Array.from({ length: 256 }, (_, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex3(bytes4) {
  abytes(bytes4);
  if (hasHexBuiltin)
    return bytes4.toHex();
  let hex3 = "";
  for (let i2 = 0; i2 < bytes4.length; i2++) {
    hex3 += hexes5[bytes4[i2]];
  }
  return hex3;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes3(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex3);
  const hl = hex3.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex3.charCodeAt(hi));
    const n2 = asciiToBase16(hex3.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex3[hi] + hex3[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes5(str) {
  if (typeof str !== "string")
    throw new Error("string expected");
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes4(data) {
  if (typeof data === "string")
    data = utf8ToBytes5(data);
  abytes(data);
  return data;
}
var Hash3 = class {
};
function createHasher2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes4(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes3(bytesLength = 32) {
  if (crypto3 && typeof crypto3.getRandomValues === "function") {
    return crypto3.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto3 && typeof crypto3.randomBytes === "function") {
    return Uint8Array.from(crypto3.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/applesauce-core/dist/helpers/pointers.js
function parseCoordinate(a, requireD = false, silent = true) {
  const parts = a.split(":");
  const kind = parts[0] ? parseInt(parts[0]) : void 0;
  const pubkey = parts[1];
  const d = parts[2];
  if (kind === void 0) {
    if (silent)
      return null;
    else
      throw new Error("Missing kind");
  }
  if (pubkey === void 0 || pubkey === "") {
    if (silent)
      return null;
    else
      throw new Error("Missing pubkey");
  }
  if (requireD && d === void 0) {
    if (silent)
      return null;
    else
      throw new Error("Missing identifier");
  }
  return {
    kind,
    pubkey,
    identifier: d
  };
}
function getPubkeyFromDecodeResult(result) {
  if (!result)
    return;
  switch (result.type) {
    case "naddr":
    case "nprofile":
      return result.data.pubkey;
    case "npub":
      return result.data;
    case "nsec":
      return getPublicKey(result.data);
    default:
      return void 0;
  }
}
function encodeDecodeResult(result) {
  switch (result.type) {
    case "naddr":
      return naddrEncode2(result.data);
    case "nprofile":
      return nprofileEncode2(result.data);
    case "nevent":
      return neventEncode2(result.data);
    case "nsec":
      return nsecEncode2(result.data);
    case "npub":
      return npubEncode2(result.data);
    case "note":
      return noteEncode2(result.data);
  }
  return "";
}
function getEventPointerFromETag(tag) {
  if (!tag[1])
    throw new Error("Missing event id in tag");
  let pointer = { id: tag[1] };
  if (tag[2] && isSafeRelayURL(tag[2]))
    pointer.relays = [tag[2]];
  return pointer;
}
function getEventPointerFromQTag(tag) {
  if (!tag[1])
    throw new Error("Missing event id in tag");
  let pointer = { id: tag[1] };
  if (tag[2] && isSafeRelayURL(tag[2]))
    pointer.relays = [tag[2]];
  if (tag[3] && tag[3].length === 64)
    pointer.author = tag[3];
  return pointer;
}
function getAddressPointerFromATag(tag) {
  if (!tag[1])
    throw new Error("Missing coordinate in tag");
  const pointer = parseCoordinate(tag[1], true, false);
  if (tag[2] && isSafeRelayURL(tag[2]))
    pointer.relays = [tag[2]];
  return pointer;
}
function getProfilePointerFromPTag(tag) {
  if (!tag[1])
    throw new Error("Missing pubkey in tag");
  if (!isHexKey(tag[1]))
    throw new Error("Invalid pubkey");
  const pointer = { pubkey: tag[1] };
  if (tag[2] && isSafeRelayURL(tag[2]))
    pointer.relays = [tag[2]];
  return pointer;
}
function isAddressPointer(pointer) {
  return typeof pointer !== "string" && Reflect.has(pointer, "identifier") && Reflect.has(pointer, "pubkey") && Reflect.has(pointer, "kind");
}
function isEventPointer(pointer) {
  return typeof pointer !== "string" && Reflect.has(pointer, "id");
}
function getCoordinateFromAddressPointer(pointer) {
  return pointer.kind + ":" + pointer.pubkey + ":" + pointer.identifier;
}
function getAddressPointerForEvent(event, relays) {
  if (!isAddressableKind2(event.kind))
    throw new Error("Cant get AddressPointer for non-replaceable event");
  const d = getReplaceableIdentifier(event);
  return {
    identifier: d,
    kind: event.kind,
    pubkey: event.pubkey,
    relays
  };
}
function getEventPointerForEvent(event, relays) {
  return {
    id: event.id,
    kind: event.kind,
    author: event.pubkey,
    relays
  };
}
function getPointerForEvent(event, relays) {
  if (kinds_exports.isAddressableKind(event.kind)) {
    return {
      type: "naddr",
      data: getAddressPointerForEvent(event, relays)
    };
  } else {
    return {
      type: "nevent",
      data: getEventPointerForEvent(event, relays)
    };
  }
}
function addRelayHintsToPointer(pointer, relays) {
  if (!relays)
    return pointer;
  else
    return { ...pointer, relays: mergeRelaySets(relays, pointer.relays) };
}
function normalizeToPubkey(str) {
  if (isHexKey(str))
    return str.toLowerCase();
  else {
    const decode4 = nip19_exports.decode(str);
    const pubkey = getPubkeyFromDecodeResult(decode4);
    if (!pubkey)
      throw new Error(`Cant find pubkey in ${decode4.type}`);
    return pubkey;
  }
}
function normalizeToSecretKey(str) {
  if (str instanceof Uint8Array)
    return str;
  else if (isHexKey(str))
    return hexToBytes3(str);
  else {
    const decode4 = nip19_exports.decode(str);
    if (decode4.type !== "nsec")
      throw new Error(`Cant get secret key from ${decode4.type}`);
    return decode4.data;
  }
}
function mergeEventPointers(a, b) {
  if (a.id !== b.id)
    throw new Error("Cant merge event pointers with different ids");
  const relays = mergeRelaySets(a.relays, b.relays);
  return { id: a.id, kind: a.kind ?? b.kind, author: a.author ?? b.author, relays };
}
function mergeAddressPointers(a, b) {
  if (a.kind !== b.kind || a.pubkey !== b.pubkey || a.identifier !== b.identifier)
    throw new Error("Cant merge address pointers with different kinds, pubkeys, or identifiers");
  const relays = mergeRelaySets(a.relays, b.relays);
  return { ...a, relays };
}
function mergeProfilePointers(a, b) {
  if (a.pubkey !== b.pubkey)
    throw new Error("Cant merge profile pointers with different pubkeys");
  const relays = mergeRelaySets(a.relays, b.relays);
  return { ...a, relays };
}

// node_modules/applesauce-core/dist/helpers/blossom.js
var BLOSSOM_SERVER_LIST_KIND = 10063;
function areBlossomServersEqual(a, b) {
  const hostnameA = new URL("/", a).toString();
  const hostnameB = new URL("/", b).toString();
  return hostnameA === hostnameB;
}
function isSha256(str) {
  return !!str.match(/^[0-9a-f]{64}$/);
}
function getBlossomServersFromList(event) {
  const tags = Array.isArray(event) ? event : event.tags;
  return processTags(tags, (tag) => {
    if (isNameValueTag(tag, "server") && URL.canParse(tag[1]))
      return new URL("/", tag[1]);
    else
      return void 0;
  });
}
function mergeBlossomServers(...servers) {
  let merged = [];
  const seen = /* @__PURE__ */ new Set();
  for (const arg of servers) {
    let arr = Array.isArray(arg) ? arg : [arg];
    for (const s of arr) {
      if (s === null || s === void 0)
        continue;
      const key = new URL("/", s).toString();
      if (seen.has(key))
        continue;
      seen.add(key);
      merged.push(s);
    }
  }
  return merged;
}

// node_modules/applesauce-core/dist/models/blossom.js
function UserBlossomServersModel(user) {
  if (typeof user === "string")
    user = { pubkey: user };
  return (store) => store.replaceable({ kind: BLOSSOM_SERVER_LIST_KIND, pubkey: user.pubkey, relays: user.relays }).pipe(map((event) => event ? getBlossomServersFromList(event) : []));
}

// node_modules/nostr-tools/lib/esm/utils.js
var utf8Decoder3 = new TextDecoder("utf-8");
var utf8Encoder3 = new TextEncoder();
function insertEventIntoDescendingList2(sortedArray, event) {
  const [idx, found] = binarySearch2(sortedArray, (b) => {
    if (event.id === b.id)
      return 0;
    if (event.created_at === b.created_at)
      return -1;
    return b.created_at - event.created_at;
  });
  if (!found) {
    sortedArray.splice(idx, 0, event);
  }
  return sortedArray;
}
function binarySearch2(arr, compare) {
  let start = 0;
  let end = arr.length - 1;
  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    const cmp = compare(arr[mid]);
    if (cmp === 0) {
      return [mid, true];
    }
    if (cmp < 0) {
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return [start, false];
}

// node_modules/applesauce-core/dist/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  AUDIO_EXT: () => AUDIO_EXT,
  BLOSSOM_SERVER_LIST_KIND: () => BLOSSOM_SERVER_LIST_KIND,
  BookmarkHiddenSymbol: () => BookmarkHiddenSymbol,
  BookmarkPublicSymbol: () => BookmarkPublicSymbol,
  CALENDAR_EVENT_RSVP_KIND: () => CALENDAR_EVENT_RSVP_KIND,
  COMMENT_KIND: () => COMMENT_KIND,
  CalendarEventGeohashSymbol: () => CalendarEventGeohashSymbol,
  CalendarEventHashtagsSymbol: () => CalendarEventHashtagsSymbol,
  CalendarEventLocationsSymbol: () => CalendarEventLocationsSymbol,
  CalendarEventParticipantsSymbol: () => CalendarEventParticipantsSymbol,
  CalendarEventReferencesSymbol: () => CalendarEventReferencesSymbol,
  ChannelMetadataSymbol: () => ChannelMetadataSymbol,
  CommentReplyPointerSymbol: () => CommentReplyPointerSymbol,
  CommentRootPointerSymbol: () => CommentRootPointerSymbol,
  ContactsRelaysSymbol: () => ContactsRelaysSymbol,
  DATE_BASED_CALENDAR_EVENT_KIND: () => DATE_BASED_CALENDAR_EVENT_KIND,
  EncryptedContentFromCacheSymbol: () => EncryptedContentFromCacheSymbol,
  EncryptedContentSymbol: () => EncryptedContentSymbol,
  EventContentEncryptionMethod: () => EventContentEncryptionMethod,
  EventIndexableTagsSymbol: () => EventIndexableTagsSymbol,
  EventStoreSymbol: () => EventStoreSymbol,
  EventUIDSymbol: () => EventUIDSymbol,
  ExpirationTimestampSymbol: () => ExpirationTimestampSymbol,
  FAVORITE_RELAYS_KIND: () => FAVORITE_RELAYS_KIND,
  FromCacheSymbol: () => FromCacheSymbol,
  GROUPS_LIST_KIND: () => GROUPS_LIST_KIND,
  GROUP_MESSAGE_KIND: () => GROUP_MESSAGE_KIND,
  GiftWrapSymbol: () => GiftWrapSymbol,
  GroupsHiddenSymbol: () => GroupsHiddenSymbol,
  GroupsPublicSymbol: () => GroupsPublicSymbol,
  HiddenContactsSymbol: () => HiddenContactsSymbol,
  HiddenContentKinds: () => HiddenContentKinds,
  HiddenContentSymbol: () => HiddenContentSymbol,
  HiddenTagsKinds: () => HiddenTagsKinds,
  HiddenTagsSymbol: () => HiddenTagsSymbol,
  HighlightAttributionSymbol: () => HighlightAttributionSymbol,
  HighlightSourceAddressPointerSymbol: () => HighlightSourceAddressPointerSymbol,
  HighlightSourceEventPointerSymbol: () => HighlightSourceEventPointerSymbol,
  IMAGE_EXT: () => IMAGE_EXT,
  INDEXABLE_TAGS: () => INDEXABLE_TAGS,
  LRU: () => LRU,
  MailboxesInboxesSymbol: () => MailboxesInboxesSymbol,
  MailboxesOutboxesSymbol: () => MailboxesOutboxesSymbol,
  MediaAttachmentsSymbol: () => MediaAttachmentsSymbol,
  MuteHiddenSymbol: () => MuteHiddenSymbol,
  MutePublicSymbol: () => MutePublicSymbol,
  NIP05_REGEX: () => NIP05_REGEX2,
  Nip10ThreadRefsSymbol: () => Nip10ThreadRefsSymbol,
  PICTURE_POST_KIND: () => PICTURE_POST_KIND,
  POLL_KIND: () => POLL_KIND,
  POLL_RESPONSE_KIND: () => POLL_RESPONSE_KIND,
  ParsedReportSymbol: () => ParsedReportSymbol,
  PollOptionsSymbol: () => PollOptionsSymbol,
  ProfileContentSymbol: () => ProfileContentSymbol,
  PublicContactsSymbol: () => PublicContactsSymbol,
  ReactionAddressPointerSymbol: () => ReactionAddressPointerSymbol,
  ReactionEventPointerSymbol: () => ReactionEventPointerSymbol,
  ReplaceableAddressSymbol: () => ReplaceableAddressSymbol,
  ReplaceableIdentifierSymbol: () => ReplaceableIdentifierSymbol,
  ReportReason: () => ReportReason,
  RumorSymbol: () => RumorSymbol,
  STREAM_EXT: () => STREAM_EXT,
  SealSymbol: () => SealSymbol,
  SeenRelaysSymbol: () => SeenRelaysSymbol,
  SharedAddressPointerSymbol: () => SharedAddressPointerSymbol,
  SharedEventPointerSymbol: () => SharedEventPointerSymbol,
  SharedEventSymbol: () => SharedEventSymbol,
  TIME_BASED_CALENDAR_EVENT_KIND: () => TIME_BASED_CALENDAR_EVENT_KIND,
  UserStatusPointerSymbol: () => UserStatusPointerSymbol,
  VIDEO_EXT: () => VIDEO_EXT,
  ZapAddressPointerSymbol: () => ZapAddressPointerSymbol,
  ZapEventPointerSymbol: () => ZapEventPointerSymbol,
  ZapInvoiceSymbol: () => ZapInvoiceSymbol,
  ZapReceiverSymbol: () => ZapReceiverSymbol,
  ZapRequestSymbol: () => ZapRequestSymbol,
  ZapSenderSymbol: () => ZapSenderSymbol,
  addRelayHintsToPointer: () => addRelayHintsToPointer,
  addSeenRelay: () => addSeenRelay,
  areBlossomServersEqual: () => areBlossomServersEqual,
  canHaveEncryptedContent: () => canHaveEncryptedContent,
  canHaveHiddenContent: () => canHaveHiddenContent,
  canHaveHiddenTags: () => canHaveHiddenTags,
  convertToUrl: () => convertToUrl,
  createConversationIdentifier: () => createConversationIdentifier,
  createHandlerAddressLink: () => createHandlerAddressLink,
  createHandlerEventLink: () => createHandlerEventLink,
  createHandlerLink: () => createHandlerLink,
  createHandlerProfileLink: () => createHandlerProfileLink,
  createMutedWordsRegExp: () => createMutedWordsRegExp,
  createReplaceableAddress: () => createReplaceableAddress,
  decodeGroupPointer: () => decodeGroupPointer,
  decodeLNURL: () => decodeLNURL,
  encodeDecodeResult: () => encodeDecodeResult,
  encodeGroupPointer: () => encodeGroupPointer,
  ensureHttpURL: () => ensureHttpURL,
  ensureProtocol: () => ensureProtocol,
  ensureWebSocketURL: () => ensureWebSocketURL,
  fakeVerifyEvent: () => fakeVerifyEvent,
  getAddressPointerForEvent: () => getAddressPointerForEvent,
  getAddressPointerFromATag: () => getAddressPointerFromATag,
  getAddressPointersFromList: () => getAddressPointersFromList,
  getArticleImage: () => getArticleImage,
  getArticlePublished: () => getArticlePublished,
  getArticleSummary: () => getArticleSummary,
  getArticleTitle: () => getArticleTitle,
  getBlossomServersFromList: () => getBlossomServersFromList,
  getBookmarks: () => getBookmarks,
  getCachedValue: () => getCachedValue,
  getCalendarAddressPointers: () => getCalendarAddressPointers,
  getCalendarEventEnd: () => getCalendarEventEnd,
  getCalendarEventEndTimezone: () => getCalendarEventEndTimezone,
  getCalendarEventGeohash: () => getCalendarEventGeohash,
  getCalendarEventHashtags: () => getCalendarEventHashtags,
  getCalendarEventImage: () => getCalendarEventImage,
  getCalendarEventLocations: () => getCalendarEventLocations,
  getCalendarEventParticipants: () => getCalendarEventParticipants,
  getCalendarEventReferences: () => getCalendarEventReferences,
  getCalendarEventStart: () => getCalendarEventStart,
  getCalendarEventStartTimezone: () => getCalendarEventStartTimezone,
  getCalendarEventSummary: () => getCalendarEventSummary,
  getCalendarEventTitle: () => getCalendarEventTitle,
  getCalendarTitle: () => getCalendarTitle,
  getChannelMetadataContent: () => getChannelMetadataContent,
  getChannelPointer: () => getChannelPointer,
  getCommentAddressPointer: () => getCommentAddressPointer,
  getCommentEventPointer: () => getCommentEventPointer,
  getCommentExternalPointer: () => getCommentExternalPointer,
  getCommentReplyPointer: () => getCommentReplyPointer,
  getCommentRootPointer: () => getCommentRootPointer,
  getContacts: () => getContacts,
  getContentWarning: () => getContentWarning,
  getConversationIdentifierFromMessage: () => getConversationIdentifierFromMessage,
  getConversationParticipants: () => getConversationParticipants,
  getCoordinateFromAddressPointer: () => getCoordinateFromAddressPointer,
  getDeleteCoordinates: () => getDeleteCoordinates,
  getDeleteIds: () => getDeleteIds,
  getDisplayName: () => getDisplayName,
  getEmbededSharedEvent: () => getEmbededSharedEvent,
  getEmojiFromTags: () => getEmojiFromTags,
  getEmojiTag: () => getEmojiTag,
  getEmojis: () => getEmojis,
  getEncryptedContent: () => getEncryptedContent,
  getEncryptedContentEncryptionMethods: () => getEncryptedContentEncryptionMethods,
  getEventPointerForEvent: () => getEventPointerForEvent,
  getEventPointerFromETag: () => getEventPointerFromETag,
  getEventPointerFromQTag: () => getEventPointerFromQTag,
  getEventPointerFromThreadTag: () => getEventPointerFromThreadTag,
  getEventPointersFromList: () => getEventPointersFromList,
  getEventUID: () => getEventUID,
  getExpirationTimestamp: () => getExpirationTimestamp,
  getExternalPointerFromTag: () => getExternalPointerFromTag,
  getFileMetadata: () => getFileMetadata,
  getFileMetadataFromImetaTag: () => getFileMetadataFromImetaTag,
  getGiftWrapRumor: () => getGiftWrapRumor,
  getGiftWrapSeal: () => getGiftWrapSeal,
  getGroupPointerFromGroupTag: () => getGroupPointerFromGroupTag,
  getGroupPointerFromHTag: () => getGroupPointerFromHTag,
  getHandlerDescription: () => getHandlerDescription,
  getHandlerLinkTemplate: () => getHandlerLinkTemplate,
  getHandlerName: () => getHandlerName,
  getHandlerPicture: () => getHandlerPicture,
  getHandlerSupportedKinds: () => getHandlerSupportedKinds,
  getHashtagTag: () => getHashtagTag,
  getHiddenBookmarks: () => getHiddenBookmarks,
  getHiddenContacts: () => getHiddenContacts,
  getHiddenContent: () => getHiddenContent,
  getHiddenContentEncryptionMethods: () => getHiddenContentEncryptionMethods,
  getHiddenGroups: () => getHiddenGroups,
  getHiddenMutedThings: () => getHiddenMutedThings,
  getHiddenTags: () => getHiddenTags,
  getHiddenTagsEncryptionMethods: () => getHiddenTagsEncryptionMethods,
  getHighlightAttributions: () => getHighlightAttributions,
  getHighlightComment: () => getHighlightComment,
  getHighlightContext: () => getHighlightContext,
  getHighlightSourceAddressPointer: () => getHighlightSourceAddressPointer,
  getHighlightSourceEventPointer: () => getHighlightSourceEventPointer,
  getHighlightSourceUrl: () => getHighlightSourceUrl,
  getHighlightText: () => getHighlightText,
  getInboxes: () => getInboxes,
  getIndexableTags: () => getIndexableTags,
  getInvoice: () => getInvoice,
  getLegacyMessageCorraspondant: () => getLegacyMessageCorraspondant,
  getLegacyMessageParent: () => getLegacyMessageParent,
  getLegacyMessageReceiver: () => getLegacyMessageReceiver,
  getLegacyMessageSender: () => getLegacyMessageSender,
  getListTags: () => getListTags,
  getMediaAttachments: () => getMediaAttachments,
  getMutedThings: () => getMutedThings,
  getNip10References: () => getNip10References,
  getOrComputeCachedValue: () => getOrComputeCachedValue,
  getOutboxes: () => getOutboxes,
  getPackName: () => getPackName,
  getParentEventStore: () => getParentEventStore,
  getPicturePostAttachments: () => getPicturePostAttachments,
  getPointerForEvent: () => getPointerForEvent,
  getPollEndsAt: () => getPollEndsAt,
  getPollOptions: () => getPollOptions,
  getPollQuestion: () => getPollQuestion,
  getPollRelays: () => getPollRelays,
  getPollResponseOptions: () => getPollResponseOptions,
  getPollResponsePollId: () => getPollResponsePollId,
  getPollResponseVotes: () => getPollResponseVotes,
  getPollType: () => getPollType,
  getProfileContent: () => getProfileContent,
  getProfilePicture: () => getProfilePicture,
  getProfilePointerFromPTag: () => getProfilePointerFromPTag,
  getProfilePointersFromList: () => getProfilePointersFromList,
  getPubkeyFromDecodeResult: () => getPubkeyFromDecodeResult,
  getPublicBookmarks: () => getPublicBookmarks,
  getPublicContacts: () => getPublicContacts,
  getPublicGroups: () => getPublicGroups,
  getPublicMutedThings: () => getPublicMutedThings,
  getRSVPAddressPointer: () => getRSVPAddressPointer,
  getRSVPEventPointer: () => getRSVPEventPointer,
  getRSVPFreeBusy: () => getRSVPFreeBusy,
  getRSVPProfilePointer: () => getRSVPProfilePointer,
  getRSVPStatus: () => getRSVPStatus,
  getReactionAddressPointer: () => getReactionAddressPointer,
  getReactionEmoji: () => getReactionEmoji,
  getReactionEventPointer: () => getReactionEventPointer,
  getRelaysFromContactsEvent: () => getRelaysFromContactsEvent,
  getRelaysFromList: () => getRelaysFromList,
  getReplaceableAddress: () => getReplaceableAddress,
  getReplaceableIdentifier: () => getReplaceableIdentifier,
  getReplaceableUID: () => getReplaceableUID,
  getReported: () => getReported,
  getRumorGiftWraps: () => getRumorGiftWraps,
  getRumorSeals: () => getRumorSeals,
  getSealGiftWrap: () => getSealGiftWrap,
  getSealRumor: () => getSealRumor,
  getSeenRelays: () => getSeenRelays,
  getSha256FromURL: () => getSha256FromURL,
  getSharedAddressPointer: () => getSharedAddressPointer,
  getSharedEventPointer: () => getSharedEventPointer,
  getStreamChatMessageStream: () => getStreamChatMessageStream,
  getStreamEndTime: () => getStreamEndTime,
  getStreamGoalPointer: () => getStreamGoalPointer,
  getStreamHashtags: () => getStreamHashtags,
  getStreamHost: () => getStreamHost,
  getStreamImage: () => getStreamImage,
  getStreamMaxViewers: () => getStreamMaxViewers,
  getStreamParticipants: () => getStreamParticipants,
  getStreamRecording: () => getStreamRecording,
  getStreamRelays: () => getStreamRelays,
  getStreamStartTime: () => getStreamStartTime,
  getStreamStatus: () => getStreamStatus,
  getStreamStreamingURLs: () => getStreamStreamingURLs,
  getStreamSummary: () => getStreamSummary,
  getStreamTitle: () => getStreamTitle,
  getStreamViewers: () => getStreamViewers,
  getTagValue: () => getTagValue,
  getURLFilename: () => getURLFilename,
  getUserStatusPointer: () => getUserStatusPointer,
  getWrappedMessageParent: () => getWrappedMessageParent,
  getWrappedMessageReceiver: () => getWrappedMessageReceiver,
  getWrappedMessageSubject: () => getWrappedMessageSubject,
  getWrappedMesssageSender: () => getWrappedMesssageSender,
  getZapAddressPointer: () => getZapAddressPointer,
  getZapEventPointer: () => getZapEventPointer,
  getZapPayment: () => getZapPayment,
  getZapPreimage: () => getZapPreimage,
  getZapRecipient: () => getZapRecipient,
  getZapRequest: () => getZapRequest,
  getZapSender: () => getZapSender,
  getZapSplits: () => getZapSplits,
  groupMessageEvents: () => groupMessageEvents,
  hasEncryptedContent: () => hasEncryptedContent,
  hasHiddenContent: () => hasHiddenContent,
  hasHiddenTags: () => hasHiddenTags,
  hasHighlightSource: () => hasHighlightSource,
  internalGiftWrapEvents: () => internalGiftWrapEvents,
  interpretThreadTags: () => interpretThreadTags,
  isATag: () => isATag,
  isAddressPointer: () => isAddressPointer,
  isAddressPointerInList: () => isAddressPointerInList,
  isAudioURL: () => isAudioURL,
  isCommentAddressPointer: () => isCommentAddressPointer,
  isCommentEventPointer: () => isCommentEventPointer,
  isDTag: () => isDTag,
  isETag: () => isETag,
  isEncryptedContentFromCache: () => isEncryptedContentFromCache,
  isEncryptedContentLocked: () => isEncryptedContentLocked,
  isEvent: () => isEvent,
  isEventInList: () => isEventInList,
  isEventPointer: () => isEventPointer,
  isEventPointerInList: () => isEventPointerInList,
  isExpired: () => isExpired,
  isFilterEqual: () => isFilterEqual,
  isFromCache: () => isFromCache,
  isGiftWrapLocked: () => isGiftWrapLocked,
  isHex: () => isHex,
  isHexKey: () => isHexKey,
  isHiddenContentLocked: () => isHiddenContentLocked,
  isHiddenTagsLocked: () => isHiddenTagsLocked,
  isImageURL: () => isImageURL,
  isLegacyMessageLocked: () => isLegacyMessageLocked,
  isNIP04Encrypted: () => isNIP04Encrypted,
  isNameValueTag: () => isNameValueTag,
  isNip05: () => isNip052,
  isPTag: () => isPTag,
  isProfilePointerInList: () => isProfilePointerInList,
  isProtectedEvent: () => isProtectedEvent,
  isRTag: () => isRTag,
  isReplaceable: () => isReplaceable,
  isRumor: () => isRumor,
  isSafeRelayURL: () => isSafeRelayURL,
  isSameURL: () => isSameURL,
  isSealLocked: () => isSealLocked,
  isSha256: () => isSha256,
  isStreamURL: () => isStreamURL,
  isTTag: () => isTTag,
  isValidList: () => isValidList,
  isValidProfile: () => isValidProfile,
  isValidZap: () => isValidZap,
  isVideoURL: () => isVideoURL,
  lockEncryptedContent: () => lockEncryptedContent,
  lockGiftWrap: () => lockGiftWrap,
  lockHiddenContent: () => lockHiddenContent,
  lockHiddenTags: () => lockHiddenTags,
  lockLegacyMessage: () => lockLegacyMessage,
  markEncryptedContentFromCache: () => markEncryptedContentFromCache,
  markFromCache: () => markFromCache,
  matchFilter: () => matchFilter,
  matchFilters: () => matchFilters,
  matchMutes: () => matchMutes,
  mergeAddressPointers: () => mergeAddressPointers,
  mergeBlossomServers: () => mergeBlossomServers,
  mergeBookmarks: () => mergeBookmarks,
  mergeContacts: () => mergeContacts,
  mergeEventPointers: () => mergeEventPointers,
  mergeFilters: () => mergeFilters,
  mergeMutes: () => mergeMutes,
  mergeProfilePointers: () => mergeProfilePointers,
  mergeRelaySets: () => mergeRelaySets,
  normalizeToPubkey: () => normalizeToPubkey,
  normalizeToSecretKey: () => normalizeToSecretKey,
  normalizeURL: () => normalizeURL2,
  notifyEventUpdate: () => notifyEventUpdate,
  parseBolt11: () => parseBolt11,
  parseBookmarkTags: () => parseBookmarkTags,
  parseCoordinate: () => parseCoordinate,
  parseExternalPointer: () => parseExternalPointer,
  parseFileMetadataTags: () => parseFileMetadataTags,
  parseLNURLOrAddress: () => parseLNURLOrAddress,
  parseLightningAddress: () => parseLightningAddress,
  parseMutedTags: () => parseMutedTags,
  parseNIP05Address: () => parseNIP05Address,
  parseSharedEvent: () => parseSharedEvent,
  persistEncryptedContent: () => persistEncryptedContent,
  presistEventsToCache: () => presistEventsToCache,
  processTags: () => processTags,
  safeParse: () => safeParse,
  setCachedValue: () => setCachedValue,
  setEncryptedContentCache: () => setEncryptedContentCache,
  setEncryptedContentEncryptionMethod: () => setEncryptedContentEncryptionMethod,
  setHiddenContentCache: () => setHiddenContentCache,
  setHiddenContentEncryptionMethod: () => setHiddenContentEncryptionMethod,
  setHiddenTagsCache: () => setHiddenTagsCache,
  setHiddenTagsEncryptionMethod: () => setHiddenTagsEncryptionMethod,
  stripInvisibleChar: () => stripInvisibleChar,
  unixNow: () => unixNow,
  unlockEncryptedContent: () => unlockEncryptedContent,
  unlockGiftWrap: () => unlockGiftWrap,
  unlockHiddenContent: () => unlockHiddenContent,
  unlockHiddenTags: () => unlockHiddenTags,
  unlockLegacyMessage: () => unlockLegacyMessage,
  unlockSeal: () => unlockSeal
});

// node_modules/applesauce-core/dist/helpers/profile.js
var ProfileContentSymbol = Symbol.for("profile-content");
function getProfileContent(event) {
  return getOrComputeCachedValue(event, ProfileContentSymbol, () => {
    var _a, _b;
    const profile = JSON.parse(event.content);
    if (profile.nip05 && typeof profile.nip05 !== "string")
      profile.nip05 = String(profile.nip05);
    if (profile.website && ((_a = profile.website) == null ? void 0 : _a.length) > 0 && ((_b = profile.website) == null ? void 0 : _b.startsWith("http")) === false) {
      profile.website = "https://" + profile.website;
    }
    return profile;
  });
}
function isValidProfile(profile) {
  if (!profile)
    return false;
  if (profile.kind !== kinds_exports.Metadata && profile.kind !== kinds_exports.Handlerinformation)
    return false;
  try {
    getProfileContent(profile);
    return true;
  } catch (error) {
    return false;
  }
}
function getProfilePicture(metadata, fallback) {
  var _a;
  if (!metadata)
    return fallback;
  if ("pubkey" in metadata && "id" in metadata && "sig" in metadata) {
    if (isValidProfile(metadata))
      metadata = getProfileContent(metadata);
    else
      metadata = void 0;
  }
  return (_a = (metadata == null ? void 0 : metadata.picture) || (metadata == null ? void 0 : metadata.image) || fallback) == null ? void 0 : _a.trim();
}
function getDisplayName(metadata, fallback) {
  var _a;
  if (!metadata)
    return fallback;
  if ("pubkey" in metadata && "id" in metadata && "sig" in metadata) {
    if (!fallback) {
      const npub = npubEncode2(metadata.pubkey);
      fallback = npub.slice(0, 5 + 4) + "" + npub.slice(-4);
    }
    if (isValidProfile(metadata))
      metadata = getProfileContent(metadata);
    else
      metadata = void 0;
  }
  return (_a = (metadata == null ? void 0 : metadata.display_name) || (metadata == null ? void 0 : metadata.displayName) || (metadata == null ? void 0 : metadata.name) || fallback) == null ? void 0 : _a.trim();
}

// node_modules/applesauce-core/dist/helpers/app-handlers.js
function getHandlerSupportedKinds(handler) {
  return processTags(handler.tags, (t) => t[0] === "k" && t[1] ? parseInt(t[1]) : void 0);
}
function getHandlerName(handler) {
  return getDisplayName(handler);
}
function getHandlerPicture(handler, fallback) {
  if (!isValidProfile(handler))
    return fallback;
  return getProfilePicture(handler, fallback);
}
function getHandlerDescription(handler) {
  if (!isValidProfile(handler))
    return;
  return getProfileContent(handler).about;
}
function getHandlerLinkTemplate(handler, platform = "web", type) {
  var _a, _b;
  const tags = handler.tags.filter((t) => t[0] === platform);
  if (type)
    return (_a = tags.find((t) => t[2] === type)) == null ? void 0 : _a[1];
  else
    return (_b = tags.find((t) => t[2] === void 0 || t[2] === "")) == null ? void 0 : _b[1];
}
function createHandlerProfileLink(handler, pointer, platform = "web") {
  var _a, _b, _c;
  return ((_a = getHandlerLinkTemplate(handler, platform, "nprofile")) == null ? void 0 : _a.replace("<bech32>", nprofileEncode2(pointer))) || ((_b = getHandlerLinkTemplate(handler, platform, "npub")) == null ? void 0 : _b.replace("<bech32>", npubEncode2(pointer.pubkey))) || ((_c = getHandlerLinkTemplate(handler, platform)) == null ? void 0 : _c.replace("<bech32>", nprofileEncode2(pointer)));
}
function createHandlerEventLink(handler, pointer, platform = "web") {
  var _a, _b, _c;
  return ((_a = getHandlerLinkTemplate(handler, platform, "nevent")) == null ? void 0 : _a.replace("<bech32>", neventEncode2(pointer))) || ((_b = getHandlerLinkTemplate(handler, platform, "note")) == null ? void 0 : _b.replace("<bech32>", noteEncode2(pointer.id))) || ((_c = getHandlerLinkTemplate(handler, platform)) == null ? void 0 : _c.replace("<bech32>", neventEncode2(pointer)));
}
function createHandlerAddressLink(handler, pointer, platform = "web") {
  var _a, _b;
  return ((_a = getHandlerLinkTemplate(handler, platform, "naddr")) == null ? void 0 : _a.replace("<bech32>", naddrEncode2(pointer))) || ((_b = getHandlerLinkTemplate(handler, platform)) == null ? void 0 : _b.replace("<bech32>", naddrEncode2(pointer)));
}
function createHandlerLink(handler, pointer, platform, webFallback = true) {
  let link = void 0;
  if (isEventPointer(pointer))
    link = createHandlerEventLink(handler, pointer, platform);
  else if (isAddressPointer(pointer))
    link = createHandlerAddressLink(handler, pointer, platform);
  else
    link = createHandlerProfileLink(handler, pointer, platform);
  if (!link && platform && platform !== "web" && webFallback)
    link = createHandlerLink(handler, pointer, "web");
  return link;
}

// node_modules/applesauce-core/dist/helpers/article.js
function getArticleTitle(article) {
  return getTagValue(article, "title");
}
function getArticleImage(article) {
  return getTagValue(article, "image");
}
function getArticleSummary(article) {
  return getTagValue(article, "summary");
}
function getArticlePublished(article) {
  const ts = getTagValue(article, "published_at");
  if (ts && !Number.isNaN(parseInt(ts)))
    return parseInt(ts);
  else
    return article.created_at;
}

// node_modules/applesauce-core/dist/helpers/bolt11.js
var import_light_bolt11_decoder = __toESM(require_bolt11(), 1);
function parseBolt11(paymentRequest) {
  var _a, _b, _c;
  const decoded = (0, import_light_bolt11_decoder.decode)(paymentRequest);
  const timestamp2 = ((_a = decoded.sections.find((s) => s.name === "timestamp")) == null ? void 0 : _a.value) ?? 0;
  const description = ((_b = decoded.sections.find((s) => s.name === "description")) == null ? void 0 : _b.value) ?? "";
  const amount = parseInt(((_c = decoded.sections.find((s) => s.name === "amount")) == null ? void 0 : _c.value) ?? "0");
  const paymentHash = decoded.sections.find((s) => s.name === "payment_hash");
  return {
    paymentRequest: decoded.paymentRequest,
    description,
    amount,
    timestamp: timestamp2,
    expiry: timestamp2 + decoded.expiry,
    paymentHash: paymentHash == null ? void 0 : paymentHash.value
  };
}

// node_modules/applesauce-core/dist/helpers/bookmarks.js
var BookmarkPublicSymbol = Symbol.for("bookmark-public");
var BookmarkHiddenSymbol = Symbol.for("bookmark-hidden");
function parseBookmarkTags(tags) {
  const notes = tags.filter((t) => t[0] === "e" && t[1]).map(getEventPointerFromETag);
  const articles = tags.filter((t) => t[0] === "a" && t[1]).map(getAddressPointerFromATag).filter((addr) => addr.kind === kinds_exports.LongFormArticle);
  const hashtags = tags.filter((t) => t[0] === "t" && t[1]).map((t) => t[1]);
  const urls = tags.filter((t) => t[0] === "r" && t[1]).map((t) => t[1]);
  return { notes, articles, hashtags, urls };
}
function mergeBookmarks(...bookmarks) {
  const notes = /* @__PURE__ */ new Map();
  const articles = /* @__PURE__ */ new Map();
  const hashtags = /* @__PURE__ */ new Set();
  const urls = /* @__PURE__ */ new Set();
  for (const bookmark of bookmarks) {
    if (!bookmark)
      continue;
    for (const note of bookmark.notes) {
      const existing = notes.get(note.id);
      if (existing)
        notes.set(note.id, mergeEventPointers(existing, note));
      else
        notes.set(note.id, note);
    }
    for (const article of bookmark.articles) {
      const coord = getCoordinateFromAddressPointer(article);
      const existing = articles.get(coord);
      if (existing)
        articles.set(coord, mergeAddressPointers(existing, article));
      else
        articles.set(coord, article);
    }
    for (const hashtag of bookmark.hashtags)
      hashtags.add(hashtag);
    for (const url of bookmark.urls)
      urls.add(url);
  }
  return {
    notes: Array.from(notes.values()),
    articles: Array.from(articles.values()),
    hashtags: Array.from(hashtags),
    urls: Array.from(urls)
  };
}
function getBookmarks(bookmark) {
  const hidden = getHiddenBookmarks(bookmark);
  if (hidden)
    return mergeBookmarks(hidden, getPublicBookmarks(bookmark));
  else
    return getPublicBookmarks(bookmark);
}
function getPublicBookmarks(bookmark) {
  return getOrComputeCachedValue(bookmark, BookmarkPublicSymbol, () => parseBookmarkTags(bookmark.tags));
}
function getHiddenBookmarks(bookmark) {
  if (isHiddenTagsLocked(bookmark))
    return void 0;
  return getOrComputeCachedValue(bookmark, BookmarkHiddenSymbol, () => parseBookmarkTags(getHiddenTags(bookmark)));
}

// node_modules/applesauce-core/dist/helpers/calendar-event.js
var DATE_BASED_CALENDAR_EVENT_KIND = 31922;
var TIME_BASED_CALENDAR_EVENT_KIND = 31923;
var CalendarEventLocationsSymbol = Symbol.for("calendar-event-locations");
var CalendarEventParticipantsSymbol = Symbol.for("calendar-event-participants");
var CalendarEventHashtagsSymbol = Symbol.for("calendar-event-hashtags");
var CalendarEventReferencesSymbol = Symbol.for("calendar-event-references");
var CalendarEventGeohashSymbol = Symbol.for("calendar-event-geohash");
function getCalendarEventTitle(event) {
  return getTagValue(event, "title") || getTagValue(event, "name");
}
function getCalendarEventSummary(event) {
  return getTagValue(event, "summary");
}
function getCalendarEventImage(event) {
  return getTagValue(event, "image");
}
function getCalendarEventStart(event) {
  const value = getTagValue(event, "start");
  if (!value)
    return void 0;
  if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
    return new Date(value).valueOf() / 1e3;
  else if (event.kind === TIME_BASED_CALENDAR_EVENT_KIND)
    return parseInt(value);
  else
    return void 0;
}
function getCalendarEventStartTimezone(event) {
  if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
    return void 0;
  return getTagValue(event, "start_tzid");
}
function getCalendarEventEndTimezone(event) {
  if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
    return void 0;
  return getTagValue(event, "end_tzid");
}
function getCalendarEventEnd(event) {
  const value = getTagValue(event, "end");
  if (!value)
    return void 0;
  if (event.kind === DATE_BASED_CALENDAR_EVENT_KIND)
    return new Date(value).valueOf() / 1e3;
  else if (event.kind === TIME_BASED_CALENDAR_EVENT_KIND)
    return parseInt(value);
  else
    return void 0;
}
function getCalendarEventLocations(event) {
  if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
    throw new Error("Event is not a date-based or time-based calendar event");
  return getOrComputeCachedValue(event, CalendarEventLocationsSymbol, () => {
    return event.tags.filter((t) => t[0] === "location" && t[1]).map((t) => t[1]);
  });
}
function getCalendarEventGeohash(event) {
  if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
    throw new Error("Event is not a date-based or time-based calendar event");
  return getOrComputeCachedValue(event, CalendarEventGeohashSymbol, () => {
    let hash3 = void 0;
    for (const tag of event.tags) {
      if (tag[0] === "g" && tag[1] && (!hash3 || tag[1].length > hash3.length))
        hash3 = tag[1];
    }
    return hash3;
  });
}
function getCalendarEventParticipants(event) {
  if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
    throw new Error("Event is not a date-based or time-based calendar event");
  return getOrComputeCachedValue(event, CalendarEventParticipantsSymbol, () => {
    return event.tags.filter(isPTag).map((tag) => ({
      ...getProfilePointerFromPTag(tag),
      // Third index of tag is optional "role"
      role: tag[3] || void 0
    }));
  });
}
function getCalendarEventHashtags(event) {
  if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
    throw new Error("Event is not a date-based or time-based calendar event");
  return getOrComputeCachedValue(event, CalendarEventHashtagsSymbol, () => {
    return event.tags.filter(isTTag).map((t) => t[1]);
  });
}
function getCalendarEventReferences(event) {
  if (event.kind !== DATE_BASED_CALENDAR_EVENT_KIND && event.kind !== TIME_BASED_CALENDAR_EVENT_KIND)
    throw new Error("Event is not a date-based or time-based calendar event");
  return getOrComputeCachedValue(event, CalendarEventReferencesSymbol, () => {
    return event.tags.filter(isRTag).map((t) => t[1]);
  });
}

// node_modules/applesauce-core/dist/helpers/calendar-rsvp.js
var CALENDAR_EVENT_RSVP_KIND = 31925;
function getRSVPStatus(event) {
  const status = getTagValue(event, "status");
  return status && ["accepted", "declined", "tentative"].includes(status) ? status : void 0;
}
function getRSVPFreeBusy(event) {
  const status = getRSVPStatus(event);
  if (status === "declined")
    return void 0;
  const fb = getTagValue(event, "fb");
  return fb && ["free", "busy"].includes(fb) ? fb : void 0;
}
function getRSVPAddressPointer(event) {
  const tag = event.tags.find(isATag);
  if (!tag)
    return void 0;
  return getAddressPointerFromATag(tag);
}
function getRSVPEventPointer(event) {
  const tag = event.tags.find(isETag);
  if (!tag)
    return void 0;
  return getEventPointerFromETag(tag);
}
function getRSVPProfilePointer(event) {
  const tag = event.tags.find(isPTag);
  if (!tag)
    return void 0;
  return getProfilePointerFromPTag(tag);
}

// node_modules/applesauce-core/dist/helpers/calendar.js
function getCalendarTitle(event) {
  return getTagValue(event, "title");
}
function getCalendarAddressPointers(event) {
  return event.tags.filter(isATag).map(getAddressPointerFromATag);
}

// node_modules/applesauce-core/dist/helpers/channels.js
var ChannelMetadataSymbol = Symbol.for("channel-metadata");
function parseChannelMetadataContent(channel) {
  const metadata = JSON.parse(channel.content);
  if (metadata.name === void 0)
    throw new Error("Missing name");
  if (metadata.about === void 0)
    throw new Error("Missing about");
  if (metadata.picture === void 0)
    throw new Error("Missing picture");
  if (metadata.relays && !Array.isArray(metadata.relays))
    throw new Error("Invalid relays");
  return metadata;
}
function getChannelMetadataContent(channel) {
  return getOrComputeCachedValue(channel, ChannelMetadataSymbol, () => {
    return parseChannelMetadataContent(channel);
  });
}
function getChannelPointer(event) {
  const tag = event.tags.find((t) => t[0] === "e" && t[1]);
  if (!tag)
    return void 0;
  return tag[2] ? { id: tag[1], relays: [tag[2]] } : { id: tag[1] };
}

// node_modules/applesauce-core/dist/helpers/external-id.js
function parseExternalPointer(identifier) {
  if (identifier.startsWith("#"))
    return { kind: "#", identifier };
  if (identifier.startsWith("geo:"))
    return { kind: "geo", identifier };
  if (identifier.startsWith("podcast:guid:"))
    return { kind: "podcast:guid", identifier };
  if (identifier.startsWith("podcast:item:guid:"))
    return { kind: "podcast:item:guid", identifier };
  if (identifier.startsWith("podcast:publisher:guid:"))
    return { kind: "podcast:publisher:guid", identifier };
  if (identifier.startsWith("isan:"))
    return { kind: "isan", identifier };
  if (identifier.startsWith("doi:"))
    return { kind: "doi", identifier };
  throw new Error("Failed to parse external identifier");
}
function getExternalPointerFromTag(tag) {
  return parseExternalPointer(tag[1]);
}

// node_modules/applesauce-core/dist/helpers/comment.js
var COMMENT_KIND = 1111;
var CommentRootPointerSymbol = Symbol.for("comment-root-pointer");
var CommentReplyPointerSymbol = Symbol.for("comment-reply-pointer");
function getCommentEventPointer(tags, root = false) {
  var _a, _b;
  const eTag = tags.find((t) => t[0] === (root ? "E" : "e"));
  const kind = (_a = tags.find((t) => t[0] === (root ? "K" : "k"))) == null ? void 0 : _a[1];
  if (eTag) {
    if (!kind)
      throw new Error("Missing kind tag");
    const rootPubkey = root ? (_b = tags.find((t) => t[0] === "P")) == null ? void 0 : _b[1] : void 0;
    const pointer = {
      type: "event",
      id: eTag[1],
      kind: parseInt(kind),
      pubkey: eTag[3] || rootPubkey || void 0,
      relay: eTag[2] && isSafeRelayURL(eTag[2]) ? eTag[2] : void 0
    };
    return pointer;
  }
  return null;
}
function getCommentAddressPointer(tags, root = false) {
  var _a, _b;
  const aTag = tags.find((t) => t[0] === (root ? "A" : "a"));
  const eTag = tags.find((t) => t[0] === (root ? "E" : "e"));
  const kind = (_a = tags.find((t) => t[0] === (root ? "K" : "k"))) == null ? void 0 : _a[1];
  if (aTag) {
    if (!kind)
      throw new Error("Missing kind tag");
    const addressPointer = getAddressPointerFromATag(aTag);
    const pointer = {
      type: "address",
      id: eTag == null ? void 0 : eTag[1],
      pubkey: addressPointer.pubkey,
      identifier: addressPointer.identifier,
      kind: addressPointer.kind || parseInt(kind),
      relay: ((_b = addressPointer.relays) == null ? void 0 : _b[0]) || (eTag == null ? void 0 : eTag[2])
    };
    return pointer;
  }
  return null;
}
function getCommentExternalPointer(tags, root = false) {
  var _a;
  const iTag = tags.find((t) => t[0] === (root ? "I" : "i"));
  const kind = (_a = tags.find((t) => t[0] === (root ? "K" : "k"))) == null ? void 0 : _a[1];
  if (iTag) {
    if (!kind)
      throw new Error("Missing kind tag");
    return {
      type: "external",
      ...getExternalPointerFromTag(iTag)
    };
  }
  return null;
}
function getCommentRootPointer(comment) {
  if (comment.kind !== COMMENT_KIND)
    throw new Error("Event is not a comment");
  return getOrComputeCachedValue(comment, CommentRootPointerSymbol, () => {
    const A = getCommentAddressPointer(comment.tags, true);
    if (A)
      return A;
    const E = getCommentEventPointer(comment.tags, true);
    if (E)
      return E;
    const I = getCommentExternalPointer(comment.tags, true);
    if (I)
      return I;
    return null;
  });
}
function getCommentReplyPointer(comment) {
  if (comment.kind !== COMMENT_KIND)
    throw new Error("Event is not a comment");
  return getOrComputeCachedValue(comment, CommentReplyPointerSymbol, () => {
    const A = getCommentAddressPointer(comment.tags, false);
    if (A)
      return A;
    const E = getCommentEventPointer(comment.tags, false);
    if (E)
      return E;
    const I = getCommentExternalPointer(comment.tags, false);
    if (I)
      return I;
    return null;
  });
}
function isCommentEventPointer(pointer) {
  return Reflect.has(pointer, "id") && Reflect.has(pointer, "kind") && !Reflect.has(pointer, "identifier") && typeof pointer.kind === "number";
}
function isCommentAddressPointer(pointer) {
  return Reflect.has(pointer, "identifier") && Reflect.has(pointer, "pubkey") && Reflect.has(pointer, "kind") && typeof pointer.kind === "number";
}

// node_modules/applesauce-core/dist/helpers/contacts.js
var ContactsRelaysSymbol = Symbol.for("contacts-relays");
var PublicContactsSymbol = Symbol.for("public-contacts");
var HiddenContactsSymbol = Symbol.for("hidden-contacts");
function getRelaysFromContactsEvent(event) {
  return getOrComputeCachedValue(event, ContactsRelaysSymbol, () => {
    try {
      const relayJson = JSON.parse(event.content);
      const relays = /* @__PURE__ */ new Map();
      for (const [url, opts] of Object.entries(relayJson)) {
        if (!isSafeRelayURL(url))
          continue;
        if (opts.write && opts.read)
          relays.set(url, "all");
        else if (opts.read)
          relays.set(url, "inbox");
        else if (opts.write)
          relays.set(url, "outbox");
      }
      return relays;
    } catch (error) {
      return null;
    }
  });
}
function mergeContacts(...pointers) {
  const merged = /* @__PURE__ */ new Map();
  for (const arr of pointers) {
    if (Array.isArray(arr)) {
      for (const pointer of arr)
        if (pointer)
          merged.set(pointer.pubkey, pointer);
    } else if (arr) {
      merged.set(arr.pubkey, arr);
    }
  }
  return Array.from(merged.values());
}
function getContacts(event) {
  return mergeContacts(getPublicContacts(event), getHiddenContacts(event));
}
function getPublicContacts(event) {
  return getOrComputeCachedValue(event, PublicContactsSymbol, () => processTags(event.tags, (t) => isPTag(t) ? t : void 0, getProfilePointerFromPTag));
}
function getHiddenContacts(event) {
  if (isHiddenTagsLocked(event))
    return void 0;
  return getOrComputeCachedValue(event, HiddenContactsSymbol, () => processTags(getHiddenTags(event), (t) => isPTag(t) ? t : void 0, getProfilePointerFromPTag));
}

// node_modules/applesauce-core/dist/helpers/content.js
function getContentWarning(event) {
  const tag = event.tags.find((t) => t[0] === "content-warning");
  if (tag)
    return tag[1] || true;
  else
    return false;
}

// node_modules/nostr-tools/lib/esm/nip05.js
var NIP05_REGEX2 = /^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/;
var isNip052 = (value) => NIP05_REGEX2.test(value || "");
var _fetch5;
try {
  _fetch5 = fetch;
} catch (_) {
  null;
}

// node_modules/applesauce-core/dist/helpers/dns-identity.js
function parseNIP05Address(address) {
  const match = address.toLowerCase().match(NIP05_REGEX2);
  if (!match)
    return null;
  const [, name = "_", domain] = match;
  return { name, domain };
}

// node_modules/applesauce-core/dist/helpers/emoji.js
function getEmojiTag(tags, code) {
  code = code.replace(/^:|:$/g, "").toLowerCase();
  return (Array.isArray(tags) ? tags : tags.tags).find((t) => t[0] === "emoji" && t.length >= 3 && t[1].toLowerCase() === code);
}
function getEmojiFromTags(event, code) {
  const tag = getEmojiTag(event, code);
  if (!tag)
    return void 0;
  return {
    shortcode: tag[1],
    url: tag[2]
  };
}
function getPackName(pack) {
  return getTagValue(pack, "title") || getTagValue(pack, "d");
}
function getEmojis(pack) {
  return pack.tags.filter((t) => t[0] === "emoji" && t[1] && t[2]).map((t) => ({ shortcode: t[1], url: t[2] }));
}
function getReactionEmoji(event) {
  var _a;
  const shortcode = (_a = /^:+(.+?):+$/g.exec(event.content.trim().toLowerCase())) == null ? void 0 : _a[1];
  if (!shortcode)
    return void 0;
  return getEmojiFromTags(event, shortcode);
}

// node_modules/applesauce-core/dist/logger.js
var import_debug = __toESM(require_browser(), 1);
var logger = (0, import_debug.default)("applesauce");

// node_modules/applesauce-core/dist/helpers/lru.js
var LRU = class {
  constructor(max2 = 0, ttl = 0, resetTtl = false) {
    __publicField(this, "first", null);
    __publicField(this, "items", /* @__PURE__ */ Object.create(null));
    __publicField(this, "last", null);
    __publicField(this, "max");
    __publicField(this, "resetTtl");
    __publicField(this, "size");
    __publicField(this, "ttl");
    this.first = null;
    this.items = /* @__PURE__ */ Object.create(null);
    this.last = null;
    this.max = max2;
    this.resetTtl = resetTtl;
    this.size = 0;
    this.ttl = ttl;
  }
  clear() {
    this.first = null;
    this.items = /* @__PURE__ */ Object.create(null);
    this.last = null;
    this.size = 0;
    return this;
  }
  delete(key) {
    if (this.has(key)) {
      const item = this.items[key];
      delete this.items[key];
      this.size--;
      if (item.prev !== null) {
        item.prev.next = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      }
      if (this.first === item) {
        this.first = item.next;
      }
      if (this.last === item) {
        this.last = item.prev;
      }
    }
    return this;
  }
  entries(keys = this.keys()) {
    return keys.map((key) => [key, this.get(key)]);
  }
  evict(bypass = false) {
    if (bypass || this.size > 0) {
      const item = this.first;
      delete this.items[item.key];
      if (--this.size === 0) {
        this.first = null;
        this.last = null;
      } else {
        this.first = item.next;
        this.first.prev = null;
      }
    }
    return this;
  }
  expiresAt(key) {
    let result;
    if (this.has(key)) {
      result = this.items[key].expiry;
    }
    return result;
  }
  get(key) {
    let result;
    if (this.has(key)) {
      const item = this.items[key];
      if (this.ttl > 0 && item.expiry <= Date.now()) {
        this.delete(key);
      } else {
        result = item.value;
        this.set(key, result, true);
      }
    }
    return result;
  }
  has(key) {
    return key in this.items;
  }
  keys() {
    const result = [];
    let x = this.first;
    while (x !== null) {
      result.push(x.key);
      x = x.next;
    }
    return result;
  }
  set(key, value, bypass = false, resetTtl = this.resetTtl) {
    let item;
    if (bypass || this.has(key)) {
      item = this.items[key];
      item.value = value;
      if (bypass === false && resetTtl) {
        item.expiry = this.ttl > 0 ? Date.now() + this.ttl : this.ttl;
      }
      if (this.last !== item) {
        const last3 = this.last, next = item.next, prev = item.prev;
        if (this.first === item) {
          this.first = item.next;
        }
        item.next = null;
        item.prev = this.last;
        last3.next = item;
        if (prev !== null) {
          prev.next = next;
        }
        if (next !== null) {
          next.prev = prev;
        }
      }
    } else {
      if (this.max > 0 && this.size === this.max) {
        this.evict(true);
      }
      item = this.items[key] = {
        expiry: this.ttl > 0 ? Date.now() + this.ttl : this.ttl,
        key,
        prev: this.last,
        next: null,
        value
      };
      if (++this.size === 1) {
        this.first = item;
      } else {
        this.last.next = item;
      }
    }
    this.last = item;
    return this;
  }
  values(keys = this.keys()) {
    return keys.map((key) => this.get(key));
  }
};

// node_modules/applesauce-core/dist/event-store/event-set.js
var EventSet = class {
  constructor() {
    __publicField(this, "log", logger.extend("EventSet"));
    /** Indexes */
    __publicField(this, "kinds", /* @__PURE__ */ new Map());
    __publicField(this, "authors", /* @__PURE__ */ new Map());
    __publicField(this, "tags", new LRU());
    __publicField(this, "created_at", []);
    /** LRU cache of last events touched */
    __publicField(this, "events", new LRU());
    /** A sorted array of replaceable events by address */
    __publicField(this, "replaceable", /* @__PURE__ */ new Map());
    /** A stream of events inserted into the database */
    __publicField(this, "insert$", new Subject());
    /** A stream of events that have been updated */
    __publicField(this, "update$", new Subject());
    /** A stream of events removed from the database */
    __publicField(this, "remove$", new Subject());
    /** A method thats called before a new event is inserted */
    __publicField(this, "onBeforeInsert");
    /** A weak map of events that are claimed by other things */
    __publicField(this, "claims", /* @__PURE__ */ new WeakMap());
  }
  /** The number of events in the event set */
  get size() {
    return this.events.size;
  }
  /** Moves an event to the top of the LRU cache */
  touch(event) {
    this.events.set(event.id, event);
  }
  /** Checks if the database contains an event without touching it */
  hasEvent(id) {
    return this.events.has(id);
  }
  /** Gets a single event based on id */
  getEvent(id) {
    return this.events.get(id);
  }
  /** Checks if the event set has a replaceable event */
  hasReplaceable(kind, pubkey, identifier) {
    const events = this.replaceable.get(createReplaceableAddress(kind, pubkey, identifier));
    return !!events && events.length > 0;
  }
  /** Gets the latest replaceable event */
  getReplaceable(kind, pubkey, identifier) {
    const address = createReplaceableAddress(kind, pubkey, identifier);
    const events = this.replaceable.get(address);
    return events == null ? void 0 : events[0];
  }
  /** Gets the history of a replaceable event */
  getReplaceableHistory(kind, pubkey, identifier) {
    const address = createReplaceableAddress(kind, pubkey, identifier);
    return this.replaceable.get(address);
  }
  /** Gets all events that match the filters */
  getByFilters(filters) {
    return this.getEventsForFilters(Array.isArray(filters) ? filters : [filters]);
  }
  /** Gets a timeline of events that match the filters */
  getTimeline(filters) {
    const timeline = [];
    const events = this.getEventsForFilters(Array.isArray(filters) ? filters : [filters]);
    for (const event of events)
      insertEventIntoDescendingList2(timeline, event);
    return timeline;
  }
  /** Inserts an event into the database and notifies all subscriptions */
  add(event) {
    var _a, _b;
    const id = event.id;
    const current = this.events.get(id);
    if (current)
      return current;
    if (((_a = this.onBeforeInsert) == null ? void 0 : _a.call(this, event)) === false)
      return null;
    this.events.set(id, event);
    this.getKindIndex(event.kind).add(event);
    this.getAuthorsIndex(event.pubkey).add(event);
    for (const tag of getIndexableTags(event)) {
      if (this.tags.has(tag))
        this.getTagIndex(tag).add(event);
    }
    insertEventIntoDescendingList2(this.created_at, event);
    if (isReplaceable(event.kind)) {
      const identifier = (_b = event.tags.find((t) => t[0] === "d")) == null ? void 0 : _b[1];
      const address = createReplaceableAddress(event.kind, event.pubkey, identifier);
      let array = this.replaceable.get(address);
      if (!this.replaceable.has(address)) {
        array = [];
        this.replaceable.set(address, array);
      }
      insertEventIntoDescendingList2(array, event);
    }
    this.insert$.next(event);
    return event;
  }
  /** Inserts and event into the database and notifies all subscriptions that the event has updated */
  update(event) {
    const inserted = this.add(event);
    if (inserted)
      this.update$.next(inserted);
    return inserted !== null;
  }
  /** Removes an event from the database and notifies all subscriptions */
  remove(eventOrId) {
    var _a;
    let event = typeof eventOrId === "string" ? this.events.get(eventOrId) : eventOrId;
    if (!event)
      throw new Error("Missing event");
    const id = event.id;
    if (!this.events.has(id))
      return false;
    this.getAuthorsIndex(event.pubkey).delete(event);
    this.getKindIndex(event.kind).delete(event);
    for (const tag of getIndexableTags(event)) {
      if (this.tags.has(tag)) {
        this.getTagIndex(tag).delete(event);
      }
    }
    const i2 = this.created_at.indexOf(event);
    this.created_at.splice(i2, 1);
    this.events.delete(id);
    if (isReplaceable(event.kind)) {
      const identifier = (_a = event.tags.find((t) => t[0] === "d")) == null ? void 0 : _a[1];
      const address = createReplaceableAddress(event.kind, event.pubkey, identifier);
      const array = this.replaceable.get(address);
      if (array && array.includes(event)) {
        const idx = array.indexOf(event);
        array.splice(idx, 1);
      }
    }
    this.claims.delete(event);
    this.remove$.next(event);
    return true;
  }
  /** Sets the claim on the event and touches it */
  claim(event, claim) {
    if (!this.claims.has(event)) {
      this.claims.set(event, claim);
    }
    this.touch(event);
  }
  /** Checks if an event is claimed by anything */
  isClaimed(event) {
    return this.claims.has(event);
  }
  /** Removes a claim from an event */
  removeClaim(event, claim) {
    const current = this.claims.get(event);
    if (current === claim)
      this.claims.delete(event);
  }
  /** Removes all claims on an event */
  clearClaim(event) {
    this.claims.delete(event);
  }
  /** Index helper methods */
  getKindIndex(kind) {
    if (!this.kinds.has(kind))
      this.kinds.set(kind, /* @__PURE__ */ new Set());
    return this.kinds.get(kind);
  }
  getAuthorsIndex(author) {
    if (!this.authors.has(author))
      this.authors.set(author, /* @__PURE__ */ new Set());
    return this.authors.get(author);
  }
  getTagIndex(tagAndValue) {
    if (!this.tags.has(tagAndValue)) {
      const events = /* @__PURE__ */ new Set();
      const ts = Date.now();
      for (const event of this.events.values()) {
        if (getIndexableTags(event).has(tagAndValue)) {
          events.add(event);
        }
      }
      const took = Date.now() - ts;
      if (took > 100)
        this.log(`Built index ${tagAndValue} took ${took}ms`);
      this.tags.set(tagAndValue, events);
    }
    return this.tags.get(tagAndValue);
  }
  /** Iterates over all events by author */
  *iterateAuthors(authors) {
    for (const author of authors) {
      const events = this.authors.get(author);
      if (events) {
        for (const event of events)
          yield event;
      }
    }
  }
  /** Iterates over all events by indexable tag and value */
  *iterateTag(tag, values) {
    for (const value of values) {
      const events = this.getTagIndex(tag + ":" + value);
      if (events) {
        for (const event of events)
          yield event;
      }
    }
  }
  /** Iterates over all events by kind */
  *iterateKinds(kinds) {
    for (const kind of kinds) {
      const events = this.kinds.get(kind);
      if (events) {
        for (const event of events)
          yield event;
      }
    }
  }
  /** Iterates over all events by time */
  *iterateTime(since, until) {
    let untilIndex = 0;
    let sinceIndex = this.created_at.length - 1;
    let start = until ? binarySearch2(this.created_at, (mid) => {
      return mid.created_at - until;
    }) : void 0;
    if (start)
      untilIndex = start[0];
    const end = since ? binarySearch2(this.created_at, (mid) => {
      return mid.created_at - since;
    }) : void 0;
    if (end)
      sinceIndex = end[0];
    for (let i2 = untilIndex; i2 < sinceIndex; i2++) {
      yield this.created_at[i2];
    }
  }
  /** Iterates over all events by id */
  *iterateIds(ids) {
    for (const id of ids) {
      if (this.events.has(id))
        yield this.events.get(id);
    }
  }
  /** Returns all events that match the filter */
  getEventsForFilter(filter2) {
    if (filter2.search)
      return /* @__PURE__ */ new Set();
    let first2 = true;
    let events = /* @__PURE__ */ new Set();
    const and = (iterable) => {
      const set = iterable instanceof Set ? iterable : new Set(iterable);
      if (first2) {
        events = set;
        first2 = false;
      } else {
        for (const event of events) {
          if (!set.has(event))
            events.delete(event);
        }
      }
      return events;
    };
    if (filter2.ids)
      and(this.iterateIds(filter2.ids));
    let time = null;
    if (filter2.since !== void 0) {
      time = Array.from(this.iterateTime(filter2.since, filter2.until));
      and(time);
    }
    for (const t of INDEXABLE_TAGS) {
      const key = `#${t}`;
      const values = filter2[key];
      if (values == null ? void 0 : values.length)
        and(this.iterateTag(t, values));
    }
    if (filter2.authors)
      and(this.iterateAuthors(filter2.authors));
    if (filter2.kinds)
      and(this.iterateKinds(filter2.kinds));
    if (filter2.since === void 0 && filter2.until !== void 0) {
      time = Array.from(this.iterateTime(filter2.since, filter2.until));
      and(time);
    }
    if (filter2.limit && time) {
      const limited = /* @__PURE__ */ new Set();
      for (const event of time) {
        if (limited.size >= filter2.limit)
          break;
        if (events.has(event))
          limited.add(event);
      }
      return limited;
    }
    return events;
  }
  /** Returns all events that match the filters */
  getEventsForFilters(filters) {
    if (filters.length === 0)
      throw new Error("No Filters");
    let events = /* @__PURE__ */ new Set();
    for (const filter2 of filters) {
      const filtered = this.getEventsForFilter(filter2);
      for (const event of filtered)
        events.add(event);
    }
    return events;
  }
  /** Remove the oldest events that are not claimed */
  prune(limit2 = 1e3) {
    let removed = 0;
    let cursor = this.events.first;
    while (cursor) {
      const event = cursor.value;
      if (!this.isClaimed(event)) {
        this.remove(event);
        removed++;
        if (removed >= limit2)
          break;
      }
      cursor = cursor.next;
    }
    return removed;
  }
  /** Resets the event set */
  reset() {
    this.events.clear();
    this.kinds.clear();
    this.authors.clear();
    this.tags.clear();
    this.created_at = [];
    this.replaceable.clear();
    this.claims = /* @__PURE__ */ new WeakMap();
  }
};

// node_modules/applesauce-core/dist/helpers/gift-wraps.js
var internalGiftWrapEvents = new EventSet();
var SealSymbol = Symbol.for("seal");
var RumorSymbol = Symbol.for("rumor");
var GiftWrapSymbol = Symbol.for("gift-wrap");
function addParentSealReference(rumor, seal) {
  const parents = Reflect.get(rumor, SealSymbol);
  if (!parents)
    Reflect.set(rumor, SealSymbol, /* @__PURE__ */ new Set([seal]));
  else
    parents.add(seal);
}
function removeParentSealReference(rumor, seal) {
  const parents = Reflect.get(rumor, SealSymbol);
  if (parents)
    parents.delete(seal);
}
function isRumor(event) {
  var _a;
  if (event === void 0 || event === null)
    return false;
  return ((_a = event.id) == null ? void 0 : _a.length) === 64 && !("sig" in event) && typeof event.pubkey === "string" && event.pubkey.length === 64 && typeof event.content === "string" && Array.isArray(event.tags) && typeof event.created_at === "number" && event.created_at > 0;
}
function getSealGiftWrap(seal) {
  return Reflect.get(seal, GiftWrapSymbol);
}
function getRumorSeals(rumor) {
  let set = Reflect.get(rumor, SealSymbol);
  if (!set) {
    set = /* @__PURE__ */ new Set();
    Reflect.set(rumor, SealSymbol, set);
  }
  return Array.from(set);
}
function getRumorGiftWraps(rumor) {
  const giftWraps = /* @__PURE__ */ new Set();
  const seals = getRumorSeals(rumor);
  for (const seal of seals) {
    const upstream = getSealGiftWrap(seal);
    if (upstream)
      giftWraps.add(upstream);
  }
  return Array.from(giftWraps);
}
function isSealLocked(seal) {
  return isEncryptedContentLocked(seal);
}
function getSealRumor(seal) {
  const cached = Reflect.get(seal, RumorSymbol);
  if (cached)
    return cached;
  const plaintext = getEncryptedContent(seal);
  if (!plaintext)
    return void 0;
  let rumor = JSON.parse(plaintext);
  const existing = internalGiftWrapEvents.getEvent(rumor.id);
  if (existing)
    rumor = existing;
  else
    internalGiftWrapEvents.add(rumor);
  addParentSealReference(rumor, seal);
  Reflect.set(seal, RumorSymbol, rumor);
  return rumor;
}
function getGiftWrapSeal(gift) {
  const cached = Reflect.get(gift, SealSymbol);
  if (cached)
    return cached;
  const plaintext = getEncryptedContent(gift);
  if (!plaintext)
    return void 0;
  let seal = JSON.parse(plaintext);
  const existing = internalGiftWrapEvents.getEvent(seal.id);
  if (existing) {
    seal = existing;
  } else {
    verifyEvent(seal);
    internalGiftWrapEvents.add(seal);
    Reflect.set(seal, GiftWrapSymbol, gift);
  }
  Reflect.set(gift, SealSymbol, seal);
  return seal;
}
function getGiftWrapRumor(gift) {
  const seal = getGiftWrapSeal(gift);
  if (!seal)
    return void 0;
  return getSealRumor(seal);
}
function isGiftWrapLocked(gift) {
  if (isEncryptedContentLocked(gift))
    return true;
  else {
    const seal = getGiftWrapSeal(gift);
    if (!seal || isSealLocked(seal))
      return true;
    else
      return false;
  }
}
async function unlockSeal(seal, signer) {
  if (isEncryptedContentLocked(seal))
    await unlockEncryptedContent(seal, seal.pubkey, signer);
  const rumor = getSealRumor(seal);
  if (!rumor)
    throw new Error("Failed to read rumor in gift wrap");
  if (rumor.pubkey !== seal.pubkey)
    throw new Error("Seal author does not match rumor author");
  return rumor;
}
async function unlockGiftWrap(gift, signer) {
  if (isEncryptedContentLocked(gift))
    await unlockEncryptedContent(gift, gift.pubkey, signer);
  const seal = getGiftWrapSeal(gift);
  if (!seal)
    throw new Error("Failed to read seal in gift wrap");
  const rumor = await unlockSeal(seal, signer);
  notifyEventUpdate(gift);
  return rumor;
}
function lockGiftWrap(gift) {
  const seal = getGiftWrapSeal(gift);
  if (seal) {
    const rumor = getSealRumor(seal);
    if (rumor)
      removeParentSealReference(rumor, seal);
    Reflect.deleteProperty(seal, GiftWrapSymbol);
    Reflect.deleteProperty(seal, RumorSymbol);
    lockEncryptedContent(seal);
  }
  Reflect.deleteProperty(gift, SealSymbol);
  lockEncryptedContent(gift);
}

// node_modules/applesauce-core/dist/helpers/encrypted-content-cache.js
var EncryptedContentFromCacheSymbol = Symbol.for("encrypted-content-from-cache");
function markEncryptedContentFromCache(event) {
  Reflect.set(event, EncryptedContentFromCacheSymbol, true);
}
function isEncryptedContentFromCache(event) {
  return Reflect.has(event, EncryptedContentFromCacheSymbol);
}
var log = logger.extend("EncryptedContentCache");
function persistEncryptedContent(eventStore, storage, fallback) {
  const storage$ = isObservable(storage) ? storage : of(storage);
  const getItem = async (storage2, event) => {
    return await storage2.getItem(event.id) || (fallback ? await fallback(event) : null);
  };
  const restore = eventStore.insert$.pipe(
    // Look for events that support encrypted content and are locked
    filter((e) => canHaveEncryptedContent(e.kind) && isEncryptedContentLocked(e)),
    // Get the encrypted content from storage
    mergeMap((event) => (
      // Wait for storage to be available
      storage$.pipe(switchMap((storage2) => combineLatest([of(event), getItem(storage2, event)])), catchError((error) => {
        log(`Failed to restore encrypted content for ${event.id}`, error);
        return EMPTY;
      }))
    ))
  ).subscribe(async ([event, content]) => {
    if (!content)
      return;
    markEncryptedContentFromCache(event);
    setEncryptedContentCache(event, content);
    log(`Restored encrypted content for ${event.id}`);
  });
  const restoreSeals = eventStore.update$.pipe(
    // Look for gift wraps that are unlocked
    filter((e) => e.kind === kinds_exports.GiftWrap && !isEncryptedContentLocked(e)),
    // Get the seal event
    map((gift) => getGiftWrapSeal(gift)),
    // Look for gift wraps with locked seals
    filter((seal) => seal !== void 0 && isEncryptedContentLocked(seal)),
    // Only attempt to unlock seals once
    distinct((seal) => seal.id),
    // Get encrypted content from storage
    mergeMap((seal) => (
      // Wait for storage to be available
      storage$.pipe(switchMap((storage2) => combineLatest([of(seal), getItem(storage2, seal)])), catchError((error) => {
        log(`Failed to restore encrypted content for ${seal.id}`, error);
        return EMPTY;
      }))
    ))
  ).subscribe(async ([seal, content]) => {
    if (!seal || !content)
      return;
    markEncryptedContentFromCache(seal);
    setEncryptedContentCache(seal, content);
    getSealRumor(seal);
    const gift = getSealGiftWrap(seal);
    if (gift)
      notifyEventUpdate(gift);
    log(`Restored encrypted content for ${seal.id}`);
  });
  const persist = combineLatest([merge(eventStore.update$, eventStore.insert$), storage$]).pipe(
    // Look for events that support encrypted content and are unlocked and not from the cache
    filter(([event]) => canHaveEncryptedContent(event.kind) && !isEncryptedContentLocked(event) && !isEncryptedContentFromCache(event)),
    // Only persist the encrypted content once
    distinct(([event]) => event.id)
  ).subscribe(async ([event, storage2]) => {
    try {
      const content = getEncryptedContent(event);
      if (content) {
        await storage2.setItem(event.id, content);
        log(`Persisted encrypted content for ${event.id}`);
      }
    } catch (error) {
      log(`Failed to persist encrypted content for ${event.id}`, error);
    }
  });
  const persistSeals = combineLatest([merge(eventStore.update$, eventStore.insert$), storage$]).pipe(
    // Look for gift wraps that are unlocked
    filter(([event]) => event.kind === kinds_exports.GiftWrap && !isEncryptedContentLocked(event)),
    // Get the seal event
    map(([gift, storage2]) => [getGiftWrapSeal(gift), storage2]),
    // Make sure the seal is defined
    filter(([seal]) => seal !== void 0),
    // Make sure seal is unlocked and not from cache
    filter(([seal]) => !isEncryptedContentLocked(seal) && !isEncryptedContentFromCache(seal)),
    // Only persist the seal once
    distinct(([seal]) => seal.id)
  ).subscribe(async ([seal, storage2]) => {
    if (!seal)
      return;
    try {
      const content = getEncryptedContent(seal);
      if (content) {
        await storage2.setItem(seal.id, content);
        log(`Persisted encrypted content for ${seal.id}`);
      }
    } catch (error) {
      log(`Failed to persist encrypted content for ${seal.id}`, error);
    }
  });
  return () => {
    restore.unsubscribe();
    persist.unsubscribe();
    restoreSeals.unsubscribe();
    persistSeals.unsubscribe();
  };
}

// node_modules/applesauce-core/dist/helpers/encryption.js
function isNIP04Encrypted(ciphertext) {
  const l = ciphertext.length;
  if (l < 28)
    return false;
  return ciphertext[l - 28] == "?" && ciphertext[l - 27] == "i" && ciphertext[l - 26] == "v" && ciphertext[l - 25] == "=";
}

// node_modules/applesauce-core/dist/helpers/event-cache.js
var log2 = logger.extend("event-cache");
function presistEventsToCache(eventStore, write, opts) {
  const time = (opts == null ? void 0 : opts.batchTime) ?? 5e3;
  const sub = eventStore.insert$.pipe(
    // Only select events that are not from the cache
    filter((e) => !isFromCache(e)),
    // Buffer events for 5 seconds
    (opts == null ? void 0 : opts.maxBatchSize) ? bufferTime(time, void 0, (opts == null ? void 0 : opts.maxBatchSize) ?? 100) : bufferTime(time),
    // Only select buffers with events
    filter((b) => b.length > 0)
  ).subscribe((events) => {
    write(events).then(() => log2(`Saved ${events.length} events to cache`)).catch((e) => log2(`Failed to save ${events.length} events to cache`, e));
  });
  return () => sub.unsubscribe();
}

// node_modules/applesauce-core/dist/helpers/file-metadata.js
function parseFileMetadataTags(tags) {
  const fields = {};
  let fallback = void 0;
  for (const [name, value] of tags) {
    switch (name) {
      case "fallback":
        fallback = fallback ? [...fallback, value] : [value];
        break;
      default:
        fields[name] = value;
        break;
    }
  }
  if (!fields.url)
    throw new Error("Missing required url in file metadata");
  const metadata = { url: fields.url, fallback };
  if (fields.size)
    metadata.size = parseInt(fields.size);
  if (fields.m)
    metadata.type = fields.m;
  if (fields.x)
    metadata.sha256 = fields.x;
  if (fields.ox)
    metadata.originalSha256 = fields.ox;
  if (fields.dim)
    metadata.dimensions = fields.dim;
  if (fields.magnet)
    metadata.magnet = fields.magnet;
  if (fields.i)
    metadata.infohash = fields.i;
  if (fields.thumb)
    metadata.thumbnail = fields.thumb;
  if (fields.image)
    metadata.image = fields.image;
  if (fields.summary)
    metadata.summary = fields.summary;
  if (fields.alt)
    metadata.alt = fields.alt;
  if (fields.blurhash)
    metadata.blurhash = fields.blurhash;
  return metadata;
}
function getFileMetadataFromImetaTag(tag) {
  const parts = tag.slice(1);
  const tags = [];
  for (const part of parts) {
    const match = part.match(/^(.+?)\s(.+)$/);
    if (match) {
      const [_, name, value] = match;
      tags.push([name, value]);
    }
  }
  return parseFileMetadataTags(tags);
}
var MediaAttachmentsSymbol = Symbol.for("media-attachments");
function getMediaAttachments(event) {
  return getOrComputeCachedValue(event, MediaAttachmentsSymbol, () => {
    return event.tags.filter((t) => t[0] === "imeta").map((tag) => {
      try {
        return getFileMetadataFromImetaTag(tag);
      } catch (error) {
        return void 0;
      }
    }).filter((a) => !!a);
  });
}
function getFileMetadata(file) {
  return parseFileMetadataTags(file.tags);
}
function getSha256FromURL(url) {
  if (typeof url === "string")
    url = new URL(url);
  const hashes = Array.from(url.pathname.matchAll(/[0-9a-f]{64}/gi));
  if (hashes.length > 0)
    return hashes[hashes.length - 1][0];
  return;
}

// node_modules/applesauce-core/dist/helpers/hashtag.js
function getHashtagTag(event, hashtag) {
  hashtag = stripInvisibleChar(hashtag.replace(/^#/, "").toLocaleLowerCase());
  return event.tags.filter((t) => t[0] === "t" && t[1]).find((t) => stripInvisibleChar(t[1].toLowerCase()) === hashtag);
}

// node_modules/applesauce-core/dist/helpers/highlight.js
var HighlightSourceEventPointerSymbol = Symbol.for("highlight-source-event-pointer");
var HighlightSourceAddressPointerSymbol = Symbol.for("highlight-source-address-pointer");
var HighlightAttributionSymbol = Symbol.for("highlight-attribution");
function getHighlightText(event) {
  return event.content;
}
function getHighlightSourceEventPointer(event) {
  return getOrComputeCachedValue(event, HighlightSourceEventPointerSymbol, () => {
    const eTag = event.tags.find(isETag);
    return eTag ? getEventPointerFromETag(eTag) : void 0;
  });
}
function getHighlightSourceAddressPointer(event) {
  return getOrComputeCachedValue(event, HighlightSourceAddressPointerSymbol, () => {
    const aTag = event.tags.find(isATag);
    return aTag ? getAddressPointerFromATag(aTag) : void 0;
  });
}
function getHighlightSourceUrl(event) {
  return getTagValue(event, "r");
}
function getHighlightAttributions(event) {
  return getOrComputeCachedValue(event, HighlightAttributionSymbol, () => {
    const attributions = [];
    const pTags = event.tags.filter(isPTag);
    for (const pTag of pTags) {
      const pointer = getProfilePointerFromPTag(pTag);
      const role = pTag[3] || "other";
      const entry = { ...pointer, role };
      attributions.push(entry);
    }
    return attributions;
  });
}
function getHighlightContext(event) {
  return getTagValue(event, "context");
}
function getHighlightComment(event) {
  return getTagValue(event, "comment");
}
function hasHighlightSource(event) {
  return !!(getHighlightSourceEventPointer(event) || getHighlightSourceAddressPointer(event) || getHighlightSourceUrl(event));
}

// node_modules/applesauce-core/dist/helpers/json.js
function safeParse(str) {
  try {
    return JSON.parse(str);
  } catch (error) {
    return void 0;
  }
}

// node_modules/applesauce-core/dist/helpers/legacy-messages.js
function isLegacyMessageLocked(event) {
  return isEncryptedContentLocked(event);
}
function getLegacyMessageCorraspondant(message, self) {
  const corraspondant = message.pubkey === self ? getTagValue(message, "p") : message.pubkey;
  if (!corraspondant)
    throw new Error("No corraspondant found");
  return corraspondant;
}
var getLegacyMessageReceiver = getLegacyMessageCorraspondant;
function getLegacyMessageSender(message) {
  return message.pubkey;
}
function getLegacyMessageParent(message) {
  return getTagValue(message, "e");
}
async function unlockLegacyMessage(message, self, signer) {
  const cached = getEncryptedContent(message);
  if (cached)
    return cached;
  const corraspondant = getLegacyMessageCorraspondant(message, self);
  return await unlockEncryptedContent(message, corraspondant, signer);
}
async function lockLegacyMessage(message) {
  lockEncryptedContent(message);
}

// node_modules/applesauce-core/dist/helpers/lists.js
var FAVORITE_RELAYS_KIND = 10012;
function getListTags(list, type) {
  switch (type) {
    case "public":
      return list.tags;
    case "hidden":
      return getHiddenTags(list) ?? [];
    default:
    case "all":
      return [...getHiddenTags(list) ?? [], ...list.tags];
  }
}
function isEventPointerInList(list, pointer, type) {
  const id = typeof pointer === "string" ? pointer : pointer.id;
  const tags = getListTags(list, type);
  return tags.some((t) => t[0] === "e" && t[1] === id);
}
function isAddressPointerInList(list, pointer, type) {
  const cord = typeof pointer === "string" ? pointer : getCoordinateFromAddressPointer(pointer);
  const tags = getListTags(list, type);
  return tags.some((t) => t[0] === "a" && t[1] === cord);
}
function isProfilePointerInList(list, pointer, type) {
  const pubkey = typeof pointer === "string" ? pointer : pointer.pubkey;
  const tags = getListTags(list, type);
  return tags.some((t) => t[0] === "p" && t[1] === pubkey);
}
function isEventInList(list, event) {
  return isReplaceable(event.kind) ? isAddressPointerInList(list, getAddressPointerForEvent(event)) : isEventPointerInList(list, event);
}
function getEventPointersFromList(list, type) {
  return processTags(getListTags(list, type), (tag) => isETag(tag) ? tag : void 0, getEventPointerFromETag);
}
function getAddressPointersFromList(list, type) {
  return processTags(getListTags(list, type), (t) => isATag(t) ? t : void 0, getAddressPointerFromATag);
}
function getProfilePointersFromList(list, type) {
  return processTags(getListTags(list, type), (t) => isPTag(t) ? t : void 0, getProfilePointerFromPTag);
}
function getRelaysFromList(list, type) {
  return mergeRelaySets(processTags(getListTags(list, type), (t) => t[0] === "relay" ? t[1] : void 0));
}
function isValidList(event) {
  try {
    if (isAddressableKind2(event.kind)) {
      getReplaceableIdentifier(event);
      return true;
    } else if (isReplaceableKind2(event.kind) && event.kind >= 1e4 && event.kind < 2e4) {
      return true;
    }
  } catch (error) {
  }
  return false;
}

// node_modules/@scure/base/lib/esm/index.js
function isBytes4(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes2(b, ...lengths) {
  if (!isBytes4(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function isArrayOf(isString, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber(n) {
  if (!Number.isSafeInteger(n))
    throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain2(...args) {
  const id = (a) => a;
  const wrap = (a, b) => (c) => a(b(c));
  const encode = args.map((x) => x.encode).reduceRight(wrap, id);
  const decode4 = args.map((x) => x.decode).reduce(wrap, id);
  return { encode, decode: decode4 };
}
function alphabet2(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l, i2) => [l, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
function join2(separator = "") {
  astr("join", separator);
  return {
    encode: (from2) => {
      astrArr("join.decode", from2);
      return from2.join(separator);
    },
    decode: (to) => {
      astr("join.decode", to);
      return to.split(separator);
    }
  };
}
function padding2(bits, chr = "=") {
  anumber(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last3 = end - 1;
        const byte = last3 * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize2(fn) {
  afn(fn);
  return { encode: (from2) => from2, decode: (to) => fn(to) };
}
function convertRadix3(data, from2, to) {
  if (from2 < 2)
    throw new Error(`convertRadix: invalid from=${from2}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d) => {
    anumber(d);
    if (d < 0 || d >= from2)
      throw new Error(`invalid integer: ${d}`);
    return d;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from2 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from2 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to;
      carry = digitBase % to;
      const rounded = Math.floor(div);
      digits[i2] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd2 = (a, b) => b === 0 ? a : gcd2(b, a % b);
var radix2carry2 = (from2, to) => from2 + (to - gcd2(from2, to));
var powers = (() => {
  let res = [];
  for (let i2 = 0; i2 < 40; i2++)
    res.push(2 ** i2);
  return res;
})();
function convertRadix22(data, from2, to, padding3) {
  aArr(data);
  if (from2 <= 0 || from2 > 32)
    throw new Error(`convertRadix2: wrong from=${from2}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry2(from2, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from2} to=${to} carryBits=${radix2carry2(from2, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const max2 = powers[from2];
  const mask = powers[to] - 1;
  const res = [];
  for (const n of data) {
    anumber(n);
    if (n >= max2)
      throw new Error(`convertRadix2: invalid data word=${n} from=${from2}`);
    carry = carry << from2 | n;
    if (pos + from2 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from2}`);
    pos += from2;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    const pow3 = powers[pos];
    if (pow3 === void 0)
      throw new Error("invalid carry");
    carry &= pow3 - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding3 && pos >= from2)
    throw new Error("Excess padding");
  if (!padding3 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding3 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix3(num) {
  anumber(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes4) => {
      if (!isBytes4(bytes4))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix3(Array.from(bytes4), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix3(digits, num, _256));
    }
  };
}
function radix22(bits, revPadding = false) {
  anumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry2(8, bits) > 32 || radix2carry2(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes4) => {
      if (!isBytes4(bytes4))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix22(Array.from(bytes4), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix22(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper2(fn) {
  afn(fn);
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e) {
    }
  };
}
var base162 = chain2(radix22(4), alphabet2("0123456789ABCDEF"), join2(""));
var base322 = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding2(5), join2(""));
var base32nopad = chain2(radix22(5), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join2(""));
var base32hex2 = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding2(5), join2(""));
var base32hexnopad = chain2(radix22(5), alphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join2(""));
var base32crockford2 = chain2(radix22(5), alphabet2("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize2((s) => s.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var decodeBase64Builtin = (s, isUrl) => {
  astr("base64", s);
  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
  const alphabet3 = isUrl ? "base64url" : "base64";
  if (s.length > 0 && !re.test(s))
    throw new Error("invalid base64");
  return Uint8Array.fromBase64(s, { alphabet: alphabet3, lastChunkHandling: "strict" });
};
var base642 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64();
  },
  decode(s) {
    return decodeBase64Builtin(s, false);
  }
} : chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding2(6), join2(""));
var base64nopad = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join2(""));
var base64url2 = hasBase64Builtin ? {
  encode(b) {
    abytes2(b);
    return b.toBase64({ alphabet: "base64url" });
  },
  decode(s) {
    return decodeBase64Builtin(s, true);
  }
} : chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding2(6), join2(""));
var base64urlnopad = chain2(radix22(6), alphabet2("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join2(""));
var genBase582 = (abc) => chain2(radix3(58), alphabet2(abc), join2(""));
var base582 = genBase582("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr2 = genBase582("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp2 = genBase582("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var BECH_ALPHABET2 = chain2(alphabet2("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
var POLYMOD_GENERATORS2 = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod2(pre) {
  const b = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS2.length; i2++) {
    if ((b >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS2[i2];
  }
  return chk;
}
function bechChecksum2(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c = prefix.charCodeAt(i2);
    if (c < 33 || c > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod2(chk) ^ c >> 5;
  }
  chk = bech32Polymod2(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod2(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v of words)
    chk = bech32Polymod2(chk) ^ v;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod2(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET2.encode(convertRadix22([chk % powers[30]], 30, 5, false));
}
function genBech322(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix22(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper2(fromWords);
  function encode(prefix, words, limit2 = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes4(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit2 !== false && actualLength > limit2)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit2}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum2(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET2.encode(words)}${sum}`;
  }
  function decode4(str, limit2 = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit2 !== false && slen > limit2)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit2})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET2.decode(data).slice(0, -6);
    const sum = bechChecksum2(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper2(decode4);
  function decodeToBytes(str) {
    const { prefix, words } = decode4(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes4) {
    return encode(prefix, toWords(bytes4));
  }
  return {
    encode,
    decode: decode4,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech322 = genBech322("bech32");
var bech32m2 = genBech322("bech32m");
var hasHexBuiltin2 = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes2(data);
    return data.toHex();
  },
  decode(s) {
    astr("hex", s);
    return Uint8Array.fromHex(s);
  }
};
var hex2 = hasHexBuiltin2 ? hexBuiltin : chain2(radix22(4), alphabet2("0123456789abcdef"), join2(""), normalize2((s) => {
  if (typeof s !== "string" || s.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
  return s.toLowerCase();
}));

// node_modules/applesauce-core/dist/helpers/lnurl.js
var decoder = new TextDecoder();
function parseLightningAddress(address) {
  let [name, domain] = address.split("@");
  if (!name || !domain)
    return;
  return new URL(`https://${domain}/.well-known/lnurlp/${name}`);
}
function decodeLNURL(lnurl) {
  try {
    const { words, prefix } = bech322.decode(lnurl);
    if (prefix !== "lnurl")
      return;
    const str = decoder.decode(bech322.fromWords(words));
    return new URL(str);
  } catch (error) {
  }
  return void 0;
}
function parseLNURLOrAddress(addressOrLNURL) {
  if (addressOrLNURL.includes("@")) {
    return parseLightningAddress(addressOrLNURL);
  }
  return decodeLNURL(addressOrLNURL);
}
async function getInvoice(callback) {
  const { pr: payRequest } = await fetch(callback).then((res) => res.json());
  const amount = callback.searchParams.get("amount");
  if (!amount)
    throw new Error("Missing amount");
  if (payRequest) {
    const parsed = parseBolt11(payRequest);
    if (parsed.amount !== parseInt(amount))
      throw new Error("Incorrect amount");
    return payRequest;
  } else
    throw new Error("Failed to get invoice");
}

// node_modules/applesauce-core/dist/helpers/mailboxes.js
var MailboxesInboxesSymbol = Symbol.for("mailboxes-inboxes");
var MailboxesOutboxesSymbol = Symbol.for("mailboxes-outboxes");
function getInboxes(event) {
  return getOrComputeCachedValue(event, MailboxesInboxesSymbol, () => {
    const inboxes = [];
    for (const tag of event.tags) {
      const [name, url, mode] = tag;
      if (name === "r" && url && isSafeRelayURL(url) && !inboxes.includes(url) && (mode === "read" || mode === void 0)) {
        inboxes.push(normalizeURL2(url));
      }
    }
    return inboxes;
  });
}
function getOutboxes(event) {
  return getOrComputeCachedValue(event, MailboxesOutboxesSymbol, () => {
    const outboxes = [];
    for (const tag of event.tags) {
      const [name, url, mode] = tag;
      if (name === "r" && url && isSafeRelayURL(url) && !outboxes.includes(url) && (mode === "write" || mode === void 0)) {
        outboxes.push(normalizeURL2(url));
      }
    }
    return outboxes;
  });
}

// node_modules/applesauce-core/dist/helpers/messages.js
function groupMessageEvents(messages, buffer2 = 5 * 60) {
  const groups = [];
  for (const message of messages) {
    const group = groups[groups.length - 1];
    const last3 = group == null ? void 0 : group[0];
    if (group && (last3 == null ? void 0 : last3.pubkey) === message.pubkey && Math.abs(message.created_at - last3.created_at) < buffer2)
      group.push(message);
    else
      groups.push([message]);
  }
  return groups;
}
function getConversationParticipants(participants) {
  let participantList;
  if (typeof participants === "string") {
    participantList = participants.split(":");
  } else if (Array.isArray(participants)) {
    participantList = participants;
  } else {
    if (participants.kind !== kinds_exports.EncryptedDirectMessage && participants.kind !== kinds_exports.PrivateDirectMessage)
      throw new Error("Can only get participants from direct message event (4, 14)");
    participantList = [participants.pubkey, ...participants.tags.filter(isPTag).map((t) => t[1])];
  }
  return Array.from(new Set(participantList));
}
function createConversationIdentifier(...participants) {
  return Array.from(new Set(participants.flat())).sort().join(":");
}
function getConversationIdentifierFromMessage(message) {
  return createConversationIdentifier(getConversationParticipants(message));
}

// node_modules/applesauce-core/dist/helpers/mutes.js
var MutePublicSymbol = Symbol.for("mute-public");
var MuteHiddenSymbol = Symbol.for("mute-hidden");
function mergeMutes(...mutes) {
  const mute = { pubkeys: /* @__PURE__ */ new Set(), threads: /* @__PURE__ */ new Set(), hashtags: /* @__PURE__ */ new Set(), words: /* @__PURE__ */ new Set() };
  for (const m of mutes) {
    for (const pubkey of m.pubkeys)
      mute.pubkeys.add(pubkey);
    for (const thread of m.threads)
      mute.threads.add(thread);
    for (const hashtag of m.hashtags)
      mute.hashtags.add(hashtag);
    for (const word of m.words)
      mute.words.add(word);
  }
  return mute;
}
function parseMutedTags(tags) {
  const pubkeys = new Set(tags.filter(isPTag).map((t) => t[1]));
  const threads = new Set(tags.filter(isETag).map((t) => t[1]));
  const hashtags = new Set(tags.filter(isTTag).map((t) => t[1].toLocaleLowerCase()));
  const words = new Set(tags.filter((t) => t[0] === "word" && t[1]).map((t) => t[1].toLocaleLowerCase()));
  return { pubkeys, threads, hashtags, words };
}
function getMutedThings(mute) {
  const hidden = getHiddenMutedThings(mute);
  const mutes = getPublicMutedThings(mute);
  if (hidden)
    return mergeMutes(hidden, mutes);
  return mutes;
}
function getPublicMutedThings(mute) {
  return getOrComputeCachedValue(mute, MutePublicSymbol, () => parseMutedTags(mute.tags));
}
function getHiddenMutedThings(mute) {
  if (isHiddenTagsLocked(mute))
    return void 0;
  return getOrComputeCachedValue(mute, MuteHiddenSymbol, () => parseMutedTags(getHiddenTags(mute)));
}
function createMutedWordsRegExp(mutedWords) {
  const escapedWords = mutedWords.map((word) => word.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
  return new RegExp(`\\b(${escapedWords.join("|")})\\b`, "gi");
}
function matchMutes(mutes, event) {
  var _a;
  if (mutes.pubkeys.size > 0) {
    if (mutes.pubkeys.has(event.pubkey))
      return true;
  }
  if (mutes.hashtags.size > 0) {
    const tags = getIndexableTags(event);
    for (let tag of mutes.hashtags) {
      if (tags.has("t:" + tag))
        return true;
    }
  }
  if (mutes.threads.size > 0 && event.kind === kinds_exports.ShortTextNote) {
    const refs = getNip10References(event);
    if (((_a = refs.root) == null ? void 0 : _a.e) && mutes.threads.has(refs.root.e.id))
      return true;
  }
  if (mutes.words.size > 0) {
    const regExp = createMutedWordsRegExp(Array.from(mutes.words));
    if (regExp.test(event.content))
      return true;
  }
  return false;
}

// node_modules/applesauce-core/dist/helpers/picture-post.js
var PICTURE_POST_KIND = 20;
function getPicturePostAttachments(post) {
  return getMediaAttachments(post);
}

// node_modules/applesauce-core/dist/helpers/poll.js
var POLL_KIND = 1068;
var POLL_RESPONSE_KIND = 1018;
var PollOptionsSymbol = Symbol.for("poll-options");
function getPollQuestion(event) {
  return event.content;
}
function getPollOptions(event) {
  return getOrComputeCachedValue(event, PollOptionsSymbol, () => {
    return event.tags.filter((tag) => tag[0] === "option" && tag.length >= 3).map((tag) => ({
      id: tag[1],
      label: tag[2]
    }));
  });
}
function getPollRelays(event) {
  return event.tags.filter((tag) => tag[0] === "relay" && tag.length >= 2).map((tag) => tag[1]);
}
function getPollType(event) {
  const type = getTagValue(event, "polltype");
  return type === "multiplechoice" || type === "singlechoice" ? type : "singlechoice";
}
function getPollEndsAt(event) {
  const endsAt = getTagValue(event, "endsAt");
  return endsAt ? parseInt(endsAt, 10) : void 0;
}
function getPollResponsePollId(event) {
  return getTagValue(event, "e");
}
function getPollResponseOptions(event) {
  return event.tags.filter((tag) => tag[0] === "response" && tag.length >= 2).map((tag) => tag[1]);
}
function getPollResponseVotes(poll, response) {
  if (poll.id !== getPollResponsePollId(response))
    return;
  const pollOptions = getPollOptions(poll);
  const responseOptions = getPollResponseOptions(response);
  const votes = responseOptions.filter((opts) => pollOptions.some((option) => option.id === opts));
  const type = getPollType(poll);
  if (type === "singlechoice")
    return votes.length === 1 ? [votes[0]] : void 0;
  return Array.from(new Set(votes));
}

// node_modules/applesauce-core/dist/helpers/reactions.js
var isInteger = (str) => Number.isInteger(Number(str));
var ReactionEventPointerSymbol = Symbol("reaction-event-pointer");
var ReactionAddressPointerSymbol = Symbol("reaction-address-pointer");
function getReactionEventPointer(event) {
  return getOrComputeCachedValue(event, ReactionEventPointerSymbol, () => {
    const eTag = event.tags.find(isETag);
    if (!eTag)
      return void 0;
    const pointer = getEventPointerFromETag(eTag);
    if (!pointer)
      return void 0;
    const k = getTagValue(event, "k");
    if (k && isInteger(k))
      pointer.kind = parseInt(k);
    if (!pointer.author) {
      const p = event.tags.find(isPTag);
      if (p) {
        const author = getProfilePointerFromPTag(p);
        pointer.author = author.pubkey;
        if (author.relays)
          pointer.relays = mergeRelaySets(author.relays, pointer.relays);
      }
    }
    return pointer;
  });
}
function getReactionAddressPointer(event) {
  return getOrComputeCachedValue(event, ReactionAddressPointerSymbol, () => {
    const aTag = event.tags.find(isATag);
    if (!aTag)
      return void 0;
    const pointer = getAddressPointerFromATag(aTag);
    if (!pointer)
      return void 0;
    const p = event.tags.find(isPTag);
    if (p) {
      const author = getProfilePointerFromPTag(p);
      if (author.relays)
        pointer.relays = mergeRelaySets(author.relays, pointer.relays);
    }
    return pointer;
  });
}

// node_modules/applesauce-core/dist/helpers/reports.js
var ParsedReportSymbol = Symbol("parsed-report");
var ReportReason;
(function(ReportReason2) {
  ReportReason2["nudity"] = "nudity";
  ReportReason2["malware"] = "malware";
  ReportReason2["profanity"] = "profanity";
  ReportReason2["illegal"] = "illegal";
  ReportReason2["spam"] = "spam";
  ReportReason2["impersonation"] = "impersonation";
  ReportReason2["other"] = "other";
})(ReportReason || (ReportReason = {}));
function getReported(report) {
  return getOrComputeCachedValue(report, ParsedReportSymbol, () => {
    const p = report.tags.find(isPTag);
    if (!p)
      throw new Error("Report missing p tag");
    const comment = report.content ? report.content.trim() : void 0;
    const e = report.tags.find(isETag);
    if (e) {
      const blobs = report.tags.filter((t) => t[0] === "x" && t[1]).map((t) => t[1]);
      return {
        type: "event",
        event: report,
        comment,
        id: e[1],
        pubkey: p[1],
        reason: e[2],
        blobs
      };
    }
    return { type: "user", event: report, comment, pubkey: p[1], reason: p[2] };
  });
}

// node_modules/applesauce-core/dist/helpers/share.js
var SharedEventSymbol = Symbol.for("shared-event");
var SharedEventPointerSymbol = Symbol.for("shared-event-pointer");
var SharedAddressPointerSymbol = Symbol.for("shared-address-pointer");
function getSharedEventPointer(event) {
  return getOrComputeCachedValue(event, SharedEventPointerSymbol, () => nip18_exports.getRepostedEventPointer(event));
}
function getSharedAddressPointer(event) {
  return getOrComputeCachedValue(event, SharedAddressPointerSymbol, () => {
    const a = event.tags.find(isATag);
    if (!a)
      return void 0;
    return getAddressPointerFromATag(a);
  });
}
function getEmbededSharedEvent(event) {
  return getOrComputeCachedValue(event, SharedEventSymbol, () => nip18_exports.getRepostedEvent(event));
}
var parseSharedEvent = getEmbededSharedEvent;

// node_modules/applesauce-core/dist/helpers/stream-chat.js
function getStreamChatMessageStream(message) {
  const tag = message.tags.find(isATag);
  if (!tag)
    return void 0;
  return getAddressPointerFromATag(tag);
}

// node_modules/applesauce-core/dist/helpers/stream.js
function getStreamTitle(stream) {
  return getTagValue(stream, "title");
}
function getStreamSummary(stream) {
  return getTagValue(stream, "summary");
}
function getStreamImage(stream) {
  return getTagValue(stream, "image");
}
var TWO_WEEKS = 60 * 60 * 24 * 14;
function getStreamStatus(stream) {
  if (stream.created_at < unixNow() - TWO_WEEKS)
    return "ended";
  else
    return getTagValue(stream, "status") || "ended";
}
function getStreamHost(stream) {
  let host = void 0;
  for (const tag of stream.tags) {
    if (isPTag(tag) && (!host || tag[3] && tag[3].toLowerCase() === "host")) {
      host = getProfilePointerFromPTag(tag);
    }
  }
  return host || { pubkey: stream.pubkey };
}
function getStreamParticipants(stream) {
  return stream.tags.filter((t) => isPTag(t) && t[3]).map((t) => ({ ...getProfilePointerFromPTag(t), role: t[3].toLowerCase() }));
}
function getStreamGoalPointer(stream) {
  const goalTag = stream.tags.find((t) => t[0] === "goal");
  return goalTag && addRelayHintsToPointer(getEventPointerFromETag(goalTag), getStreamRelays(stream));
}
function getStreamStreamingURLs(stream) {
  return stream.tags.filter((t) => t[0] === "streaming").map((t) => t[1]);
}
function getStreamRecording(stream) {
  return getTagValue(stream, "recording");
}
function getStreamRelays(stream) {
  for (const tag of stream.tags) {
    if (tag[0] === "relays")
      return mergeRelaySets(tag.slice(1));
  }
  return void 0;
}
function getStreamStartTime(stream) {
  const str = getTagValue(stream, "starts");
  return str ? parseInt(str) : void 0;
}
function getStreamEndTime(stream) {
  const str = getTagValue(stream, "ends");
  return str ? parseInt(str) : getStreamStatus(stream) === "ended" ? stream.created_at : void 0;
}
function getStreamViewers(stream) {
  const viewers = getTagValue(stream, "current_participants");
  return viewers ? parseInt(viewers) : void 0;
}
function getStreamMaxViewers(stream) {
  const viewers = getTagValue(stream, "total_participants");
  return viewers ? parseInt(viewers) : void 0;
}
function getStreamHashtags(stream) {
  return stream.tags.filter((t) => t[0] === "t").map((t) => t[1]);
}

// node_modules/applesauce-core/dist/helpers/threading.js
var Nip10ThreadRefsSymbol = Symbol.for("nip10-thread-refs");
function getEventPointerFromThreadTag(tag) {
  if (!tag[1])
    throw new Error("Missing event id in tag");
  let pointer = { id: tag[1] };
  if (tag[2] && isSafeRelayURL(tag[2]))
    pointer.relays = [tag[2]];
  if (tag[0] === "e" && (tag[3] === "root" || tag[3] === "reply" || tag[3] === "mention") && tag[4] && tag[4].length === 64) {
    pointer.author = tag[4];
  }
  return pointer;
}
function interpretThreadTags(tags) {
  const eTags = tags.filter((t) => t[0] === "e" && t[1]);
  const aTags = tags.filter((t) => t[0] === "a" && t[1]);
  let rootETag = eTags.find((t) => t[3] === "root");
  let replyETag = eTags.find((t) => t[3] === "reply");
  let rootATag = aTags.find((t) => t[3] === "root");
  let replyATag = aTags.find((t) => t[3] === "reply");
  if (!rootETag || !replyETag) {
    rootETag = replyETag = rootETag || replyETag;
  }
  if (!rootATag || !replyATag) {
    rootATag = replyATag = rootATag || replyATag;
  }
  if (!rootETag && !replyETag) {
    const legacyETags = eTags.filter((t) => {
      if (t[3])
        return false;
      return true;
    });
    if (legacyETags.length >= 1) {
      rootETag = legacyETags[0];
      replyETag = legacyETags[legacyETags.length - 1] ?? rootETag;
    }
  }
  return {
    root: rootETag || rootATag ? { e: rootETag, a: rootATag } : void 0,
    reply: replyETag || replyATag ? { e: replyETag, a: replyATag } : void 0
  };
}
function getNip10References(event) {
  return getOrComputeCachedValue(event, Nip10ThreadRefsSymbol, () => {
    const tags = interpretThreadTags(event.tags);
    let root;
    if (tags.root) {
      try {
        root = {
          e: tags.root.e && getEventPointerFromThreadTag(tags.root.e),
          a: tags.root.a && getAddressPointerFromATag(tags.root.a)
        };
      } catch (error) {
      }
    }
    let reply;
    if (tags.reply) {
      try {
        reply = {
          e: tags.reply.e && getEventPointerFromThreadTag(tags.reply.e),
          a: tags.reply.a && getAddressPointerFromATag(tags.reply.a)
        };
      } catch (error) {
      }
    }
    return {
      root,
      reply
    };
  });
}

// node_modules/applesauce-core/dist/helpers/user-status.js
var UserStatusPointerSymbol = Symbol.for("user-status-pointer");
function getStatusPointer(status) {
  const pTag = status.tags.find((t) => t[0] === "p" && t[1]);
  if (pTag)
    return { type: "nprofile", data: getProfilePointerFromPTag(pTag) };
  const eTag = status.tags.find((t) => t[0] === "e" && t[1]);
  if (eTag)
    return { type: "nevent", data: getEventPointerFromETag(eTag) };
  const aTag = status.tags.find((t) => t[0] === "a" && t[1]);
  if (aTag)
    return { type: "naddr", data: getAddressPointerFromATag(aTag) };
  const rTag = status.tags.find((t) => t[0] === "r" && t[1]);
  if (rTag)
    return { type: "url", data: rTag[1] };
  return null;
}
function getUserStatusPointer(status) {
  return getOrComputeCachedValue(status, UserStatusPointerSymbol, () => getStatusPointer(status));
}

// node_modules/applesauce-core/dist/helpers/wrapped-messages.js
function getWrappedMessageSubject(message) {
  return getTagValue(message, "subject");
}
function getWrappedMessageParent(message) {
  return getTagValue(message, "e");
}
function getWrappedMesssageSender(message) {
  return message.pubkey;
}
function getWrappedMessageReceiver(message) {
  return getConversationParticipants(message).filter((p) => p !== message.pubkey)[0];
}

// node_modules/applesauce-core/dist/helpers/zap.js
var ZapRequestSymbol = Symbol.for("zap-request");
var ZapSenderSymbol = Symbol.for("zap-sender");
var ZapReceiverSymbol = Symbol.for("zap-receiver");
var ZapInvoiceSymbol = Symbol.for("zap-bolt11");
var ZapEventPointerSymbol = Symbol.for("zap-event-pointer");
var ZapAddressPointerSymbol = Symbol.for("zap-address-pointer");
function getZapSender(zap) {
  return getOrComputeCachedValue(zap, ZapSenderSymbol, () => {
    return getTagValue(zap, "P") || getZapRequest(zap).pubkey;
  });
}
function getZapRecipient(zap) {
  return getOrComputeCachedValue(zap, ZapReceiverSymbol, () => {
    const recipient = getTagValue(zap, "p");
    if (!recipient)
      throw new Error("Missing recipient");
    return recipient;
  });
}
function getZapPayment(zap) {
  return getOrComputeCachedValue(zap, ZapInvoiceSymbol, () => {
    const bolt11 = getTagValue(zap, "bolt11");
    return bolt11 ? parseBolt11(bolt11) : void 0;
  });
}
function getZapAddressPointer(zap) {
  return getOrComputeCachedValue(zap, ZapAddressPointerSymbol, () => {
    const a = zap.tags.find(isATag);
    return a ? getAddressPointerFromATag(a) : null;
  });
}
function getZapEventPointer(zap) {
  return getOrComputeCachedValue(zap, ZapEventPointerSymbol, () => {
    const e = zap.tags.find(isETag);
    return e ? getEventPointerFromETag(e) : null;
  });
}
function getZapPreimage(zap) {
  return getTagValue(zap, "preimage");
}
function getZapRequest(zap) {
  return getOrComputeCachedValue(zap, ZapRequestSymbol, () => {
    const description = getTagValue(zap, "description");
    if (!description)
      throw new Error("Missing description tag");
    const error = nip57_exports.validateZapRequest(description);
    if (error)
      throw new Error(error);
    return JSON.parse(description);
  });
}
function isValidZap(zap) {
  if (!zap)
    return false;
  if (zap.kind !== kinds_exports.Zap)
    return false;
  try {
    getZapRequest(zap);
    getZapRecipient(zap);
    return true;
  } catch (error) {
    return false;
  }
}
function getZapSplits(event) {
  const tags = event.tags.filter((t) => t[0] === "zap" && t[1] && t[3]);
  if (tags.length > 0) {
    const targets = tags.map((t) => ({ pubkey: t[1], relay: t[2], weight: parseFloat(t[3]) })).filter((p) => Number.isFinite(p.weight));
    const total = targets.reduce((v, p) => v + p.weight, 0);
    return targets.map((p) => ({ ...p, percent: p.weight / total }));
  }
  return void 0;
}

// node_modules/applesauce-core/dist/observable/claim-events.js
function claimEvents(claims) {
  return (source) => {
    const seen = /* @__PURE__ */ new Set();
    return source.pipe(
      // claim all events
      tap((message) => {
        if (message === void 0)
          return;
        if (Array.isArray(message)) {
          for (const event of message) {
            seen.add(event);
            claims.claim(event, source);
          }
        } else {
          seen.add(message);
          claims.claim(message, source);
        }
      }),
      // remove claims on cleanup
      finalize(() => {
        for (const e of seen)
          claims.removeClaim(e, source);
      })
    );
  };
}

// node_modules/applesauce-core/dist/observable/claim-latest.js
function claimLatest(claims) {
  return (source) => {
    let latest = void 0;
    return source.pipe(tap((event) => {
      if (latest)
        claims.removeClaim(latest, source);
      if (event)
        claims.claim(event, source);
      latest = event;
    }), finalize(() => {
      if (latest)
        claims.removeClaim(latest, source);
    }));
  };
}

// node_modules/applesauce-core/dist/observable/with-immediate-value.js
function withImmediateValueOrDefault(defaultValue) {
  return (source) => new Observable((observer) => {
    let seen = false;
    const sub = source.subscribe({
      next: (v) => {
        seen = true;
        observer.next(v);
      },
      error: (err) => observer.error(err),
      complete: () => observer.complete()
    });
    if (!seen)
      observer.next(defaultValue);
    return sub;
  });
}

// node_modules/applesauce-core/dist/models/common.js
function EventModel(pointer) {
  if (typeof pointer === "string")
    pointer = { id: pointer };
  return (events) => merge(
    // get current event and ignore if there is none
    defer(() => {
      let event = events.getEvent(pointer.id);
      if (event)
        return of(event);
      if (!events.eventLoader)
        return EMPTY;
      return from(events.eventLoader(pointer)).pipe(filter((e) => !!e));
    }),
    // Listen for new events
    events.insert$.pipe(filter((e) => e.id === pointer.id)),
    // emit undefined when deleted
    events.removed(pointer.id).pipe(endWith(void 0))
  ).pipe(
    // claim all events
    claimLatest(events),
    // ignore duplicate events
    distinctUntilChanged((a, b) => (a == null ? void 0 : a.id) === (b == null ? void 0 : b.id)),
    // always emit undefined so the observable is synchronous
    withImmediateValueOrDefault(void 0)
  );
}
function ReplaceableModel(pointer) {
  return (events) => {
    let current = void 0;
    return merge(
      // lazily get current event
      defer(() => {
        let event = events.getReplaceable(pointer.kind, pointer.pubkey, pointer.identifier);
        if (event)
          return of(event);
        else if (pointer.identifier !== void 0) {
          if (!events.addressableLoader)
            return EMPTY;
          return from(events.addressableLoader(pointer)).pipe(filter((e) => !!e));
        } else {
          if (!events.replaceableLoader)
            return EMPTY;
          return from(events.replaceableLoader(pointer)).pipe(filter((e) => !!e));
        }
      }),
      // subscribe to new events
      events.insert$.pipe(filter((e) => e.pubkey == pointer.pubkey && e.kind === pointer.kind && (pointer.identifier !== void 0 ? getReplaceableIdentifier(e) === pointer.identifier : true)))
    ).pipe(
      // only update if event is newer
      distinctUntilChanged((prev, event) => {
        return prev.created_at >= event.created_at;
      }),
      // Hacky way to extract the current event so takeUntil can access it
      tap((event) => current = event),
      // complete when event is removed
      takeUntil(events.remove$.pipe(filter((e) => e.id === (current == null ? void 0 : current.id)))),
      // emit undefined when removed
      endWith(void 0),
      // keep the observable hot
      repeat(),
      // claim latest event
      claimLatest(events),
      // always emit undefined so the observable is synchronous
      withImmediateValueOrDefault(void 0)
    );
  };
}
function TimelineModel(filters, includeOldVersion) {
  filters = Array.isArray(filters) ? filters : [filters];
  return (events) => {
    const seen = /* @__PURE__ */ new Map();
    return defer(() => of(Array.from(events.getTimeline(filters)))).pipe(
      // claim existing events
      claimEvents(events),
      // subscribe to newer events
      mergeWith(events.insert$.pipe(
        filter((e) => matchFilters(filters, e)),
        // claim all new events
        claimEvents(events)
      )),
      // subscribe to delete events
      mergeWith(events.remove$.pipe(filter((e) => matchFilters(filters, e)), map((e) => e.id))),
      // build a timeline
      scan((timeline, event) => {
        if (typeof event === "string")
          return timeline.filter((e) => e.id !== event);
        if (Array.isArray(event)) {
          if (!includeOldVersion) {
            for (const e of event)
              if (isReplaceable(e.kind))
                seen.set(getEventUID(e), e);
          }
          return event;
        }
        let newTimeline = [...timeline];
        if (!includeOldVersion && isReplaceable(event.kind)) {
          const uid = getEventUID(event);
          const existing = seen.get(uid);
          if (existing && event.created_at < existing.created_at)
            return timeline;
          seen.set(uid, event);
          if (existing)
            newTimeline.slice(newTimeline.indexOf(existing), 1);
        }
        insertEventIntoDescendingList2(newTimeline, event);
        return newTimeline;
      }, []),
      // ignore changes that do not modify the timeline instance
      distinctUntilChanged(),
      // hacky hack to clear seen on unsubscribe
      finalize(() => seen.clear())
    );
  };
}
function EventsModel(ids) {
  return (events) => combineLatest(Object.fromEntries(ids.map((id) => [id, events.model(EventModel, { id })])));
}
function ReplaceableSetModel(pointers) {
  return (events) => combineLatest(Object.fromEntries(pointers.map((pointer) => [
    createReplaceableAddress(pointer.kind, pointer.pubkey, pointer.identifier),
    events.model(ReplaceableModel, pointer)
  ])));
}

// node_modules/applesauce-core/dist/observable/defined.js
function defined() {
  return (source) => source.pipe(filter((v) => v !== void 0 && v !== null));
}

// node_modules/applesauce-core/dist/observable/get-observable-value.js
function getObservableValue(observable2) {
  if (observable2 instanceof BehaviorSubject)
    return observable2.value;
  if (Reflect.has(observable2, "value"))
    return Reflect.get(observable2, "value");
  return firstValueFrom(observable2);
}

// node_modules/applesauce-core/dist/observable/map-events-timeline.js
function mapEventsToTimeline() {
  return scan((timeline, event) => insertEventIntoDescendingList2(timeline, event), []);
}

// node_modules/applesauce-core/dist/observable/map-events-to-store.js
function mapEventsToStore(store, removeDuplicates = true) {
  return (source) => source.pipe(
    // Map all events to the store
    // NOTE: map is used here because we want to return the single cononical version of the event so that distinct() can be used later
    map((event) => store.add(event)),
    // Ignore invalid events
    filter((e) => e !== null),
    // Remove duplicates if requested
    removeDuplicates ? distinct() : identity
  );
}

// node_modules/applesauce-core/dist/observable/simple-timeout.js
var TimeoutError2 = class extends Error {
};
function simpleTimeout(first2, message) {
  return timeout({ first: first2, with: () => throwError(() => new TimeoutError2(message ?? "Timeout")) });
}

// node_modules/applesauce-core/dist/observable/watch-event-updates.js
function watchEventUpdates(eventStore) {
  return (source) => {
    let latest;
    return merge(
      // Get the latest event
      source.pipe(tap((value) => latest = value)),
      // listen for updates
      eventStore.update$.pipe(filter((e) => e.id === (latest == null ? void 0 : latest.id)))
    );
  };
}
function watchEventsUpdates(eventStore) {
  return (source) => {
    let latest = [];
    return merge(
      // Get the latest event
      source.pipe(tap((value) => latest = value)),
      // listen for updates
      eventStore.update$.pipe(
        filter((e) => latest.includes(e)),
        // re-emit the array of events
        map(() => latest)
      )
    );
  };
}

// node_modules/applesauce-core/dist/models/contacts.js
function ContactsModel(user) {
  if (typeof user === "string")
    user = { pubkey: user };
  return (events) => events.replaceable({ kind: kinds_exports.Contacts, pubkey: user.pubkey, relays: user.relays }).pipe(
    // listen for event updates (hidden tags unlocked)
    watchEventUpdates(events),
    // Get all contacts
    map((e) => e ? getContacts(e) : [])
  );
}
function PublicContactsModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Contacts, pubkey).pipe(map((e) => e && getPublicContacts(e)));
}
function HiddenContactsModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Contacts, pubkey).pipe(
    // listen for event updates (hidden tags unlocked)
    watchEventUpdates(events),
    // Get hidden contacts
    map((e) => e && (getHiddenContacts(e) ?? null))
  );
}

// node_modules/applesauce-core/dist/models/index.js
var models_exports = {};
__export(models_exports, {
  BlockedRelaysModel: () => BlockedRelaysModel,
  CalendarEventRSVPsModel: () => CalendarEventRSVPsModel,
  CalendarEventsModel: () => CalendarEventsModel,
  ChannelHiddenModel: () => ChannelHiddenModel,
  ChannelMessagesModel: () => ChannelMessagesModel,
  ChannelMetadataModel: () => ChannelMetadataModel,
  ChannelMutedModel: () => ChannelMutedModel,
  CommentsModel: () => CommentsModel,
  ContactsModel: () => ContactsModel,
  EncryptedContentModel: () => EncryptedContentModel,
  EventModel: () => EventModel,
  EventZapsModel: () => EventZapsModel,
  EventsModel: () => EventsModel,
  FavoriteRelaySetsModel: () => FavoriteRelaySetsModel,
  FavoriteRelaysModel: () => FavoriteRelaysModel,
  GiftWrapRumorModel: () => GiftWrapRumorModel,
  GiftWrapsModel: () => GiftWrapsModel,
  HiddenContactsModel: () => HiddenContactsModel,
  HiddenMuteModel: () => HiddenMuteModel,
  LegacyMessageReplies: () => LegacyMessageReplies,
  LegacyMessageThreads: () => LegacyMessageThreads,
  LegacyMessagesGroup: () => LegacyMessagesGroup,
  LegacyMessagesGroups: () => LegacyMessagesGroups,
  MailboxesModel: () => MailboxesModel,
  MuteModel: () => MuteModel,
  ProfileModel: () => ProfileModel,
  PublicContactsModel: () => PublicContactsModel,
  PublicMuteModel: () => PublicMuteModel,
  ReactionsModel: () => ReactionsModel,
  ReceivedZapsModel: () => ReceivedZapsModel,
  ReplaceableModel: () => ReplaceableModel,
  ReplaceableSetModel: () => ReplaceableSetModel,
  RepliesModel: () => RepliesModel,
  SearchRelaysModel: () => SearchRelaysModel,
  SentZapsModel: () => SentZapsModel,
  ThreadModel: () => ThreadModel,
  TimelineModel: () => TimelineModel,
  UserBlossomServersModel: () => UserBlossomServersModel,
  UserBookmarkModel: () => UserBookmarkModel,
  UserHiddenBookmarkModel: () => UserHiddenBookmarkModel,
  UserPinnedModel: () => UserPinnedModel,
  UserPublicBookmarkModel: () => UserPublicBookmarkModel,
  WrappedMessageReplies: () => WrappedMessageReplies,
  WrappedMessageThreads: () => WrappedMessageThreads,
  WrappedMessagesGroup: () => WrappedMessagesGroup,
  WrappedMessagesGroups: () => WrappedMessagesGroups,
  WrappedMessagesModel: () => WrappedMessagesModel
});

// node_modules/applesauce-core/dist/models/bookmarks.js
function UserBookmarkModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Mutelist, pubkey).pipe(
    // listen for event updates (hidden tags unlocked)
    watchEventUpdates(events),
    // Get all bookmarks
    map((event) => event && getBookmarks(event))
  );
}
function UserPublicBookmarkModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Mutelist, pubkey).pipe(map((event) => event && getPublicBookmarks(event)));
}
function UserHiddenBookmarkModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Mutelist, pubkey).pipe(
    // listen for event updates (hidden tags unlocked)
    watchEventUpdates(events),
    // Get hidden bookmarks
    map((event) => event && (getHiddenBookmarks(event) ?? null))
  );
}

// node_modules/applesauce-core/dist/models/calendar.js
function CalendarEventsModel(calendar) {
  return (events) => combineLatest(getCalendarAddressPointers(calendar).map((p) => events.replaceable(p.kind, p.pubkey, p.identifier).pipe(defined())));
}
function CalendarEventRSVPsModel(event) {
  return (events) => {
    return events.timeline({ kinds: [CALENDAR_EVENT_RSVP_KIND], "#a": [getReplaceableAddress(event)] });
  };
}

// node_modules/applesauce-core/dist/models/channels.js
function ChannelHiddenModel(channel, authors = []) {
  return (events) => {
    const hidden = /* @__PURE__ */ new Map();
    return events.filters([{ kinds: [kinds_exports.ChannelHideMessage], "#e": [channel.id], authors: [channel.pubkey, ...authors] }]).pipe(map((event) => {
      var _a;
      const reason = (_a = safeParse(event.content)) == null ? void 0 : _a.reason;
      for (const tag of event.tags) {
        if (tag[0] === "e" && tag[1])
          hidden.set(tag[1], reason ?? "");
      }
      return hidden;
    }));
  };
}
function ChannelMessagesModel(channel) {
  return (events) => events.timeline([{ kinds: [kinds_exports.ChannelMessage], "#e": [channel.id] }]);
}
function ChannelMetadataModel(channel) {
  return (events) => {
    const filters = [
      { ids: [channel.id] },
      { kinds: [kinds_exports.ChannelMetadata], "#e": [channel.id], authors: [channel.pubkey] }
    ];
    let latest = channel;
    return events.filters(filters).pipe(map((event) => {
      try {
        if (event.pubkey === latest.pubkey && event.created_at > latest.created_at) {
          latest = event;
        }
        return getChannelMetadataContent(latest);
      } catch (error) {
        return void 0;
      }
    }));
  };
}
function ChannelMutedModel(channel, authors = []) {
  return (events) => {
    const muted = /* @__PURE__ */ new Map();
    return events.filters([{ kinds: [kinds_exports.ChannelMuteUser], "#e": [channel.id], authors: [channel.pubkey, ...authors] }]).pipe(map((event) => {
      var _a;
      const reason = (_a = safeParse(event.content)) == null ? void 0 : _a.reason;
      for (const tag of event.tags) {
        if (tag[0] === "p" && tag[1])
          muted.set(tag[1], reason ?? "");
      }
      return muted;
    }));
  };
}

// node_modules/applesauce-core/dist/models/comments.js
function CommentsModel(parent2) {
  return (events) => {
    const filters = [{ kinds: [COMMENT_KIND], "#e": [parent2.id] }];
    if (isAddressableKind2(parent2.kind))
      filters.push({ kinds: [COMMENT_KIND], "#a": [getReplaceableAddress(parent2)] });
    return events.timeline(filters);
  };
}

// node_modules/applesauce-core/dist/models/encrypted-content.js
function EncryptedContentModel(event) {
  return (events) => (typeof event === "string" ? events.event(event) : of(event)).pipe(
    // Listen for updates to the event
    watchEventUpdates(events),
    // Get the encrypted content
    map((event2) => event2 && getEncryptedContent(event2))
  );
}

// node_modules/applesauce-core/dist/models/gift-wrap.js
function GiftWrapsModel(pubkey, locked) {
  return (store) => store.timeline({ kinds: [kinds_exports.GiftWrap], "#p": [pubkey] }).pipe(
    // Update the timeline when events are updated
    watchEventsUpdates(store),
    // If lock is specified filter on locked status
    locked !== void 0 ? map((events) => events.filter((e) => isGiftWrapLocked(e) === locked)) : identity
  );
}
function GiftWrapRumorModel(gift) {
  return (events) => (typeof gift === "string" ? events.event(gift) : of(gift)).pipe(
    // Listen for updates to the event
    watchEventUpdates(events),
    // Get the rumor event
    map((event) => event && getGiftWrapRumor(event))
  );
}

// node_modules/applesauce-core/dist/models/legacy-messages.js
function LegacyMessagesGroups(self) {
  return (store) => store.timeline({ kinds: [kinds_exports.EncryptedDirectMessage], "#p": [self] }).pipe(map((messages) => {
    const groups = {};
    for (const message of messages) {
      const id = getConversationIdentifierFromMessage(message);
      if (!groups[id] || groups[id].created_at < message.created_at)
        groups[id] = message;
    }
    return Object.values(groups).map((message) => ({
      id: getConversationIdentifierFromMessage(message),
      participants: getConversationParticipants(message),
      lastMessage: message
    }));
  }));
}
function LegacyMessagesGroup(self, corraspondant) {
  return (store) => store.timeline([
    {
      kinds: [kinds_exports.EncryptedDirectMessage],
      "#p": [self],
      authors: [corraspondant]
    },
    {
      kinds: [kinds_exports.EncryptedDirectMessage],
      "#p": [corraspondant],
      authors: [self]
    }
  ]);
}
function LegacyMessageThreads(self, corraspondant) {
  return (store) => store.model(LegacyMessagesGroup, self, corraspondant).pipe(map((messages) => messages.filter((message) => (
    // Only select messages that are not replies
    !getLegacyMessageParent(message) && // Check if message has any replies
    store.getByFilters({ "#e": [message.id], kinds: [kinds_exports.EncryptedDirectMessage] }).size > 0
  ))));
}
function LegacyMessageReplies(self, message) {
  const corraspondant = getLegacyMessageCorraspondant(message, self);
  return (store) => store.timeline([
    {
      kinds: [kinds_exports.EncryptedDirectMessage],
      "#p": [self],
      authors: [corraspondant],
      "#e": [message.id]
    },
    {
      kinds: [kinds_exports.EncryptedDirectMessage],
      "#p": [corraspondant],
      authors: [self],
      "#e": [message.id]
    }
  ]);
}

// node_modules/applesauce-core/dist/models/mailboxes.js
function MailboxesModel(user) {
  if (typeof user === "string")
    user = { pubkey: user };
  return (events) => events.replaceable({ kind: kinds_exports.RelayList, pubkey: user.pubkey, relays: user.relays }).pipe(map((event) => event && {
    inboxes: getInboxes(event),
    outboxes: getOutboxes(event)
  }));
}

// node_modules/applesauce-core/dist/models/mutes.js
function MuteModel(user) {
  if (typeof user === "string")
    user = { pubkey: user };
  return (events) => events.replaceable({ kind: kinds_exports.Mutelist, pubkey: user.pubkey, relays: user.relays }).pipe(
    // listen for event updates (hidden tags unlocked)
    watchEventUpdates(events),
    // Get all muted things
    map((event) => event && getMutedThings(event))
  );
}
function PublicMuteModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Mutelist, pubkey).pipe(map((event) => event && getPublicMutedThings(event)));
}
function HiddenMuteModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Mutelist, pubkey).pipe(
    // listen for event updates (hidden tags unlocked)
    watchEventUpdates(events),
    // Get hidden muted things
    map((event) => event && getHiddenMutedThings(event))
  );
}

// node_modules/applesauce-core/dist/models/pins.js
function UserPinnedModel(pubkey) {
  return (events) => events.replaceable(kinds_exports.Pinlist, pubkey).pipe(map((event) => event && processTags(event.tags.filter(isETag), getEventPointerFromETag)));
}

// node_modules/applesauce-core/dist/models/profile.js
function ProfileModel(user) {
  if (typeof user === "string")
    user = { pubkey: user };
  return (events) => events.replaceable({ kind: kinds_exports.Metadata, pubkey: user.pubkey, relays: user.relays }).pipe(
    // Filter out invalid profile events
    filter(isValidProfile),
    // Parse the profile event into a ProfileContent
    map((event) => event && getProfileContent(event)),
    // Ensure the model is synchronous
    withImmediateValueOrDefault(void 0)
  );
}

// node_modules/applesauce-core/dist/models/reactions.js
function ReactionsModel(event) {
  return (events) => events.timeline(isReplaceable(event.kind) ? [
    { kinds: [kinds_exports.Reaction], "#e": [event.id] },
    { kinds: [kinds_exports.Reaction], "#a": [getEventUID(event)] }
  ] : [
    {
      kinds: [kinds_exports.Reaction],
      "#e": [event.id]
    }
  ]);
}

// node_modules/applesauce-core/dist/models/relays.js
function FavoriteRelaysModel(pubkey, type) {
  return (events) => {
    return events.replaceable(FAVORITE_RELAYS_KIND, pubkey).pipe(type !== "public" ? watchEventUpdates(events) : map(identity), map((e) => e && getRelaysFromList(e, type)));
  };
}
function FavoriteRelaySetsModel(pubkey, type) {
  return (events) => {
    return events.replaceable(FAVORITE_RELAYS_KIND, pubkey).pipe(type !== "public" ? watchEventUpdates(events) : map(identity), map((e) => e && getAddressPointersFromList(e, type)));
  };
}
function SearchRelaysModel(pubkey, type) {
  return (events) => {
    return events.replaceable(kinds_exports.SearchRelaysList, pubkey).pipe(type !== "public" ? watchEventUpdates(events) : map(identity), map((e) => e && getRelaysFromList(e, type)));
  };
}
function BlockedRelaysModel(pubkey, type) {
  return (events) => {
    return events.replaceable(kinds_exports.BlockedRelaysList, pubkey).pipe(type !== "public" ? watchEventUpdates(events) : map(identity), map((e) => e && getRelaysFromList(e, type)));
  };
}

// node_modules/applesauce-core/dist/models/thread.js
var defaultOptions = {
  kinds: [kinds_exports.ShortTextNote]
};
function ThreadModel(root, opts) {
  const parentReferences = /* @__PURE__ */ new Map();
  const items = /* @__PURE__ */ new Map();
  const { kinds } = { ...defaultOptions, ...opts };
  let rootUID = "";
  const rootFilter = {};
  const replyFilter = { kinds };
  if (isAddressPointer(root)) {
    rootUID = getCoordinateFromAddressPointer(root);
    rootFilter.kinds = [root.kind];
    rootFilter.authors = [root.pubkey];
    rootFilter["#d"] = [root.identifier];
    replyFilter["#a"] = [rootUID];
  } else if (typeof root === "string") {
    rootUID = root;
    rootFilter.ids = [root];
    replyFilter["#e"] = [root];
  } else {
    rootUID = root.id;
    rootFilter.ids = [root.id];
    replyFilter["#e"] = [root.id];
  }
  return (events) => events.filters([rootFilter, replyFilter]).pipe(map((event) => {
    var _a, _b;
    if (!items.has(getEventUID(event))) {
      const refs = getNip10References(event);
      const replies = parentReferences.get(getEventUID(event)) || /* @__PURE__ */ new Set();
      const item = { event, refs, replies };
      for (const child of replies) {
        child.parent = item;
      }
      if (((_a = refs.reply) == null ? void 0 : _a.e) || ((_b = refs.reply) == null ? void 0 : _b.a)) {
        let uid = refs.reply.e ? refs.reply.e.id : getCoordinateFromAddressPointer(refs.reply.a);
        item.parent = items.get(uid);
        if (item.parent) {
          item.parent.replies.add(item);
        } else {
          let set = parentReferences.get(uid);
          if (!set) {
            set = /* @__PURE__ */ new Set();
            parentReferences.set(uid, set);
          }
          set.add(item);
        }
      }
      items.set(getEventUID(event), item);
    }
    return { root: items.get(rootUID), all: items };
  }));
}
function RepliesModel(event, overrideKinds) {
  return (events) => {
    const kinds = overrideKinds || event.kind === 1 ? [1, COMMENT_KIND] : [COMMENT_KIND];
    const filter2 = { kinds };
    if (isEvent(parent) || isEventPointer(event))
      filter2["#e"] = [event.id];
    const address = isAddressableKind2(event.kind) ? createReplaceableAddress(event.kind, event.pubkey, getTagValue(event, "d")) : void 0;
    if (address) {
      filter2["#a"] = [address];
    }
    return events.timeline(filter2).pipe(map((events2) => {
      return events2.filter((e) => {
        var _a, _b, _c, _d;
        const refs = interpretThreadTags(e.tags);
        return ((_b = (_a = refs.reply) == null ? void 0 : _a.e) == null ? void 0 : _b[1]) === event.id || ((_d = (_c = refs.reply) == null ? void 0 : _c.a) == null ? void 0 : _d[1]) === address;
      });
    }));
  };
}

// node_modules/applesauce-core/dist/models/wrapped-messages.js
function WrappedMessagesModel(self) {
  return (store) => store.timeline({ kinds: [kinds_exports.GiftWrap], "#p": [self] }).pipe(
    // Watch for updates to the gift wraps
    watchEventsUpdates(store),
    // Get rumors and filter out locked
    map((rumors) => rumors.map((gift) => getGiftWrapRumor(gift)).filter((e) => !!e).filter((e) => e.kind === kinds_exports.PrivateDirectMessage).sort((a, b) => b.created_at - a.created_at))
  );
}
function WrappedMessagesGroups(self) {
  return (store) => store.model(WrappedMessagesModel, self).pipe(map((messages) => {
    const groups = {};
    for (const message of messages) {
      const id = getConversationIdentifierFromMessage(message);
      if (!groups[id] || groups[id].created_at < message.created_at)
        groups[id] = message;
    }
    return Object.values(groups).map((message) => ({
      id: getConversationIdentifierFromMessage(message),
      participants: getConversationParticipants(message),
      lastMessage: message
    }));
  }));
}
function WrappedMessagesGroup(self, participants) {
  const identifier = createConversationIdentifier(self, participants);
  return (store) => store.model(WrappedMessagesModel, self).pipe(
    // Only select direct messages for this conversation
    map((rumors) => rumors.filter((rumor) => rumor.kind === kinds_exports.PrivateDirectMessage && // Only select message for this conversation (the identifier from the message will include "self")
    getConversationIdentifierFromMessage(rumor) === identifier))
  );
}
function WrappedMessageThreads(self, participants) {
  return (store) => store.model(WrappedMessagesGroup, self, participants).pipe(
    // Filter down messages to only include root messages that have replies
    map((rumors) => rumors.filter((rumor) => (
      // Only select root messages
      !getWrappedMessageParent(rumor) && // Check if message has any replies
      rumors.some((r) => getWrappedMessageParent(r) === rumor.id)
    )))
  );
}
function WrappedMessageReplies(self, message) {
  const conversation = getConversationIdentifierFromMessage(message);
  return (store) => store.model(WrappedMessagesGroup, self, conversation).pipe(
    // Only select replies to this message
    map((rumors) => rumors.filter((rumor) => getWrappedMessageParent(rumor) === message.id))
  );
}

// node_modules/applesauce-core/dist/models/zaps.js
function EventZapsModel(id) {
  return (events) => {
    if (isAddressPointer(id)) {
      return events.timeline([{ kinds: [kinds_exports.Zap], "#a": [getCoordinateFromAddressPointer(id)] }]).pipe(map((events2) => events2.filter(isValidZap)));
    } else {
      id = typeof id === "string" ? id : id.id;
      return events.timeline([{ kinds: [kinds_exports.Zap], "#e": [id] }]).pipe(map((events2) => events2.filter(isValidZap)));
    }
  };
}
function SentZapsModel(pubkey) {
  return (events) => events.timeline([{ kinds: [kinds_exports.Zap], authors: [pubkey] }]);
}
function ReceivedZapsModel(pubkey) {
  return (events) => events.timeline([{ kinds: [kinds_exports.Zap], "#a": [pubkey] }]);
}

// node_modules/applesauce-core/dist/event-store/event-store.js
var EventStore = class _EventStore {
  constructor() {
    __publicField(this, "database");
    /** Enable this to keep old versions of replaceable events */
    __publicField(this, "keepOldVersions", false);
    /** Enable this to keep expired events */
    __publicField(this, "keepExpired", false);
    /**
     * A method used to verify new events before added them
     * @returns true if the event is valid, false if it should be ignored
     */
    __publicField(this, "verifyEvent");
    /** A stream of new events added to the store */
    __publicField(this, "insert$");
    /** A stream of events that have been updated */
    __publicField(this, "update$");
    /** A stream of events that have been removed */
    __publicField(this, "remove$");
    /**
     * A method that will be called when an event isn't found in the store
     * @experimental
     */
    __publicField(this, "eventLoader");
    /**
     * A method that will be called when a replaceable event isn't found in the store
     * @experimental
     */
    __publicField(this, "replaceableLoader");
    /**
     * A method that will be called when an addressable event isn't found in the store
     * @experimental
     */
    __publicField(this, "addressableLoader");
    // delete state
    __publicField(this, "deletedIds", /* @__PURE__ */ new Set());
    __publicField(this, "deletedCoords", /* @__PURE__ */ new Map());
    __publicField(this, "expirations", /* @__PURE__ */ new Map());
    __publicField(this, "expirationTimeout", null);
    __publicField(this, "nextExpirationCheck", null);
    /** A directory of all active models */
    __publicField(this, "models", /* @__PURE__ */ new Map());
    /** How long a model should be kept "warm" while nothing is subscribed to it */
    __publicField(this, "modelKeepWarm", 6e4);
    this.database = new EventSet();
    this.database.onBeforeInsert = (event) => {
      if (this.verifyEvent && this.verifyEvent(event) === false)
        return false;
      else
        return true;
    };
    this.database.insert$.subscribe((event) => {
      Reflect.set(event, EventStoreSymbol, this);
    });
    this.database.remove$.subscribe((event) => {
      Reflect.deleteProperty(event, EventStoreSymbol);
    });
    this.insert$ = this.database.insert$;
    this.update$ = this.database.update$;
    this.remove$ = this.database.remove$;
  }
  checkDeleted(event) {
    var _a;
    if (typeof event === "string")
      return this.deletedIds.has(event);
    else {
      if (this.deletedIds.has(event.id))
        return true;
      if (isAddressableKind2(event.kind)) {
        const identifier = (_a = event.tags.find((t) => t[0] === "d")) == null ? void 0 : _a[1];
        const deleted = this.deletedCoords.get(createReplaceableAddress(event.kind, event.pubkey, identifier));
        if (deleted)
          return deleted > event.created_at;
      }
    }
    return false;
  }
  /** Adds an event to the expiration map */
  addExpiration(event) {
    const expiration = getExpirationTimestamp(event);
    if (expiration && Number.isFinite(expiration))
      this.expirations.set(event.id, expiration);
  }
  handleExpiringEvent(event) {
    const expiration = getExpirationTimestamp(event);
    if (!expiration)
      return;
    this.expirations.set(event.id, expiration);
    if (this.expirationTimeout && this.nextExpirationCheck && this.nextExpirationCheck < expiration)
      return;
    if (this.expirationTimeout)
      clearTimeout(this.expirationTimeout);
    const timeout2 = expiration - unixNow();
    this.expirationTimeout = setTimeout(this.pruneExpired.bind(this), timeout2 * 1e3 + 10);
    this.nextExpirationCheck = expiration;
  }
  /** Remove expired events from the store */
  pruneExpired() {
    const now2 = unixNow();
    for (const [id, expiration] of this.expirations) {
      if (expiration <= now2) {
        this.expirations.delete(id);
        this.remove(id);
      }
    }
    if (this.expirationTimeout)
      clearTimeout(this.expirationTimeout);
    this.nextExpirationCheck = null;
    this.expirationTimeout = null;
  }
  // handling delete events
  handleDeleteEvent(deleteEvent) {
    const ids = getDeleteIds(deleteEvent);
    for (const id of ids) {
      this.deletedIds.add(id);
      const event = this.database.getEvent(id);
      if (event)
        this.database.remove(event);
    }
    const coords = getDeleteCoordinates(deleteEvent);
    for (const coord of coords) {
      this.deletedCoords.set(coord, Math.max(this.deletedCoords.get(coord) ?? 0, deleteEvent.created_at));
      const parsed = parseCoordinate(coord);
      if (!parsed)
        continue;
      const events = this.database.getReplaceableHistory(parsed.kind, parsed.pubkey, parsed.identifier) ?? [];
      for (const event of events) {
        if (event.created_at < deleteEvent.created_at)
          this.database.remove(event);
      }
    }
  }
  /** Copies important metadata from and identical event to another */
  static mergeDuplicateEvent(source, dest) {
    const relays = getSeenRelays(source);
    if (relays) {
      for (const relay of relays)
        addSeenRelay(dest, relay);
    }
    const fromCache = Reflect.get(source, FromCacheSymbol);
    if (fromCache && !Reflect.get(dest, FromCacheSymbol))
      Reflect.set(dest, FromCacheSymbol, fromCache);
  }
  /**
   * Adds an event to the store and update subscriptions
   * @returns The existing event or the event that was added, if it was ignored returns null
   */
  add(event, fromRelay) {
    var _a;
    if (event.kind === kinds_exports.EventDeletion)
      this.handleDeleteEvent(event);
    if (this.checkDeleted(event))
      return event;
    const expiration = getExpirationTimestamp(event);
    if (this.keepExpired === false && expiration && expiration <= unixNow())
      return null;
    const identifier = isReplaceable(event.kind) ? (_a = event.tags.find((t) => t[0] === "d")) == null ? void 0 : _a[1] : void 0;
    if (!this.keepOldVersions && isReplaceable(event.kind)) {
      const existing = this.database.getReplaceableHistory(event.kind, event.pubkey, identifier);
      if (existing && existing.length > 0 && existing[0].created_at >= event.created_at) {
        _EventStore.mergeDuplicateEvent(event, existing[0]);
        return existing[0];
      }
    } else if (this.database.hasEvent(event.id)) {
      const existing = this.database.getEvent(event.id);
      if (existing) {
        _EventStore.mergeDuplicateEvent(event, existing);
        return existing;
      }
    }
    const inserted = this.database.add(event);
    if (inserted === null)
      return null;
    if (event !== inserted)
      _EventStore.mergeDuplicateEvent(event, inserted);
    if (fromRelay)
      addSeenRelay(inserted, fromRelay);
    if (!this.keepOldVersions && isReplaceable(event.kind)) {
      const existing = this.database.getReplaceableHistory(event.kind, event.pubkey, identifier);
      if (existing) {
        const older = Array.from(existing).filter((e) => e.created_at < event.created_at);
        for (const old of older)
          this.database.remove(old);
        if (existing.length !== older.length)
          return existing[0];
      }
    }
    if (this.keepExpired === false && expiration)
      this.handleExpiringEvent(inserted);
    return inserted;
  }
  /** Removes an event from the database and updates subscriptions */
  remove(event) {
    return this.database.remove(event);
  }
  /** Add an event to the store and notifies all subscribes it has updated */
  update(event) {
    return this.database.update(event);
  }
  /** Removes any event that is not being used by a subscription */
  prune(max2) {
    return this.database.prune(max2);
  }
  /** Check if the store has an event by id */
  hasEvent(id) {
    return this.database.hasEvent(id);
  }
  /** Get an event by id from the store */
  getEvent(id) {
    return this.database.getEvent(id);
  }
  /** Check if the store has a replaceable event */
  hasReplaceable(kind, pubkey, d) {
    return this.database.hasReplaceable(kind, pubkey, d);
  }
  /** Gets the latest version of a replaceable event */
  getReplaceable(kind, pubkey, identifier) {
    return this.database.getReplaceable(kind, pubkey, identifier);
  }
  /** Returns all versions of a replaceable event */
  getReplaceableHistory(kind, pubkey, identifier) {
    return this.database.getReplaceableHistory(kind, pubkey, identifier);
  }
  /** Get all events matching a filter */
  getByFilters(filters) {
    return this.database.getByFilters(filters);
  }
  /** Returns a timeline of events that match filters */
  getTimeline(filters) {
    return this.database.getTimeline(filters);
  }
  /** Sets the claim on the event and touches it */
  claim(event, claim) {
    this.database.claim(event, claim);
  }
  /** Checks if an event is claimed by anything */
  isClaimed(event) {
    return this.database.isClaimed(event);
  }
  /** Removes a claim from an event */
  removeClaim(event, claim) {
    this.database.removeClaim(event, claim);
  }
  /** Removes all claims on an event */
  clearClaim(event) {
    this.database.clearClaim(event);
  }
  /** Get or create a model on the event store */
  model(constructor, ...args) {
    let models = this.models.get(constructor);
    if (!models) {
      models = /* @__PURE__ */ new Map();
      this.models.set(constructor, models);
    }
    const key = constructor.getKey ? constructor.getKey(...args) : (0, import_hash_sum.default)(args);
    let model = models.get(key);
    if (!model) {
      const cleanup = () => {
        if (models.get(key) === model)
          models.delete(key);
      };
      model = constructor(...args)(this).pipe(
        // remove the model when its unsubscribed
        finalize(cleanup),
        // only subscribe to models once for all subscriptions
        share({
          connector: () => new ReplaySubject(1),
          resetOnComplete: () => timer(this.modelKeepWarm),
          resetOnRefCountZero: () => timer(this.modelKeepWarm)
        })
      );
      models.set(key, model);
    }
    return model;
  }
  /**
   * Creates an observable that streams all events that match the filter
   * @param filters
   * @param [onlyNew=false] Only subscribe to new events
   */
  filters(filters, onlyNew = false) {
    filters = Array.isArray(filters) ? filters : [filters];
    return merge(
      // merge existing events
      onlyNew ? EMPTY : from(this.getByFilters(filters)),
      // subscribe to future events
      this.insert$.pipe(filter((e) => matchFilters(filters, e)))
    );
  }
  /** Returns an observable that completes when an event is removed */
  removed(id) {
    const deleted = this.checkDeleted(id);
    if (deleted)
      return EMPTY;
    return this.remove$.pipe(
      // listen for removed events
      filter((e) => e.id === id),
      // complete as soon as we find a matching removed event
      take(1),
      // switch to empty
      mergeMap(() => EMPTY)
    );
  }
  /** Creates an observable that emits when event is updated */
  updated(event) {
    return this.database.update$.pipe(filter((e) => e.id === event || e === event));
  }
  // Helper methods for creating models
  /** Creates a {@link EventModel} */
  event(pointer) {
    if (typeof pointer === "string")
      pointer = { id: pointer };
    return this.model(EventModel, pointer);
  }
  replaceable(...args) {
    let pointer;
    if (args.length === 1) {
      pointer = args[0];
    } else if (args.length === 3 || args.length === 2) {
      let [kind, pubkey, identifier] = args;
      pointer = { kind, pubkey, identifier };
    }
    if (!pointer)
      throw new Error("Invalid arguments, expected address pointer or kind, pubkey, identifier");
    return this.model(ReplaceableModel, pointer);
  }
  /** Subscribe to an addressable event by pointer */
  addressable(pointer) {
    return this.model(ReplaceableModel, pointer);
  }
  /** Creates a {@link TimelineModel} */
  timeline(filters, includeOldVersion = false) {
    return this.model(TimelineModel, filters, includeOldVersion);
  }
  /** Subscribe to a users profile */
  profile(user) {
    return this.model(ProfileModel, user);
  }
  /** Subscribe to a users contacts */
  contacts(user) {
    if (typeof user === "string")
      user = { pubkey: user };
    return this.model(ContactsModel, user);
  }
  /** Subscribe to a users mutes */
  mutes(user) {
    if (typeof user === "string")
      user = { pubkey: user };
    return this.model(MuteModel, user);
  }
  /** Subscribe to a users NIP-65 mailboxes */
  mailboxes(user) {
    if (typeof user === "string")
      user = { pubkey: user };
    return this.model(MailboxesModel, user);
  }
  /** Subscribe to a users blossom servers */
  blossomServers(user) {
    if (typeof user === "string")
      user = { pubkey: user };
    return this.model(UserBlossomServersModel, user);
  }
  /** Subscribe to an event's reactions */
  reactions(event) {
    return this.model(ReactionsModel, event);
  }
  /** Subscribe to a thread */
  thread(root) {
    return this.model(ThreadModel, root);
  }
  /** Subscribe to a event's comments */
  comments(event) {
    return this.model(CommentsModel, event);
  }
  /** @deprecated use multiple {@link EventModel} instead */
  events(ids) {
    return this.model(EventsModel, ids);
  }
  /** @deprecated use multiple {@link ReplaceableModel} instead */
  replaceableSet(pointers) {
    return this.model(ReplaceableSetModel, pointers);
  }
};

export {
  Subject,
  BehaviorSubject,
  of,
  isObservable,
  lastValueFrom,
  firstValueFrom,
  map,
  NEVER,
  catchError,
  distinctUntilChanged,
  finalize,
  switchMap,
  require_hash_sum,
  getOrComputeCachedValue,
  convertToUrl,
  getURLFilename,
  IMAGE_EXT,
  decode2 as decode,
  abytes,
  aexists,
  aoutput,
  clean,
  createView4 as createView,
  rotr3 as rotr,
  bytesToHex3 as bytesToHex,
  toBytes4 as toBytes,
  Hash3 as Hash,
  createHasher2 as createHasher,
  randomBytes3 as randomBytes,
  parseBolt11,
  getEmojiTag,
  logger,
  EventSet,
  getHashtagTag,
  helpers_exports,
  withImmediateValueOrDefault,
  defined,
  getObservableValue,
  mapEventsToTimeline,
  mapEventsToStore,
  TimeoutError2 as TimeoutError,
  simpleTimeout,
  watchEventUpdates,
  watchEventsUpdates,
  models_exports,
  EventStore
};
/*! Bundled license information:

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/ciphers/esm/utils.js:
  (*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-ESJ34HX7.js.map

import { setHiddenContentEncryptionMethod } from "applesauce-core/helpers";
import { isHexKey } from "applesauce-core/helpers/string";
import { kinds } from "nostr-tools";
// Set encryption types for nostr connect events
setHiddenContentEncryptionMethod(kinds.NostrConnect, "nip44");
export function isErrorResponse(response) {
    return !!response.error;
}
export var Permission;
(function (Permission) {
    Permission["GetPublicKey"] = "get_pubic_key";
    Permission["SignEvent"] = "sign_event";
    Permission["Nip04Encrypt"] = "nip04_encrypt";
    Permission["Nip04Decrypt"] = "nip04_decrypt";
    Permission["Nip44Encrypt"] = "nip44_encrypt";
    Permission["Nip44Decrypt"] = "nip44_decrypt";
})(Permission || (Permission = {}));
export var NostrConnectMethod;
(function (NostrConnectMethod) {
    NostrConnectMethod["Connect"] = "connect";
    NostrConnectMethod["CreateAccount"] = "create_account";
    NostrConnectMethod["GetPublicKey"] = "get_public_key";
    NostrConnectMethod["SignEvent"] = "sign_event";
    NostrConnectMethod["Nip04Encrypt"] = "nip04_encrypt";
    NostrConnectMethod["Nip04Decrypt"] = "nip04_decrypt";
    NostrConnectMethod["Nip44Encrypt"] = "nip44_encrypt";
    NostrConnectMethod["Nip44Decrypt"] = "nip44_decrypt";
})(NostrConnectMethod || (NostrConnectMethod = {}));
/** Parse a bunker:// URI */
export function parseBunkerURI(uri) {
    const url = new URL(uri);
    // firefox puts pubkey part in host, chrome puts pubkey in pathname
    const remote = url.host || url.pathname.replace("//", "");
    if (!isHexKey(remote))
        throw new Error("Invalid bunker URI: remote is not a valid hex key");
    const relays = url.searchParams.getAll("relay");
    if (relays.length === 0)
        throw new Error("Invalid bunker URI: missing relays");
    const secret = url.searchParams.get("secret") ?? undefined;
    return { remote, relays, secret };
}
/** Creates a bunker:// URI from a {@link BunkerURI} object */
export function createBunkerURI(data) {
    const url = new URL(`bunker://${data.remote}`);
    data.relays.forEach((relay) => url.searchParams.append("relay", relay));
    if (data.secret)
        url.searchParams.set("secret", data.secret);
    return url.toString();
}
/** Parse a nostrconnect:// URI */
export function parseNostrConnectURI(uri) {
    const url = new URL(uri);
    const client = url.host || url.pathname.replace("//", "");
    if (!isHexKey(client))
        throw new Error("Invalid nostrconnect URI: client is not a valid hex key");
    const secret = url.searchParams.get("secret");
    const relays = url.searchParams.getAll("relay");
    if (!secret)
        throw new Error("Invalid nostrconnect URI: missing secret");
    if (relays.length === 0)
        throw new Error("Invalid nostrconnect URI: missing relays");
    const metadata = {
        name: url.searchParams.get("name") ?? undefined,
        image: url.searchParams.get("image") ?? undefined,
        url: url.searchParams.get("url") ?? undefined,
        permissions: url.searchParams.get("perms")?.split(",") ?? undefined,
    };
    /** Omit metadata if all values are undefined */
    if (Object.values(metadata).every((v) => v === undefined))
        return { client, secret, relays };
    else
        return { client, secret, relays, metadata };
}
/** Create a nostrconnect:// URI from a {@link NostrConnectURI} object */
export function createNostrConnectURI(data) {
    const params = new URLSearchParams();
    params.set("secret", data.secret);
    if (data.metadata?.name)
        params.set("name", data.metadata.name);
    if (data.metadata?.url)
        params.set("url", String(data.metadata.url));
    if (data.metadata?.image)
        params.set("image", data.metadata.image);
    if (data.metadata?.permissions)
        params.set("perms", data.metadata.permissions.join(","));
    for (const relay of data.relays)
        params.append("relay", relay);
    return `nostrconnect://${data.client}?` + params.toString();
}
/** Build an array of signing permissions for event kinds */
export function buildSigningPermissions(kinds) {
    return [Permission.GetPublicKey, ...kinds.map((k) => `${Permission.SignEvent}:${k}`)];
}
